  12:31:15.178  > do
	-- Config
	local LINES_PER_PRINT = 200
	local MAX_DUPLICATE_SOURCES = 2
	local MAX_SAME_TYPE_CHILDREN = 5  -- Limit identical child types per parent
	
	-- Filter out spammy object types
	local SKIP_TYPES = {
		"LineHandleAdornment", "SphereHandleAdornment", "ConeHandleAdornment",
		"CylinderHandleAdornment", "ImageHandleAdornment", "SelectionBox",
		"SelectionSphere", "Handles", "ArcHandles", "SurfaceSelection"
	}
	local skipSet = {}
	for _, t in ipairs(SKIP_TYPES) do skipSet[t] = true end

	-- Helpers
	local function normalizeNL(s) return (s:gsub("\r\n","\n"):gsub("\r","\n")) end
	local function splitLines(s)
		s = normalizeNL(s)
		local t = {}
		for line in (s.."\n"):gmatch("(.-)\n") do t[#t+1] = line end
		return t
	end
	local function getChildrenSorted(inst)
		local t = {}
		for _, child in ipairs(inst:GetChildren()) do
			if not skipSet[child.ClassName] then
				t[#t+1] = child
			end
		end
		table.sort(t, function(a,b)
			return a.ClassName==b.ClassName and a.Name:lower()<b.Name:lower() or a.ClassName<b.ClassName
		end)
		return t
	end

	-- Chunked printing
	local buf = {}
	local function out(s)
		buf[#buf+1] = s
		if #buf >= LINES_PER_PRINT then
			print(table.concat(buf, "\n"))
			buf = {}
		end
	end
	local function flush()
		if #buf > 0 then
			print(table.concat(buf, "\n"))
			buf = {}
		end
	end

	-- Try to read source
	local function getSource(lua)
		local ok, src = pcall(function() return lua.Source end)
		if ok and type(src) == "string" then return src end
		local ok2, sesrc = pcall(function()
			return game:GetService("ScriptEditorService"):GetEditorSource(lua)
		end)
		if ok2 and type(sesrc) == "string" then return sesrc end
		return nil
	end

	-- Dump Explorer tree (with spam filtering)
	local function dumpHierarchy()
		out("=== Explorer Hierarchy (filtered, max " .. MAX_SAME_TYPE_CHILDREN .. " per type) ===")
		local function rec(inst, depth)
			local indent = string.rep("  ", depth)
			if depth == 0 then
				out("game")
			else
				out(string.format("%s[%s] %s", indent, inst.ClassName, inst.Name))
			end
			
			-- Group children by type and limit repetitive ones
			local children = getChildrenSorted(inst)
			local typeCount = {}
			for _, ch in ipairs(children) do
				local count = typeCount[ch.ClassName] or 0
				if count < MAX_SAME_TYPE_CHILDREN then
					typeCount[ch.ClassName] = count + 1
					rec(ch, depth + 1)
				elseif count == MAX_SAME_TYPE_CHILDREN then
					typeCount[ch.ClassName] = count + 1
					out(string.format("%s  ... (%d more %s objects)", indent, 
						#inst:GetChildren() - count, ch.ClassName))
				end
			end
		end
		rec(game, 0)
		out("")
	end

	-- Dump scripts + source
	local function dumpScripts()
		out(string.format("=== Lua Scripts + Source (max %d identical copies) ===", MAX_DUPLICATE_SOURCES))
		local scripts = {}
		for _, inst in ipairs(game:GetDescendants()) do
			if inst:IsA("LuaSourceContainer") and not skipSet[inst.ClassName] then
				scripts[#scripts+1] = inst
			end
		end
		table.sort(scripts, function(a,b) return a:GetFullName() < b:GetFullName() end)

		local srcCount, total, printed, skipped = {}, #scripts, 0, 0
		for _, s in ipairs(scripts) do
			local src = getSource(s)
			if not src then
				out(string.format(">>> game.%s (%s) — [source not accessible]", s:GetFullName(), s.ClassName))
			else
				src = normalizeNL(src)
				local count = srcCount[src] or 0
				if count >= MAX_DUPLICATE_SOURCES then
					skipped = skipped + 1
				else
					srcCount[src] = count + 1
					printed = printed + 1
					local lines = splitLines(src)
					out(string.format(">>> game.%s (%s) — %d lines", s:GetFullName(), s.ClassName, #lines))
					for _, line in ipairs(lines) do out(line) end
					out("")
				end
			end
		end
		out(string.format("=== Scripts scanned: %d | Printed: %d | Skipped duplicates beyond %d: %d ===",
			total, printed, MAX_DUPLICATE_SOURCES, skipped))
	end

	dumpHierarchy()
	dumpScripts()
	flush()
end  -  Studio
  12:31:15.182  === Explorer Hierarchy (filtered, max 5 per type) ===
game
  [] FilteredSelection
  [] FilteredSelection
  [] FilteredSelection
  [] FilteredSelection
  [] FilteredSelection
  [AdService] AdService
  [AnalyticsService] AnalyticsService
  [AnimationClipProvider] AnimationClipProvider
  [AssetService] AssetService
  [AvatarCreationService] AvatarCreationService
  [BadgeService] BadgeService
  [BrowserService] BrowserService
  [CaptureService] CaptureService
  [ChangeHistoryService] ChangeHistoryService
  [Chat] Chat
  [CollectionService] CollectionService
  [CommerceService] CommerceService
  [ContentProvider] ContentProvider
  [ContextActionService] ContextActionService
  [ControllerService] ControllerService
    [HumanoidController] Instance
  [CookiesService] CookiesService
  [CoreGui] CoreGui
    [Folder] KojoGizmos
      [BoxHandleAdornment] BoxHandle
      [BoxHandleAdornment] BoxHandle
      [BoxHandleAdornment] BoxHandle
      [BoxHandleAdornment] BoxHandle
      [BoxHandleAdornment] BoxHandle
      ... (22 more BoxHandleAdornment objects)
    [Folder] LightGuides
    [Folder] MoonAnimator2Gui
      [Folder] MoonAnimator2UI3D
    [Folder] PathEditFolder
    [Folder] PlaceAnnotations
      [ScreenGui] PlaceAnnotationsGui
        [Frame] FoundationCursorContainer
        [Frame] Manager
        [StyleLink] StyleLink
    ... (27 more Folder objects)
    [ObjectValue] GeomToolsToolbar
      [ObjectValue] GapFill
      [ObjectValue] Owner
    [ObjectValue] Plugins By Robo
      [ObjectValue] Add Easy Texture
      [ObjectValue] Owner
    [ScreenGui] Add Easy TexturesUI
    [ScreenGui] BezierPathGui
      [Frame] App
        [Frame] BrickColor
          [TextButton] Dropdown
            [TextButton] Capture
            [TextButton] DropdownItem
              [Frame] ColorFrame
            [TextButton] DropdownItem
              [Frame] ColorFrame
            [TextButton] DropdownItem
              [Frame] ColorFrame
            [TextButton] DropdownItem
              [Frame] ColorFrame
            ... (60 more TextButton objects)
          [TextButton] Input
            [Frame] SelectedColor
            [ImageLabel] Arrow
          [TextLabel] Label
            [TextLabel] Tooltip
        [Frame] Divider
        [Frame] Height
          [TextButton] Input
            [TextBox] TextBox
          [TextLabel] Label
            [TextLabel] Tooltip
        [Frame] Material
          [TextButton] Dropdown
            [TextButton] Capture
            [TextButton] DropdownItem
            [TextButton] DropdownItem
            [TextButton] DropdownItem
            [TextButton] DropdownItem
            ... (41 more TextButton objects)
          [TextButton] Input
            [ImageLabel] Arrow
          [TextLabel] Label
            [TextLabel] Tooltip
        [Frame] NumSegments
          [TextButton] Input
            [TextBox] TextBox
          [TextLabel] Label
          [TextLabel] Tooltip
        ... (9 more Frame objects)
        [TextButton] Exit
        [TextButton] Finish
        [TextButton] Reset
        [TextButton] Undo
        [TextLabel] Title
    [ScreenGui] BrickCutterGui
      [Frame] Frame
        [TextBox] TextBox
          [TextLabel] TextLabel
      [Part] Part
      [Part] Part
      [Part] Part
      [Part] Part
      [Sound] SoundAxisChange
      [Sound] SoundCancel
      [Sound] SoundCut
      [Sound] SoundLunge
      [Sound] SoundUnsheath
    [ScreenGui] CharacterGui
      [Frame] Main
        [Frame] Container
          [Frame] SpawnButtons
            [TextButton] SpawnCharacterR15
            [TextButton] SpawnCharacterR6
            [UIListLayout] UIListLayout
          [ImageLabel] Character
          [TextButton] SpawnAtOrigin
            [TextLabel] Check
            [TextLabel] Label
          [TextButton] User
            [TextBox] TextBox
          [UIListLayout] UIListLayout
        [Frame] Topbar
          [TextLabel] Title
        [TextButton] Exit
    [ScreenGui] CodifyGui
      [Frame] Background
      [Frame] Main
        [Frame] Panel
          [Frame] Background
            [Frame] ScrollBackground
          [ScrollingFrame] Console
            [Frame] Script
              [TextBox] Code
              [UIListLayout] UIListLayout
            [Frame] Settings
              [Frame] AllowScriptSource
                [StringValue] Setting
                [TextButton] Checkbox
                  [ImageLabel] Checked
                  [ImageLabel] Unchecked
                [TextLabel] Description
                [TextLabel] Title
              [Frame] MessageOnStartup
                [StringValue] Setting
                [TextButton] Checkbox
                  [ImageLabel] Checked
                  [ImageLabel] Unchecked
                [TextLabel] Description
                [TextLabel] Title
              [Frame] Selection
                [StringValue] Setting
                [TextButton] Toggle
                  [ImageLabel] children
                    [StringValue] Choice
                  [ImageLabel] descendants
                    [StringValue] Choice
                  [ImageLabel] selected
                    [StringValue] Choice
                [TextLabel] Choice
                [TextLabel] Description
                [TextLabel] Title
              [Frame] SmallerCode
                [StringValue] Setting
                [TextButton] Checkbox
                  [ImageLabel] Checked
                  [ImageLabel] Unchecked
                [TextLabel] Description
                [TextLabel] Title
              [UIListLayout] UIListLayout
          [TextButton] ScrollDownBtn
            [ImageLabel] Arrow
          [TextButton] ScrollUpBtn
            [ImageLabel] Arrow
        [Frame] Tabs
          [TextButton] ScriptBtn
          [TextButton] SettingsBtn
        [Frame] Top
          [TextButton] CloseBtn
          [TextLabel] Title
      [Frame] Message
        [Frame] Background
        [TextBox] Text
        [TextButton] CloseBtn1
        [TextButton] CloseBtn2
        [TextLabel] Text2
        [TextLabel] Title
      [Frame] Warning
        [TextButton] ContinueBtn
        [TextButton] StopBtn
        [TextLabel] Contact
        [TextLabel] Info
        [TextLabel] Message
        [TextLabel] Smiley
        [TextLabel] Title
    ... (27 more ScreenGui objects)
  [DataStoreService] DataStoreService
  [Debris] Debris  -  Edit
  12:31:15.191    [DebuggerManager] DebuggerManager
    [ScriptDebugger] AutoPoopSystemDebugger
    [ScriptDebugger] AutoPrimaryScriptDebugger
    [ScriptDebugger] AutoPrimaryScriptDebugger
    [ScriptDebugger] AutoPrimaryScriptDebugger
    [ScriptDebugger] AutoPrimaryScriptDebugger
    ... (76 more ScriptDebugger objects)
  [DraftsService] DraftsService
  [DraggerService] DraggerService
  [FeatureRestrictionManager] FeatureRestrictionManager
  [FriendService] FriendService
  [GamePassService] GamePassService
  [GamepadService] GamepadService
  [GenerationService] GenerationService
  [Geometry] Geometry
  [GroupService] GroupService
  [GuiService] GuiService
    [LocalizationTable] FoundationLocalization
    [ScreenshotHud] ScreenshotHud
  [GuidRegistryService] GuidRegistryService
  [HSRDataContentProvider] HSRDataContentProvider
  [HapticService] HapticService
  [HeapProfilerService] HeapProfilerService
  [HttpRbxApiService] HttpRbxApiService
  [HttpService] HttpService
  [InsertService] InsertService
    [StringValue] InsertionHash
  [JointsService] JointsService
  [KeyboardService] KeyboardService
  [KeyframeSequenceProvider] KeyframeSequenceProvider
  [Lighting] Lighting
    [Atmosphere] Atmosphere
    [BloomEffect] Bloom
    [BlurEffect] Blur
    [ColorCorrectionEffect] ColorCorrection
    [Sky] Sky
    [SunRaysEffect] SunRays
  [LocalizationService] LocalizationService
  [LogService] LogService
  [LuaWebService] LuaWebService
  [MarketplaceService] MarketplaceService
  [MaterialService] MaterialService
  [MemStorageService] MemStorageService
    [MemStorageConnection] MemStorageConnection
    [MemStorageConnection] MemStorageConnection
    [MemStorageConnection] MemStorageConnection
    [MemStorageConnection] MemStorageConnection
    [MemStorageConnection] MemStorageConnection
    ... (57 more MemStorageConnection objects)
  [MeshContentProvider] MeshContentProvider
  [MicroProfilerService] MicroProfilerService
  [MouseService] MouseService
  [NetworkClient] NetworkClient
    [ClientReplicator] ClientReplicator
  [NotificationService] NotificationService
  [PackageService] PackageService
  [PathfindingService] PathfindingService
  [PermissionsService] PermissionsService
  [PhysicsService] PhysicsService
  [PlacesService] PlacesService
  [Players] Players
    [Player] mohamad2041
      [Backpack] Backpack
      [PlayerScripts] PlayerScripts
  [PluginDebugService] PluginDebugService
  [PluginGuiService] PluginGuiService
    [DockWidgetPluginGui] Add Easy Texture
      [Frame] RoactTree
        [Frame] Info
          [Frame] BarHorizontal
            [Frame] BarBackground
              [TextButton] Bar
            [ImageButton] LeftArrow
            [ImageButton] RightArrow
          [Frame] BarVertical
            [Frame] BarBackground
              [TextButton] Bar
            [ImageButton] DownArrow
            [ImageButton] UpArrow
          [Frame] Clipping
            [Frame] Holder
              [Frame] props
                [Frame] BarHorizontal
                  [Frame] BarBackground
                    [TextButton] Bar
                  [ImageButton] LeftArrow
                  [ImageButton] RightArrow
                [Frame] BarVertical
                  [Frame] BarBackground
                    [TextButton] Bar
                  [ImageButton] DownArrow
                  [ImageButton] UpArrow
                [Frame] Clipping
                  [Frame] Holder
                    [Frame] propBgColor
                      [Frame] 1
                        [TextLabel] 1
                        [UIPadding] 2
                      [Frame] 2
                        [TextLabel] Label
                        [UIPadding] 1
                    [Frame] propCategory
                      [Frame] 1
                        [TextLabel] 1
                        [UIPadding] 2
                      [Frame] 2
                        [TextLabel] Label
                          [UIPadding] Padding
                        [UIPadding] 1
                    [Frame] propColor
                      [Frame] 1
                        [TextLabel] 1
                        [UIPadding] 2
                      [Frame] 2
                        [TextLabel] Label
                        [UIPadding] 1
                    [Frame] propCreator
                      [Frame] 1
                        [TextLabel] 1
                        [UIPadding] 2
                      [Frame] 2
                        [TextLabel] Label
                        [UIPadding] 1
                    [Frame] propSize
                      [Frame] 1
                        [TextLabel] 1
                        [UIPadding] 2
                      [Frame] 2
                        [TextLabel] Label
                        [UIPadding] 1
                    ... (3 more Frame objects)
                    [TextLabel] propTags
                      [UIPadding] Padding
                    [UIListLayout] Layout
              [ImageButton] TextureImage
                [UIAspectRatioConstraint] SameSize
              [TextButton] Apply
              [TextButton] Close
              [TextButton] Delete
              [TextLabel] Label
              [UIListLayout] Layout
        [Frame] Mainbar
          [TextLabel] Info
        [Frame] MainHolder
          [Frame] AddMenu
            [Frame] Menu
              [ImageLabel] TexturePreview
              [TextButton] Add
              [TextButton] PickNew
              [TextLabel] Category
              [TextLabel] Name
              [TextLabel] Tags
            [Frame] Pick
              [TextButton] Button
              [TextLabel] Disc
            [TextButton] back
          [Frame] Main
            [Frame] BarHorizontal
              [Frame] BarBackground
                [TextButton] Bar
              [ImageButton] LeftArrow
              [ImageButton] RightArrow
            [Frame] BarVertical
              [Frame] BarBackground
                [TextButton] Bar
              [ImageButton] DownArrow
              [ImageButton] UpArrow
            [Frame] Clipping
              [Frame] Holder
                [ImageButton] 012809EC-A3FA-9EB6-E1D0-FAFF34208CCA
                  [ImageButton] Fav
                    [UIAspectRatioConstraint] UISize
                  [ImageButton] Info
                    [UIAspectRatioConstraint] UISize
                [ImageButton] 0136CD03-92D4-2D13-A076-76632A1C81A9
                  [ImageButton] Fav
                    [UIAspectRatioConstraint] UISize
                  [ImageButton] Info
                    [UIAspectRatioConstraint] UISize
                [ImageButton] 015D4D50-D979-3A42-1C2B-438F8D02AD31
                  [ImageButton] Fav
                    [UIAspectRatioConstraint] UISize
                  [ImageButton] Info
                    [UIAspectRatioConstraint] UISize
                [ImageButton] 029FB024-3A66-901E-BDDA-849264A81EDC
                  [ImageButton] Fav
                    [UIAspectRatioConstraint] UISize
                  [ImageButton] Info
                    [UIAspectRatioConstraint] UISize
                [ImageButton] 04FC90BC-F236-2BAC-0044-0C20EF58F039
                  [ImageButton] Fav
                    [UIAspectRatioConstraint] UISize
                  [ImageButton] Info
                    [UIAspectRatioConstraint] UISize
                ... (401 more ImageButton objects)
                [UIGridLayout] Layout
          [Frame] MainTabs
            [Frame] BarHorizontal
              [Frame] BarBackground
                [TextButton] Bar  -  Edit
  12:31:15.191                [ImageButton] LeftArrow
              [ImageButton] RightArrow
            [Frame] BarVertical
              [Frame] BarBackground
                [TextButton] Bar
              [ImageButton] DownArrow
              [ImageButton] UpArrow
            [Frame] Clipping
              [Frame] Holder
                [ImageButton] All
                  [Frame] Content
                    [ImageLabel] Icon
                    [TextLabel] Label
                    [UIListLayout] UIListLayout
                  [Frame] UpperBorder
                [ImageButton] Basic
                  [Frame] Content
                    [ImageLabel] Icon
                    [TextLabel] Label
                    [UIListLayout] UIListLayout
                  [Frame] LowerBorder
                [ImageButton] Low poly
                  [Frame] Content
                    [ImageLabel] Icon
                    [TextLabel] Label
                    [UIListLayout] UIListLayout
                  [Frame] LowerBorder
                [ImageButton] Realistic
                  [Frame] Content
                    [ImageLabel] Icon
                    [TextLabel] Label
                    [UIListLayout] UIListLayout
                  [Frame] LowerBorder
                [ImageButton] Stylized
                  [Frame] Content
                    [ImageLabel] Icon
                    [TextLabel] Label
                    [UIListLayout] UIListLayout
                  [Frame] LowerBorder
                [UIListLayout] Layout
        [Frame] SidebarHolder
          [Frame] Sidebar
            [Frame] BarHorizontal
              [Frame] BarBackground
                [TextButton] Bar
              [ImageButton] LeftArrow
              [ImageButton] RightArrow
            [Frame] BarVertical
              [Frame] BarBackground
                [TextButton] Bar
              [ImageButton] DownArrow
              [ImageButton] UpArrow
            [Frame] Clipping
              [Frame] Holder
                [Frame] .Instant Apply
                  [Frame] 1
                    [TextLabel] 1
                    [UIPadding] 2
                  [Frame] 2
                    [Frame] Box
                      [Frame] Box
                      [TextButton] Button
                    [UIPadding] 1
                [Frame] All Sides
                  [Frame] 1
                    [TextLabel] 1
                    [UIPadding] 2
                  [Frame] 2
                    [Frame] Box
                      [Frame] Box
                      [TextButton] Button
                    [UIPadding] 1
                [Frame] Back
                  [Frame] 1
                    [TextLabel] 1
                    [UIPadding] 2
                  [Frame] 2
                    [Frame] Box
                      [Frame] Box
                      [TextButton] Button
                    [UIPadding] 1
                [Frame] Bottom
                  [Frame] 1
                    [TextLabel] 1
                    [UIPadding] 2
                  [Frame] 2
                    [Frame] Box
                      [Frame] Box
                      [TextButton] Button
                    [UIPadding] 1
                [Frame] Front
                  [Frame] 1
                    [TextLabel] 1
                    [UIPadding] 2
                  [Frame] 2
                    [Frame] Box
                      [Frame] Box
                      [TextButton] Button
                    [UIPadding] 1
                ... (4 more Frame objects)
                [UIListLayout] Layout
          [Frame] SidebarTabs
            [ImageButton] Apply Options
              [Frame] Content
                [ImageLabel] Icon
                [TextLabel] Label
                [UIListLayout] UIListLayout
              [Frame] UpperBorder
            [ImageButton] History
              [Frame] Content
                [ImageLabel] Icon
                [TextLabel] Label
                [UIListLayout] UIListLayout
              [Frame] LowerBorder
            [ImageButton] List Options
              [Frame] Content
                [ImageLabel] Icon
                [TextLabel] Label
                [UIListLayout] UIListLayout
              [Frame] LowerBorder
            [ImageButton] Tag Options
              [Frame] Content
                [ImageLabel] Icon
                [TextLabel] Label
                [UIListLayout] UIListLayout
              [Frame] LowerBorder
            [ImageButton] Texture Options
              [Frame] Content
                [ImageLabel] Icon
                [TextLabel] Label
                [UIListLayout] UIListLayout
              [Frame] LowerBorder
            [UIGridLayout] UIGridLayout
        [ImageButton] Button
        [TextLabel] Tooltip
          [UIPadding] Padding
    [DockWidgetPluginGui] Brushtool
      [Frame] Brushtool
        [Frame] List
          [Frame] Content
            [Frame] Alert
              [TextLabel] Text
            [Frame] ResetField
              [Frame] Checkbox
                [Frame] Button
                  [TextButton] StatefulButton
                [ImageLabel] Border
                  [Frame] ContentFrame
                  [ImageLabel] Border
              [Frame] Text
                [TextLabel] Text
              [UIListLayout] HList
            [Frame] Sep1
            [Frame] Sep2
            [Frame] Sep3
            ... (5 more Frame objects)
            [ImageLabel] BrushIcon
            [ImageLabel] StartButton
              [Frame] ContentFrame
                [Frame] Button
                  [TextButton] StatefulButton
                  [TextLabel] Text
              [ImageLabel] Border
            [TextLabel] TitleText
            [UIListLayout] UIListLayout
    [DockWidgetPluginGui] PluginGui
      [Frame] Background
      [Frame] Main
        [ImageLabel] ScrollTrack
        [ScrollingFrame] _smoothinputframe
        [ScrollingFrame] ScrollArea
          [UIListLayout] UIListLayout
          [UIPadding] UIPadding
      [Frame] Message
        [ImageLabel] Icon
        [TextLabel] Text
        [UIListLayout] UIListLayout
      [Frame] UpdateNotice
        [ImageLabel] Background
        [ImageLabel] Icon
        [TextLabel] Label
      [ImageButton] Convert
        [TextLabel] Label
      [ImageButton] Retry
        [TextLabel] Label
      [ImageLabel] FindClass
        [TextBox] TextBox
        [TextLabel] Placeholder
    [DockWidgetPluginGui] PluginGui
      [Frame] MainGUI
        [Frame] Background
        [Frame] Frame
          [Frame] Searchbox
            [ScrollingFrame] Frame
              [TextLabel] Beams
                [ImageButton] button
                [TextLabel] count
                  [UIPadding] UIPadding
                [UIPadding] UIPadding
              [TextLabel] Bursts  -  Edit
  12:31:15.346                  [ImageButton] button
                [TextLabel] count
                  [UIPadding] UIPadding
                [UIPadding] UIPadding
              [TextLabel] Debris
                [ImageButton] button
                [TextLabel] count
                  [UIPadding] UIPadding
                [UIPadding] UIPadding
              [TextLabel] Debris
                [ImageButton] button
                [TextLabel] count
                  [UIPadding] UIPadding
                [UIPadding] UIPadding
              [TextLabel] divider
                [UIPadding] UIPadding
              ... (16 more TextLabel objects)
              [UIListLayout] UIListLayout
            [TextLabel] divider
              [UIPadding] UIPadding
            [TextLabel] template
              [ImageButton] button
              [TextLabel] count
                [UIPadding] UIPadding
              [UIPadding] UIPadding
            [UICorner] UICorner
            [UIStroke] UIStroke
          [ImageButton] Button
          [ImageButton] Cross
          [ImageButton] Insert
          [ImageButton] Settings
          [ImageLabel] Arrow
          [TextLabel] Current
            [UICorner] UICorner
            [UIPadding] UIPadding
          [UICorner] UICorner
          [UIStroke] UIStroke
        [Frame] Insert
          [Frame] flipbookFrame
            [TextButton] by2
              [UICorner] UICorner
              [UIStroke] UIStroke
            [TextButton] by4
              [UIStroke] UIStroke
            [TextButton] by8
              [UICorner] UICorner
              [UIStroke] UIStroke
            [UICorner] UICorner
            [UIListLayout] UIListLayout
            [UIStroke] UIStroke
          [TextBox] idBox
            [UICorner] UICorner
            [UIPadding] UIPadding
            [UIStroke] UIStroke
          [TextButton] insertButton
            [UICorner] UICorner
            [UIPadding] UIPadding
            [UIStroke] UIStroke
          [TextLabel] text
            [UICorner] UICorner
          [UICorner] UICorner
          [UIPadding] UIPadding
          [UIStroke] UIStroke
        [Frame] Textures
          [Frame] Selected
            [Frame] Holder
              [Frame] textureFrame
                [TextBox] textureId
                [UICorner] UICorner
                [UIPadding] UIPadding
                [UIStroke] UIStroke
              [TextButton] get
                [UICorner] UICorner
                [UIPadding] UIPadding
                [UIStroke] UIStroke
              [TextButton] set
                [UICorner] UICorner
                [UIPadding] UIPadding
                [UIStroke] UIStroke
              [UIListLayout] UIListLayout
            [Frame] Image
              [ImageButton] Delete
              [ImageButton] Star
                [ImageLabel] Fill
              [ImageLabel] ImageLabel
                [UICorner] UICorner
              [ImageLabel] Previewer
                [UICorner] UICorner
              [UICorner] UICorner
              [UIStroke] UIStroke
            [UICorner] UICorner
            [UIListLayout] UIListLayout
            [UIPadding] UIPadding
            [UIStroke] UIStroke
          [ScrollingFrame] Frame
            [Frame] http://www.roblox.com/asset/?id=10001969939
              [ImageButton] Button
              [ImageLabel] ImageLabel
              [ImageLabel] Star
              [IntValue] Id
              [StringValue] TextureId
              [UICorner] UICorner
              [UIStroke] UIStroke
            [Frame] http://www.roblox.com/asset/?id=10031303479
              [ImageButton] Button
              [ImageLabel] ImageLabel
              [ImageLabel] Star
              [IntValue] Id
              [StringValue] TextureId
              [UICorner] UICorner
              [UIStroke] UIStroke
            [Frame] http://www.roblox.com/asset/?id=1006711101
              [ImageButton] Button
              [ImageLabel] ImageLabel
              [ImageLabel] Star
              [IntValue] Id
              [StringValue] TextureId
              [UICorner] UICorner
              [UIStroke] UIStroke
            [Frame] http://www.roblox.com/asset/?id=10101314593
              [ImageButton] Button
              [ImageLabel] ImageLabel
              [ImageLabel] Star
              [IntValue] Id
              [StringValue] TextureId
              [UICorner] UICorner
              [UIStroke] UIStroke
            [Frame] http://www.roblox.com/asset/?id=1012159668
              [ImageButton] Button
              [ImageLabel] ImageLabel
              [ImageLabel] Star
              [IntValue] Id
              [StringValue] TextureId
              [UICorner] UICorner
              [UIStroke] UIStroke
            ... (7214 more Frame objects)
            [UIGridLayout] UIGridLayout
              [UIAspectRatioConstraint] UIAspectRatioConstraint
            [UIPadding] Padding
          [UICorner] UICorner
          [UIStroke] UIStroke
        [StringValue] Current
        [UIPadding] Padding
    [DockWidgetPluginGui] PluginGui
      [TextBox] TextBox
    ... (8 more DockWidgetPluginGui objects)
  [PluginManagementService] PluginManagementService
  [PointsService] PointsService
  [PolicyService] PolicyService
  [ProcessInstancePhysicsService] ProcessInstancePhysicsService
  [ProximityPromptService] ProximityPromptService
  [PublishService] PublishService
  [RemoteDebuggerServer] RemoteDebuggerServer
  [ReplicatedFirst] ReplicatedFirst
  [ReplicatedStorage] ReplicatedStorage
    [Folder] PoopFolder
      [Model] BlackHolePoop
        [UnionOperation] Poop
          [Attachment] MIDDLE
            [ParticleEmitter] ABYSS
            [ParticleEmitter] CORE
            [ParticleEmitter] CORE RING
            [ParticleEmitter] CREEPING DARK
            [ParticleEmitter] VOID
      [Model] BloodyPoop
        [UnionOperation] Poop
          [Attachment] Attachment
            [ParticleEmitter] BloodHit
            [ParticleEmitter] ParticleEmitter
            [ParticleEmitter] ParticleEmitter
            [ParticleEmitter] ParticleEmitter
            [ParticleEmitter] slash5
      [Model] BurntPoop
        [UnionOperation] Poop
          [Attachment] Explosion
            [ParticleEmitter] BrightWave (5)
            [ParticleEmitter] DarkWave (5)
            [ParticleEmitter] Sparks (30)
      [Model] ChainedGalaxyPoop
        [UnionOperation] Poop
          [Attachment] Attachment
          [Attachment] Attachment
            [ParticleEmitter] cresents
            [ParticleEmitter] flame
            [ParticleEmitter] flame 2
            [ParticleEmitter] glow
            [ParticleEmitter] glow 2
            ... (1 more ParticleEmitter objects)
          [Attachment] Attachment
            [ParticleEmitter] balls
            [ParticleEmitter] stars
          [Attachment] Attachment
          [Attachment] Attachment
          ... (8 more Attachment objects)
          [Beam] chain
          [Beam] chain
          [Beam] chain..
          [Beam] chainh
          [PointLight] PointLight
          [RotateV] RotateV  -  Edit
  12:31:15.347        [Model] DiamondPoop
        [UnionOperation] Poop
          [Attachment] Block(*)
            [ParticleEmitter] CenterStar (30)
            [ParticleEmitter] Radial(1)
            [ParticleEmitter] Saprks (30)
          [Attachment] Ground2
            [ParticleEmitter] Beams
            [ParticleEmitter] Center1
            [ParticleEmitter] Center2
            [ParticleEmitter] Circle
            [ParticleEmitter] Traces
          [Attachment] Part1
            [ParticleEmitter] Charge
            [ParticleEmitter] Swirl
          [Attachment] PerfectBlock(*)
            [ParticleEmitter] CenterPiece (10)
            [ParticleEmitter] CenterStar (30)
            [ParticleEmitter] CenterWave (10)
            [ParticleEmitter] Radial(1)
            [ParticleEmitter] Saprks (30)
      ... (20 more Model objects)
    [ModuleScript] ShopConfig
    [ModuleScript] TutorialConfig
    [RemoteEvent] PoopGainPopupEvent
    [RemoteEvent] PortalTeleportClient
    [RemoteEvent] ZoneChangedEvent
    [RemoteEvent] ZoneEnteredEvent
    [RemoteEvent] ZoneUnlockedEvent
    [RemoteFunction] FilteringFunction
  [RunService] Run Service
  [ScriptContext] Script Context
  [ScriptEditorService] ScriptEditorService
    [ScriptDocument] CommandBar
    [ScriptDocument] ReplicatedStorage.ShopConfig
    [ScriptDocument] ReplicatedStorage.TutorialConfig
    [ScriptDocument] ServerScriptService.AutoPoopSystem
    [ScriptDocument] ServerScriptService.BoostsServer
    ... (24 more ScriptDocument objects)
  [ScriptProfilerService] ScriptProfilerService
  [ScriptService] ScriptService
  [Selection] Selection
  [SelectionHighlightManager] SelectionHighlightManager
  [ServerScriptService] ServerScriptService
    [Script] AutoPoopSystem
    [Script] BoostsServer
    [Script] GroupRewardsHandler
    [Script] LeaderboardsManager
    [Script] leaderstats
    ... (6 more Script objects)
  [ServerStorage] ServerStorage
    [Folder] Brushtool2_Plugin_Storage
      [Folder] 532837911_BrushtoolBrushObjects
        [Folder] {3364ac02-b7c2-4642-a960-3d71f9c2083e}
          [Model] Tree1
            [MeshPart] Leaves1
            [MeshPart] Leaves2
            [MeshPart] Trunk
        [Folder] {559ba22d-1438-4f06-9447-bed93c9a5d6a}
          [Model] Tree2
            [MeshPart] MeshPart
            [MeshPart] MeshPart
        [Folder] {75742758-9bc8-4855-99e7-1fd9e7d1fc03}
          [Model] Tree3
            [MeshPart] Leaves
            [MeshPart] Leaves
            [MeshPart] Leaves
            [MeshPart] Trunk
        [Folder] {7f61b0d5-8d4b-4e05-a72f-c1d84aabf6ad}
          [Model] Tree4
            [MeshPart] Leaf
            [MeshPart] Leaf
            [MeshPart] Leaf
            [MeshPart] Leaf
            [MeshPart] Leaf
            ... (12 more MeshPart objects)
        [Folder] {9f9b4bb7-2b07-4343-ba42-09e26b0526c3}
          [MeshPart] Grass
        ... (2 more Folder objects)
      [Folder] 532837911_BrushtoolReferences
        [Folder] brushedParent
          [ObjectValue] Value
        [Folder] stampedParent
          [ObjectValue] Value
      [Folder] 532837911_BrushtoolStampObjects
        [Folder] {EA0887D3-1F39-4F5C-88E9-9C2341526468}
          [Model] CanopyTent
            [Model] Collider
              [MeshPart] Canopy
              [Part] Part
              [Part] Part
              [Part] Part
              [Part] Part
              [Part] Part
            [Model] Visual
              [Part] Canopy
                [SpecialMesh] Mesh
              [Part] Legs
                [SpecialMesh] Mesh
            [Part] Base
      [Folder] 532837911_BrushtoolTable
        [StringValue] brush
        [StringValue] brushObjects
        [StringValue] erase
        [StringValue] stamp
        [StringValue] stampObjects
    [Folder] VFX
      [Folder] Blue's Particle Effect kit
        [Part] Part
          [ParticleEmitter] Dots 1
          [ParticleEmitter] Dots 2
        [Part] Part
          [Attachment] Attachment
            [ParticleEmitter] Circles
            [ParticleEmitter] Flare
            [ParticleEmitter] Rays
            [ParticleEmitter] Rays
        [Part] Part
          [Attachment] Attachment
            [ParticleEmitter] Bits
            [ParticleEmitter] Bits_Small
            [ParticleEmitter] Wave
            [ParticleEmitter] Wave
        [Part] Part
          [ParticleEmitter] Circle
        [Part] Part
          [ParticleEmitter] Purple Expanding
        ... (11 more Part objects)
      [Folder] Cool Effect Pack
        [Folder] Blood
          [Part] A - Droplets
            [ParticleEmitter] Blood Droplets
          [Part] B - Puddle
            [Attachment] Middle
              [ParticleEmitter] Blood
          [Part] C - Pool
            [Attachment] Middle
              [ParticleEmitter] Blood
          [Part] D - Bleeding
            [Attachment] Middle
              [ParticleEmitter] Blood
          [Part] E - Gushing
            [Attachment] Middle
              [ParticleEmitter] Blood
            [ParticleEmitter] Splash
          ... (5 more Part objects)
        [Folder] Characters
          [Model] AuraVFX
            [BodyColors] Body Colors
            [Humanoid] Humanoid
              [Animator] Animator
              [HumanoidDescription] HumanoidDescription
                [BodyPartDescription] BodyPartDescription
                [BodyPartDescription] BodyPartDescription
                [BodyPartDescription] BodyPartDescription
                [BodyPartDescription] BodyPartDescription
                [BodyPartDescription] BodyPartDescription
                ... (1 more BodyPartDescription objects)
            [Part] Head
              [Attachment] FaceCenterAttachment
              [Attachment] FaceFrontAttachment
              [Attachment] HairAttachment
              [Attachment] HatAttachment
              [ParticleEmitter] Aura1
              [ParticleEmitter] Aura2
              [ParticleEmitter] Smoke1
              [SpecialMesh] Mesh
            [Part] HumanoidRootPart
              [Attachment] RootAttachment
              [Motor6D] RootJoint
            [Part] Left Arm
              [Attachment] LeftGripAttachment
              [Attachment] LeftShoulderAttachment
              [ParticleEmitter] Aura1
              [ParticleEmitter] Aura2
              [ParticleEmitter] Smoke1
            [Part] Left Leg
              [Attachment] LeftFootAttachment
            [Part] Right Arm
              [Attachment] RightGripAttachment
              [Attachment] RightShoulderAttachment
              [ParticleEmitter] Aura1
              [ParticleEmitter] Aura2
              [ParticleEmitter] Smoke1
            ... (4 more Part objects)
          [Part] Labelpart
            [SurfaceGui] SurfaceGui
              [TextLabel] TextLabel
        [Folder] Cuts & Slashes
          [Part] A - Cuts [A]
            [ParticleEmitter] Cuts
          [Part] A - Cuts [B]
            [ParticleEmitter] Cuts
          [Part] A - Cuts [C]
            [ParticleEmitter] Cuts
          [Part] B - Arcs v1 [A]
            [Attachment] Middle
              [ParticleEmitter] Arcs
          [Part] B - Arcs v1 [B]
            [Attachment] Middle  -  Edit
  12:31:15.349                [ParticleEmitter] Arcs
          ... (4 more Part objects)
        [Folder] Electricity
          [Part] A - Sparks [A]
            [ParticleEmitter] Sparks
          [Part] B - Zaps [A]
            [ParticleEmitter] Zaps
          [Part] C - Jolts [A]
            [ParticleEmitter] Sparks
          [Part] D - Sparks [B]
            [ParticleEmitter] Sparks
          [Part] E - Zaps [B]
            [ParticleEmitter] Zaps
          ... (5 more Part objects)
        [Folder] Flames
          [Part] A - Candle
            [Attachment] Middle
              [ParticleEmitter] Candlelight
          [Part] B - Fire
            [ParticleEmitter] Flames
          [Part] C - Medium Fire
            [ParticleEmitter] Flames
          [Part] D - Large Fire
            [ParticleEmitter] Flames
          [Part] E - XL Fire
            [ParticleEmitter] Flames
          ... (4 more Part objects)
        ... (6 more Folder objects)
      [Folder] fire particle (effects
        [Part] fire particle
          [Attachment] Attachment
            [ParticleEmitter] Flame
          [ParticleEmitter] Embers
          [ParticleEmitter] Older
          [ParticleEmitter] ParticleEmitter
          [ParticleEmitter] ParticleEmitter
        [Part] Fireball (*)
          [Attachment] Fireball
            [ParticleEmitter] Inner
            [ParticleEmitter] Sparks
            [ParticleEmitter] Wave
        [Part] Part
      [Folder] hat effects
        [Part] rave
          [Attachment] Attachment
            [ParticleEmitter] ParticleEmitter
            [ParticleEmitter] ParticleEmitter
      [Folder] Particle effects
        [Folder] Blood
          [Part] B - HEMORRHAGE
            [Attachment] MIDDLE
              [ParticleEmitter] BLOOD01
              [ParticleEmitter] BLOOD02
          [Part] C - BLOOD SPLATTER
            [Attachment] MIDDLE
              [ParticleEmitter] BLOOD01
              [ParticleEmitter] BLOOD02
          [Part] D - POOLING BLOOD [A]
            [Attachment] MIDDLE
              [ParticleEmitter] BLOOD01
              [ParticleEmitter] BLOOD02
          [Part] E - POOLING BLOOD [B]
            [Attachment] MIDDLE
              [ParticleEmitter] BLOOD01
          [Part] Part
        [Folder] Fire
          [Part] A - CANDLELIGHT
            [Attachment] MIDDLE
              [ParticleEmitter] CANDLELIGHT
              [ParticleEmitter] GLOW
          [Part] B - FLAMES
            [ParticleEmitter] FIRE
            [ParticleEmitter] GLOW
            [ParticleEmitter] SPECKS
          [Part] Burn
            [ParticleEmitter] Fire
            [ParticleEmitter] Sparks
          [Part] C - STRONG FIRE
            [ParticleEmitter] FIRE
            [ParticleEmitter] GLOW
            [ParticleEmitter] SPECKS
          [Part] D - ROARING FLAMES
            [ParticleEmitter] FIRE
            [ParticleEmitter] GLOW
            [ParticleEmitter] SPECKS
          ... (6 more Part objects)
        [Folder] Hits
          [Part] A - NORMAL STRIKE [A]
            [Attachment] MIDDLE
              [ParticleEmitter] CIRCLE
              [ParticleEmitter] HIT
          [Part] B - NORMAL STRIKE [B]
            [Attachment] MIDDLE
              [ParticleEmitter] STRIKES
          [Part] BlockEff
            [ParticleEmitter] Hit
            [ParticleEmitter] ParticleEmitter
            [ParticleEmitter] ParticleEmitter
          [Part] C - NORMAL STRIKE [C]
            [Attachment] MIDDLE
              [ParticleEmitter] STRIKES
          [Part] D - QUICKSTEP
            [ParticleEmitter] FWOOSH
          ... (2 more Part objects)
        [Folder] Lightning
          [Part] 05 - LIGHTNING STRIKE [A]
            [Attachment] LIGHTNING
              [ParticleEmitter] ELECTRIC
            [ParticleEmitter] RESIDUE
          [Part] 06 - LIGHTNING STRIKE [B]
            [Attachment] LIGHTNING
              [ParticleEmitter] ELECTRIC
            [ParticleEmitter] RESIDUE
          [Part] A - ELECTRICITY 01
            [ParticleEmitter] ELECTRIC
          [Part] B - ELECTRICITY 02
            [ParticleEmitter] ELECTRIC
          [Part] D - ELECTRICITY 04
            [ParticleEmitter] ELECTRIC
          ... (5 more Part objects)
        [Folder] Other
          [Part] 1
          [Part] A - POISON
            [ParticleEmitter] POISON
          [Part] B - TREASURE
            [Attachment] Middle
              [ParticleEmitter] Core
              [ParticleEmitter] Singular Rays
              [ParticleEmitter] Surrounding Aura
          [Part] C - SHINY
            [ParticleEmitter] Glow
            [ParticleEmitter] Shine
          [Part] D - DEADLY GAS
            [ParticleEmitter] GAS
            [ParticleEmitter] SPECKS
          ... (16 more Part objects)
        ... (4 more Folder objects)
      ... (1 more Folder objects)
  [ServiceVisibilityService] ServiceVisibilityService
  [SharedTableRegistry] SharedTableRegistry
  [SocialService] SocialService
  [SolidModelContentProvider] SolidModelContentProvider
  [SoundService] SoundService
    [Sound] MainTheme
  [SpawnerService] SpawnerService
  [StarterGui] StarterGui
    [ScreenGui] BoostsGui
      [Frame] Background
        [ImageButton] BoostTemplate1
          [UIAspectRatioConstraint] UIAspectRatioConstraint
        [ImageButton] BoostTemplate2
          [UIAspectRatioConstraint] UIAspectRatioConstraint
        [ImageButton] BoostTemplate3
          [UIAspectRatioConstraint] UIAspectRatioConstraint
        [ImageButton] BoostTemplate4
          [UIAspectRatioConstraint] UIAspectRatioConstraint
        [UIAspectRatioConstraint] UIAspectRatioConstraint
        [UIListLayout] UIListLayout
      [Frame] HoverFrame
        [TextLabel] Description
          [UIAspectRatioConstraint] UIAspectRatioConstraint
          [UIStroke] UIStroke
        [TextLabel] TimeLeft
          [UIAspectRatioConstraint] UIAspectRatioConstraint
          [UIStroke] UIStroke
        [UIAspectRatioConstraint] UIAspectRatioConstraint
        [UICorner] UICorner
        [UIGradient] UIGradient
        [UIStroke] UIStroke
      [LocalScript] BoostsScript
      [UIAspectRatioConstraint] UIAspectRatioConstraint
    [ScreenGui] CurrencyGui
      [Frame] Background
        [ImageLabel] Image
          [UIAspectRatioConstraint] UIAspectRatioConstraint
        [TextLabel] PooBucks
          [LocalScript] CurrencyUpdaterScript
          [UIAspectRatioConstraint] UIAspectRatioConstraint
          [UIStroke] UIStroke
        [UIAspectRatioConstraint] UIAspectRatioConstraint
        [UICorner] UICorner
        [UIGradient] UIGradient
        [UIStroke] UIStroke
      [Frame] TimesPoopedBG
        [ImageLabel] Image
          [UIAspectRatioConstraint] UIAspectRatioConstraint
        [TextLabel] TimesPooped
          [LocalScript] CurrencyUpdaterScript
          [UIAspectRatioConstraint] UIAspectRatioConstraint
          [UIStroke] UIStroke
        [UIAspectRatioConstraint] UIAspectRatioConstraint
        [UICorner] UICorner
        [UIGradient] UIGradient
        [UIStroke] UIStroke
      [UIAspectRatioConstraint] UIAspectRatioConstraint
    [ScreenGui] GroupRewardsGui
      [Frame] StatsBackground
        [ImageButton] ExitButton
          [TextLabel] ExitLabel
            [UIStroke] UIStroke  -  Edit
  12:31:15.351          [ImageLabel] CosmeticIcon
          [UIAspectRatioConstraint] UIAspectRatioConstraint
          [UICorner] UICorner
        [ImageLabel] Image
          [UIAspectRatioConstraint] UIAspectRatioConstraint
        [ImageLabel] Image
          [UIAspectRatioConstraint] UIAspectRatioConstraint
        [TextButton] VerifyButton
          [UIAspectRatioConstraint] UIAspectRatioConstraint
          [UICorner] UICorner
          [UIStroke] UIStroke
          [UIStroke] UIStroke
        [TextLabel] +2,000 PooBucks
          [UIGradient] UIGradient
          [UIStroke] UIStroke
        [TextLabel] +2,000 PooBucks
          [UIGradient] UIGradient
          [UIStroke] UIStroke
        [TextLabel] DescriptionOfGroupRewards
          [UIGradient] UIGradient
          [UIStroke] UIStroke
        [TextLabel] StatsTitleLabel
          [UIGradient] UIGradient
          [UIStroke] UIStroke
        [UICorner] UICorner
        [UIGradient] UIGradient
        [UIStroke] UIStroke
    [ScreenGui] InviteGui
      [Frame] Icon
        [TextButton] IconButton
          [ImageLabel] IconImage
            [UIAspectRatioConstraint] UIAspectRatioConstraint
          [LocalScript] GuiEffect
          [LocalScript] InviteScript
          [TextLabel] IconLabel
            [UIAspectRatioConstraint] UIAspectRatioConstraint
          [UIAspectRatioConstraint] UIAspectRatioConstraint
          [UICorner] IconCorner
        [UIAspectRatioConstraint] UIAspectRatioConstraint
    [ScreenGui] LoadingScreen
      [Frame] Background
        [CanvasGroup] BarFramePercentage
          [UIAspectRatioConstraint] UIAspectRatioConstraint
          [UICorner] UICorner
          [UIStroke] UIStroke
        [ImageLabel] CosmeticLogo
          [UIAspectRatioConstraint] UIAspectRatioConstraint
          [UICorner] UICorner
          [UIStroke] UIStroke
        [TextLabel] CosmeticTitleLabel
          [UIAspectRatioConstraint] UIAspectRatioConstraint
          [UIGradient] UIGradient
          [UIStroke] UIStroke
        [TextLabel] PercentageLabel
          [UIAspectRatioConstraint] UIAspectRatioConstraint
          [UIStroke] UIStroke
        [TextLabel] TipsLabel
          [UIAspectRatioConstraint] UIAspectRatioConstraint
          [UIStroke] UIStroke
        [UIGradient] UIGradient
      [LocalScript] LoadingScript
    ... (12 more ScreenGui objects)
  [StarterPack] StarterPack
  [StarterPlayer] StarterPlayer
    [StarterCharacterScripts] StarterCharacterScripts
    [StarterPlayerScripts] StarterPlayerScripts
      [LocalScript] LuckBonusClient
      [LocalScript] MainGuiHandler
      [LocalScript] PoopScript
      [LocalScript] PortalClient
      [LocalScript] TutorialClient
  [Stats] Stats
    [StatsItem] ChangeHistory
      [StatsItem] Constrained Data Size
      [StatsItem] Data Size
      [StatsItem] Stack Size
    [StatsItem] FrameRateManager
      [StatsItem] AutoQuality
      [StatsItem] AverageFPS
      [StatsItem] AverageGPU
      [StatsItem] AveragePresent
      [StatsItem] AverageQualityLevel
      ... (32 more StatsItem objects)
    [StatsItem] Lua
      [StatsItem] AverageGcInterval
      [StatsItem] AverageGcTime
      [StatsItem] disabled
      [StatsItem] threads
    [StatsItem] Network
      [StatsItem] Packets Thread
        [StatsItem] Activity
        [StatsItem] Physics Senders
        [StatsItem] Rate
        [StatsItem] Send Buffer Health
      [StatsItem] ServerStatsItem
        [RunningAverageItemInt] Data Ping
        [StatsItem] BandwidthExceeded
        [StatsItem] CongestionControlExceeded
        [StatsItem] DataPingDetails
          [StatsItem] EstTotal
          [StatsItem] LAppPopToSerialize
          [StatsItem] LBcsQ
          [StatsItem] LDeserializeToProcess
          [StatsItem] LQToS
          ... (21 more StatsItem objects)
        [StatsItem] ElapsedTime
        [StatsItem] InPhysicsDetails
          [TotalCountTimeIntervalItem] CFrameOnly
            [RunningAverageItemInt] Size
          [TotalCountTimeIntervalItem] Mechanism
            [RunningAverageItemInt] Size
          [TotalCountTimeIntervalItem] Rotation
            [RunningAverageItemInt] Size
          [TotalCountTimeIntervalItem] Translation
            [RunningAverageItemInt] Size
          [TotalCountTimeIntervalItem] Velocity
            [RunningAverageItemInt] Size
        ... (28 more StatsItem objects)
    [StatsItem] PerformanceStats
      [StatsItem] CPU
      [StatsItem] GPU
      [StatsItem] MaxCPU
      [StatsItem] MaxGPU
      [StatsItem] MaxMemory
      ... (7 more StatsItem objects)
    ... (3 more StatsItem objects)
  [StreamingService] StreamingService
  [StudioService] StudioService
  [StylingService] StylingService
    [Folder] PlaceAnnotations
      [StyleSheet] Design
        [StyleDerive] Derive from Design
        [StyleDerive] Derive from PlaceAnnotationsDarkTheme
        [StyleRule] .AddAnnotationIcon
        [StyleRule] .CheckboxOffIcon
        [StyleRule] .CheckboxOnIcon
        [StyleRule] .CloseIcon
        [StyleRule] .Component-AnnotationContents
          [StyleRule] ::UIPadding
          [StyleRule] > #TextColumn
            [StyleRule] ::UIFlexItem
            [StyleRule] ::UIListLayout
            [StyleRule] >> #UsernameRow
              [StyleRule] > #MoreIcon
                [StyleRule] :hover
                [StyleRule] :pressed
              [StyleRule] > Frame
                [StyleRule] > #TaggedYou
                  [StyleRule] ::UICorner
                  [StyleRule] ::UIPadding
                [StyleRule] > TextLabel
            [StyleRule] >> TextBox
            [StyleRule] >> TextLabel #Contents
          [StyleRule] >> Frame
        ... (23 more StyleRule objects)
      [StyleSheet] PlaceAnnotationsDarkTheme
        [StyleDerive] Derive from Design
      [StyleSheet] PlaceAnnotationsLightTheme
        [StyleDerive] Derive from Design
    [Folder] StudioDesign-1
      [Folder] Stories
      [Folder] Themes
        [StyleSheet] Dark
          [StyleDerive] Derive from Palette
        [StyleSheet] Light
          [StyleDerive] Derive from Palette
      [StyleSheet] Design
        [StyleDerive] Derive from Dark
        [StyleRule] .Component-Checkbox
          [StyleRule] .Checked >> ImageLabel
          [StyleRule] .Disabled >> ImageLabel
          [StyleRule] .Indeterminate >> ImageLabel
          [StyleRule] >> ImageLabel
        [StyleRule] .Component-DragBar
          [StyleRule] .Transparent
          [StyleRule] :hover
          [StyleRule] :press
        [StyleRule] .Component-ExpandablePane
          [StyleRule] .compact
            [StyleRule] .Expanded > .Header > .Arrow
            [StyleRule] > .Header > .Arrow
          [StyleRule] .Expanded > .Header > .Arrow
          [StyleRule] > .Header > .Arrow
        [StyleRule] .Component-IconButton
        [StyleRule] .Component-Image
          [StyleRule] .ArrowIcon
          [StyleRule] .ErrorIcon
          [StyleRule] .Icon16
          [StyleRule] .Primary
        ... (51 more StyleRule objects)
      [StyleSheet] Palette
    [StyleSheet] Explorer
      [StyleRule] .Explorer-BG-Action-Soft-Emphasis
      [StyleRule] .Explorer-BG-Hover
      [StyleRule] .Explorer-BG-Input
      [StyleRule] .Explorer-BG-PrimaryBrandFill
      [StyleRule] .Explorer-BG-Shift300
      ... (28 more StyleRule objects)
    [StyleSheet] ExplorerDark
    [StyleSheet] ExplorerLight  -  Edit
  12:31:15.352    [Teams] Teams
  [TeleportService] Teleport Service
  [TestService] TestService
  [TextBoxService] TextBoxService
  [TextChatService] TextChatService
    [BubbleChatConfiguration] BubbleChatConfiguration
      [ImageLabel] ImageLabel
      [UICorner] UICorner
      [UIGradient] UIGradient
      [UIPadding] UIPadding
    [ChannelTabsConfiguration] ChannelTabsConfiguration
    [ChatInputBarConfiguration] ChatInputBarConfiguration
    [ChatWindowConfiguration] ChatWindowConfiguration
  [TextService] TextService
  [TimerService] TimerService
  [TouchInputService] TouchInputService
  [TweenService] TweenService
  [UGCValidationService] UGCValidationService
  [UIDragDetectorService] UIDragDetectorService
  [UserInputService] UserInputService
  [VRService] VRService
  [VersionControlService] VersionControlService
  [VideoCaptureService] VideoCaptureService
  [VideoService] VideoService
  [Visit] Visit
  [VisualizationModeService] VisualizationModeService
    [VisualizationModeCategory] GUI
      [VisualizationMode] DeviceEmulation
      [VisualizationMode] GUIOverlay
    [VisualizationModeCategory] Lighting
      [VisualizationMode] Lights
    [VisualizationModeCategory] Pathfinding
      [VisualizationMode] PathfindingLinks
      [VisualizationMode] PathfindingMesh
      [VisualizationMode] PathfindingModifiers
    [VisualizationModeCategory] PhysicsConstraints
      [VisualizationMode] Constraints
      [VisualizationMode] Welds
    [VisualizationModeCategory] PhysicsLabels
      [VisualizationMode] AnchoredParts
      [VisualizationMode] Assemblies
      [VisualizationMode] AwakeParts
      [VisualizationMode] Mechanisms
      [VisualizationMode] NetworkOwner
    ... (2 more VisualizationModeCategory objects)
  [VoiceChatService] VoiceChatService
  [Workspace] Workspace
    [Camera] Camera
    [Folder] Islands
      [Folder] FloatingPoopIslandMap
        [Folder] Plungers
          [Model] Plunger
            [Part] Part
              [CylinderMesh] Mesh
            [UnionOperation] Union
            [UnionOperation] Union
          [Model] Plunger
            [Part] Part
              [CylinderMesh] Mesh
            [UnionOperation] Union
            [UnionOperation] Union
          [Model] Plunger
            [Part] Part
              [CylinderMesh] Mesh
            [UnionOperation] Union
            [UnionOperation] Union
          [Model] Plunger
            [Part] Part
              [CylinderMesh] Mesh
            [UnionOperation] Union
            [UnionOperation] Union
          [Model] Plunger
            [Part] Part
              [CylinderMesh] Mesh
            [UnionOperation] Union
            [UnionOperation] Union
          ... (8 more Model objects)
        [Folder] Poops
          [MeshPart] Poop
          [MeshPart] Poop
          [MeshPart] Poop
          [MeshPart] Poop
          [MeshPart] Poop
          ... (5 more MeshPart objects)
        [Folder] TheIsland
          [MeshPart] Hills
          [MeshPart] Meshes/Free Map_Cube
          [MeshPart] Meshes/Free Map_Cube.001
            [Texture] Texture
        [Folder] Trees
          [Model] Tree1
            [MeshPart] Leaves1
            [MeshPart] Leaves2
            [MeshPart] Trunk
          [Model] Tree1
            [MeshPart] Leaves1
            [MeshPart] Leaves2
            [MeshPart] Trunk
          [Model] Tree1
            [MeshPart] Leaves1
            [MeshPart] Leaves2
            [MeshPart] Trunk
          [Model] Tree1
            [MeshPart] Leaves1
            [MeshPart] Leaves2
            [MeshPart] Trunk
          [Model] Tree1
            [MeshPart] Leaves1
            [MeshPart] Leaves2
            [MeshPart] Trunk
          ... (5 more Model objects)
      [Folder] FloatingToiletIslandMap
        [Folder] Plungers
          [Model] Plunger
            [Part] Part
              [CylinderMesh] Mesh
            [UnionOperation] Union
            [UnionOperation] Union
          [Model] Plunger
            [Part] Part
              [CylinderMesh] Mesh
            [UnionOperation] Union
            [UnionOperation] Union
          [Model] Plunger
            [Part] Part
              [CylinderMesh] Mesh
            [UnionOperation] Union
            [UnionOperation] Union
          [Model] Plunger
            [Part] Part
              [CylinderMesh] Mesh
            [UnionOperation] Union
            [UnionOperation] Union
        [Folder] Poop
          [MeshPart] Poop
          [MeshPart] Poop
          [MeshPart] Poop
          [MeshPart] Poop
          [MeshPart] Poop
          ... (5 more MeshPart objects)
        [Folder] TheIsland
          [MeshPart] Hills
          [MeshPart] Meshes/Free Map_Cube
          [MeshPart] Meshes/Free Map_Cube.001
            [Texture] Texture
        [Folder] ToiletPaper
          [Model] ToiletPaper
            [UnionOperation] Toilet Paper
          [Model] ToiletPaper
            [UnionOperation] Toilet Paper
          [Model] ToiletPaper
            [UnionOperation] Toilet Paper
          [Model] ToiletPaper
            [UnionOperation] Toilet Paper
          [Model] ToiletPaper
            [UnionOperation] Toilet Paper
        [Folder] Toilets
          [Model] Bathroom Toilet
            [Part] Part
            [Part] Water. I promise.
              [SpecialMesh] Mesh
            [UnionOperation] BaseBack
            [UnionOperation] BowlBase
            [UnionOperation] FlushSpread
            [UnionOperation] Handle
            [UnionOperation] Hinges
            ... (9 more UnionOperation objects)
          [Model] Bathroom Toilet
            [Part] Part
            [Part] Water. I promise.
              [SpecialMesh] Mesh
            [UnionOperation] BaseBack
            [UnionOperation] BowlBase
            [UnionOperation] FlushSpread
            [UnionOperation] Handle
            [UnionOperation] Hinges
            ... (9 more UnionOperation objects)
          [Model] Bathroom Toilet
            [Part] Part
            [Part] Water. I promise.
              [SpecialMesh] Mesh
            [UnionOperation] BaseBack
            [UnionOperation] BowlBase
            [UnionOperation] FlushSpread
            [UnionOperation] Handle
            [UnionOperation] Hinges
            ... (9 more UnionOperation objects)
          [Model] Bathroom Toilet
            [Part] Part
            [Part] Water. I promise.
              [SpecialMesh] Mesh
            [UnionOperation] BaseBack
            [UnionOperation] BowlBase
            [UnionOperation] FlushSpread
            [UnionOperation] Handle
            [UnionOperation] Hinges
            ... (9 more UnionOperation objects)
          [Model] Bathroom Toilet
            [Part] Part
            [Part] Water. I promise.  -  Edit
  12:31:15.354                [SpecialMesh] Mesh
            [UnionOperation] BaseBack
            [UnionOperation] BowlBase
            [UnionOperation] FlushSpread
            [UnionOperation] Handle
            [UnionOperation] Hinges
            ... (9 more UnionOperation objects)
          ... (1 more Model objects)
        ... (1 more Folder objects)
      [Folder] TheGreatMountainSkyIslandMap
        [Folder] TheIsland
          [MeshPart] Hills
          [MeshPart] Meshes/Free Map_Cube
          [MeshPart] Meshes/Free Map_Cube.001
            [Texture] Texture
        [Model] Decor
          [MeshPart] Poop
          [MeshPart] Poop
          [MeshPart] Poop
          [MeshPart] Poop
          [MeshPart] Poop
          ... (134 more MeshPart objects)
          [Model] Tree1
            [MeshPart] Leaves1
            [MeshPart] Leaves2
            [MeshPart] Trunk
          [Model] Tree1
            [MeshPart] Leaves1
            [MeshPart] Leaves2
            [MeshPart] Trunk
          [Model] Tree1
            [MeshPart] Leaves1
            [MeshPart] Leaves2
            [MeshPart] Trunk
          [Model] Tree1
            [MeshPart] Leaves1
            [MeshPart] Leaves2
            [MeshPart] Trunk
          [Model] Tree1
            [MeshPart] Leaves1
            [MeshPart] Leaves2
            [MeshPart] Trunk
          ... (134 more Model objects)
        [Model] Model
          [MeshPart] Poop
    [Folder] Leaderboards
      [Model] PooBucksLeaderboard
        [Model] ActualModel
          [Part] Part
          [Part] Part
          [Part] Part
          [Part] Part
          [Part] Part
          ... (32 more Part objects)
        [Part] LeaderboardPart
          [SurfaceGui] Leaderboard
            [Folder] Names
              [TextLabel] Name1
                [UIStroke] UIStroke
              [TextLabel] Name10
                [UIStroke] UIStroke
              [TextLabel] Name2
                [UIStroke] UIStroke
              [TextLabel] Name3
                [UIStroke] UIStroke
              [TextLabel] Name4
                [UIStroke] UIStroke
              ... (5 more TextLabel objects)
            [Folder] Photos
              [ImageLabel] Photo1
                [UICorner] UICorner
                [UIStroke] UIStroke
              [ImageLabel] Photo10
                [UICorner] UICorner
                [UIStroke] UIStroke
              [ImageLabel] Photo2
                [UICorner] UICorner
                [UIStroke] UIStroke
              [ImageLabel] Photo3
                [UICorner] UICorner
                [UIStroke] UIStroke
              [ImageLabel] Photo4
                [UICorner] UICorner
                [UIStroke] UIStroke
              ... (5 more ImageLabel objects)
            [Folder] Score
              [TextLabel] Score1
                [UIStroke] UIStroke
              [TextLabel] Score10
                [UIStroke] UIStroke
              [TextLabel] Score2
                [UIStroke] UIStroke
              [TextLabel] Score3
                [UIStroke] UIStroke
              [TextLabel] Score4
                [UIStroke] UIStroke
              ... (5 more TextLabel objects)
        [Part] Title
          [SurfaceGui] TitleGui
            [TextLabel] Title
              [UIAspectRatioConstraint] UIAspectRatioConstraint
              [UIStroke] UIStroke
      [Model] PoopsLeaderboard
        [Model] ActualModel
          [Part] Part
          [Part] Part
          [Part] Part
          [Part] Part
          [Part] Part
          ... (32 more Part objects)
        [Part] LeaderboardPart
          [SurfaceGui] Leaderboard
            [Folder] Names
              [TextLabel] Name1
                [UIStroke] UIStroke
              [TextLabel] Name10
                [UIStroke] UIStroke
              [TextLabel] Name2
                [UIStroke] UIStroke
              [TextLabel] Name3
                [UIStroke] UIStroke
              [TextLabel] Name4
                [UIStroke] UIStroke
              ... (5 more TextLabel objects)
            [Folder] Photos
              [ImageLabel] Photo1
                [UICorner] UICorner
                [UIStroke] UIStroke
              [ImageLabel] Photo10
                [UICorner] UICorner
                [UIStroke] UIStroke
              [ImageLabel] Photo2
                [UICorner] UICorner
                [UIStroke] UIStroke
              [ImageLabel] Photo3
                [UICorner] UICorner
                [UIStroke] UIStroke
              [ImageLabel] Photo4
                [UICorner] UICorner
                [UIStroke] UIStroke
              ... (5 more ImageLabel objects)
            [Folder] Score
              [TextLabel] Score1
                [UIStroke] UIStroke
              [TextLabel] Score10
                [UIStroke] UIStroke
              [TextLabel] Score2
                [UIStroke] UIStroke
              [TextLabel] Score3
                [UIStroke] UIStroke
              [TextLabel] Score4
                [UIStroke] UIStroke
              ... (5 more TextLabel objects)
        [Part] Title
          [SurfaceGui] TitleGui
            [TextLabel] Text
              [UIAspectRatioConstraint] UIAspectRatioConstraint
              [UIStroke] UIStroke
      [Model] RebirthsLeaderboard
        [Model] ActualModel
          [Part] Part
          [Part] Part
          [Part] Part
          [Part] Part
          [Part] Part
          ... (32 more Part objects)
        [Part] LeaderboardPart
          [SurfaceGui] Leaderboard
            [Folder] Names
              [TextLabel] Name1
                [UIStroke] UIStroke
              [TextLabel] Name10
                [UIStroke] UIStroke
              [TextLabel] Name2
                [UIStroke] UIStroke
              [TextLabel] Name3
                [UIStroke] UIStroke
              [TextLabel] Name4
                [UIStroke] UIStroke
              ... (5 more TextLabel objects)
            [Folder] Photos
              [ImageLabel] Photo1
                [UICorner] UICorner
                [UIStroke] UIStroke
              [ImageLabel] Photo10
                [UICorner] UICorner
                [UIStroke] UIStroke
              [ImageLabel] Photo2
                [UICorner] UICorner
                [UIStroke] UIStroke
              [ImageLabel] Photo3
                [UICorner] UICorner
                [UIStroke] UIStroke
              [ImageLabel] Photo4
                [UICorner] UICorner
                [UIStroke] UIStroke
              ... (5 more ImageLabel objects)
            [Folder] Score
              [TextLabel] Score1
                [UIStroke] UIStroke  -  Edit
  12:31:15.356                [TextLabel] Score10
                [UIStroke] UIStroke
              [TextLabel] Score2
                [UIStroke] UIStroke
              [TextLabel] Score3
                [UIStroke] UIStroke
              [TextLabel] Score4
                [UIStroke] UIStroke
              ... (5 more TextLabel objects)
        [Part] Title
          [SurfaceGui] TitleGui
            [TextLabel] Title
              [UIAspectRatioConstraint] UIAspectRatioConstraint
              [UIStroke] UIStroke
    [Folder] LobbyMap
      [Folder] Barriers
        [Model] barrier wall invisible boundaries 225133
          [Part] barrier wall invisible boundary
          [Part] barrier wall invisible boundary
          [Part] barrier wall invisible boundary
          [Part] barrier wall invisible boundary
          [Part] barrier wall invisible boundary
          ... (40 more Part objects)
        [Model] barrier wall invisible boundaries 658112
          [Part] barrier wall invisible boundary
          [Part] barrier wall invisible boundary
          [Part] barrier wall invisible boundary
          [Part] barrier wall invisible boundary
          [Part] barrier wall invisible boundary
          ... (27 more Part objects)
        [Model] barrier wall invisible boundaries 849579
          [Part] barrier wall invisible boundary
          [Part] barrier wall invisible boundary
          [Part] barrier wall invisible boundary
          [Part] barrier wall invisible boundary
          [Part] barrier wall invisible boundary
          ... (15 more Part objects)
        [Model] barrier wall invisible boundaries 931767
          [Part] barrier wall invisible boundary
          [Part] barrier wall invisible boundary
          [Part] barrier wall invisible boundary
          [Part] barrier wall invisible boundary
          [Part] barrier wall invisible boundary
          ... (28 more Part objects)
      [Folder] Baseplate
        [Part] Baseplate
          [Texture] Back
          [Texture] Bottom
          [Texture] Front
          [Texture] Left
          [Texture] Right
          ... (1 more Texture objects)
        [Part] Baseplate
          [Texture] Back
          [Texture] Bottom
          [Texture] Front
          [Texture] Left
          [Texture] Right
          ... (1 more Texture objects)
        [Part] Baseplate
          [Texture] Back
          [Texture] Bottom
          [Texture] Front
          [Texture] Left
          [Texture] Right
          ... (1 more Texture objects)
      [Folder] Fences
        [MeshPart] MeshPart
        [MeshPart] MeshPart
        [MeshPart] MeshPart
        [MeshPart] MeshPart
        [MeshPart] MeshPart
        ... (3 more MeshPart objects)
      [Folder] Flowers
        [Model] Flower
          [Folder] ChangeColor
            [Part] Part
            [Part] Part
            [Part] Part
            [Part] Part
            [Part] Part
            ... (22 more Part objects)
          [Folder] GreenThing
            [Part] Part
            [Part] Part
            [Part] Part
            [UnionOperation] Union
            [UnionOperation] Union
            [UnionOperation] Union
        [Model] Flower
          [Folder] ChangeColor
            [Part] Part
            [Part] Part
            [Part] Part
            [Part] Part
            [Part] Part
            ... (22 more Part objects)
          [Folder] GreenThing
            [Part] Part
            [Part] Part
            [Part] Part
            [UnionOperation] Union
            [UnionOperation] Union
            [UnionOperation] Union
        [Model] Flower
          [Folder] ChangeColor
            [Part] Part
            [Part] Part
            [Part] Part
            [Part] Part
            [Part] Part
            ... (22 more Part objects)
          [Folder] GreenThing
            [Part] Part
            [Part] Part
            [Part] Part
            [UnionOperation] Union
            [UnionOperation] Union
            [UnionOperation] Union
      [Folder] MapStuff
        [MeshPart] MeshPart
        [MeshPart] MeshPart
        [MeshPart] MeshPart
        [MeshPart] MeshPart
        [MeshPart] MeshPart
        [Model] Bench
          [MeshPart] BenchSeat
          [MeshPart] BenchSupport
        [Model] Bench
          [MeshPart] BenchSeat
          [MeshPart] BenchSupport
        [Model] Bench
          [MeshPart] BenchSeat
          [MeshPart] BenchSupport
        [Model] Bench
          [MeshPart] BenchSeat
          [MeshPart] BenchSupport
        [Model] CirclePath
          [UnionOperation] Union
        ... (87 more Model objects)
        [Part] Part
        [Part] Part
        [Part] Part
        [Part] Part
      ... (5 more Folder objects)
      [Model] Cartoony fountain (NOT MINE)
        [Model] Fountain
          [MeshPart] Meshes/IceysAssetPack_Cylinder.022 (2)
          [MeshPart] Meshes/IceysAssetPack_Cylinder.023 (2)
          [MeshPart] Meshes/IceysAssetPack_Cylinder.036 (1)
        [Part] Duck
          [SpecialMesh] Mesh
        [Part] Part
        [Part] Part
        [Part] Water
    [Folder] Portals
      [Model] Zone1Portal
        [Model] Cosmetic
          [MeshPart] Meshes/Portal_Plane
          [Part] Part
          [Part] Part
          [Part] Part
          [Part] Part
        [Model] ZoneDescription
          [Part] Part
            [BillboardGui] ZoneNameBillboardGui
              [TextLabel] ZoneName
                [UIStroke] UIStroke
              [TextLabel] ZoneNeeded
                [UIStroke] UIStroke
        [Part] TPPartToZone1
      [Model] Zone1PortalArrive
        [Model] Cosmetic
          [MeshPart] Meshes/Portal_Plane
          [Part] Part
          [Part] Part
          [Part] Part
          [Part] Part
        [Part] TPPartBackFromZone1
      [Model] Zone2Portal
        [Model] Cosmetic
          [MeshPart] Meshes/Portal_Plane
          [Part] Part
          [Part] Part
          [Part] Part
          [Part] Part
        [Model] ZoneDescription
          [Part] Part
            [BillboardGui] ZoneNameBillboardGui
              [TextLabel] ZoneName
                [UIStroke] UIStroke
              [TextLabel] ZoneNeeded
                [UIStroke] UIStroke
        [Part] TPPartToZone2
      [Model] Zone2PortalArrive
        [Model] Cosmetic
          [MeshPart] Meshes/Portal_Plane
          [Part] Part
          [Part] Part
          [Part] Part  -  Edit
  12:31:15.399            [Part] Part
        [Part] TPPartFromZone2
      [Model] Zone3Portal
        [Model] Cosmetic
          [MeshPart] Meshes/Portal_Plane
          [Part] Part
          [Part] Part
          [Part] Part
          [Part] Part
        [Model] ZoneDescription
          [Part] Part
            [BillboardGui] ZoneNameBillboardGui
              [TextLabel] ZoneName
                [UIStroke] UIStroke
              [TextLabel] ZoneNeeded
                [UIStroke] UIStroke
        [Part] TPPartToZone3
      ... (1 more Model objects)
    [Folder] Shop
      [Folder] Coins
        [Model] Model
          [MeshPart] Hexagon
          [MeshPart] Hexagon
          [MeshPart] Hexagon
          [MeshPart] Hexagon
          [MeshPart] Hexagon
          ... (4 more MeshPart objects)
          [Model] Model
            [MeshPart] Hexagon
            [MeshPart] Hexagon
            [MeshPart] Hexagon
            [MeshPart] Hexagon
            [MeshPart] Hexagon
            ... (3 more MeshPart objects)
          [Model] Model
            [MeshPart] Hexagon
            [MeshPart] Hexagon
            [MeshPart] Hexagon
            [MeshPart] Hexagon
            [MeshPart] Hexagon
            ... (7 more MeshPart objects)
        [Model] Model
          [MeshPart] Hexagon
          [MeshPart] Hexagon
          [MeshPart] Hexagon
          [MeshPart] Hexagon
          [MeshPart] Hexagon
          ... (4 more MeshPart objects)
          [Model] Model
            [MeshPart] Hexagon
            [MeshPart] Hexagon
            [MeshPart] Hexagon
            [MeshPart] Hexagon
            [MeshPart] Hexagon
            ... (3 more MeshPart objects)
          [Model] Model
            [MeshPart] Hexagon
            [MeshPart] Hexagon
            [MeshPart] Hexagon
            [MeshPart] Hexagon
            [MeshPart] Hexagon
            ... (7 more MeshPart objects)
      [Model] Cartoony house (NOT MINE)
        [Model] TextModel2
          [MeshPart] H
          [MeshPart] O
          [MeshPart] P
          [MeshPart] S
        [Part] Back Roof Window Blue Glass
        [Part] Back Window Blue Galss
        [Part] Brown Door
        [Part] Door Knob
        [Part] Door Steps
        ... (16 more Part objects)
        [UnionOperation] Black Roof
        [UnionOperation] Bricks
        [UnionOperation] Red Middle
        [UnionOperation] White Door Frame
        [UnionOperation] White Frame of  Right Window
        ... (16 more UnionOperation objects)
      [Model] GemShop
        [MeshPart] MainPart
          [BillboardGui] BillboardGui
            [TextLabel] TextLabel
              [UIStroke] UIStroke
        [MeshPart] Shop
          [Highlight] Highlight
      [Part] Trigger
        [Script] TriggerShopScript
    ... (6 more Folder objects)
    [Model] toilet
      [MeshPart] input
    [Terrain] Terrain
      [Part] mohamad2041_googly_base_left
        [SpotLight] googly_spotlight
      [Part] mohamad2041_googly_base_right
        [SpotLight] googly_spotlight
      [Part] mohamad2041_googly_pupil_left
      [Part] mohamad2041_googly_pupil_right

=== Lua Scripts + Source (max 2 identical copies) ===
>>> game.ReplicatedStorage.ShopConfig (ModuleScript) — 1160 lines
-- ShopConfig (ModuleScript in ReplicatedStorage) - COMPLETE WITH ALL NEW FEATURES
return {
	-- ═══════════════════════════════════════════════════════════════
	-- DEBUG SETTINGS
	-- ═══════════════════════════════════════════════════════════════
	Debug = {
		Enabled = true,
		ShowClientDebug = true,
		ShowServerDebug = true,
		ShowLeaderstatsDebug = false,
		ShowBoostDebug = false,
		ShowShopDebug = true,
		ShowZoneDebug = false,
		ShowRebirthDebug = false,
		ShowNotificationDebug = false
	},

	-- ═══════════════════════════════════════════════════════════════
	-- SOUND CONFIGURATION
	-- ═══════════════════════════════════════════════════════════════
	Sounds = {
		-- UI Sounds
		ButtonHover = "rbxassetid://10066931761",
		ButtonClick = "rbxassetid://7593297942",
		TabSwitch = "rbxassetid://12222183",

		-- Purchase Sounds
		PurchaseSuccess = "rbxassetid://3454671965",
		PurchaseFail = "rbxassetid://2390695935",
		AlreadyOwned = "rbxassetid://9066167010",

		-- Shop Sounds
		ShopOpen = "rbxassetid://2084290015",
		ShopClose = "rbxassetid://8904888220",

		-- Poop Sounds
		PoopSpawn = "rbxassetid://98112849852832",

		-- Notification Sounds
		GiftReceived = "rbxassetid://1839997929",
		NotificationShow = "rbxassetid://133071738727579",

		-- Rebirth Sounds
		RebirthSuccess = "rbxassetid://3454671965",
		RebirthFail = "rbxassetid://2390695935",

		-- Zone Sounds
		ZoneEnter = "rbxassetid://12222253",
		ZoneExit = "rbxassetid://12222152",
		ZoneRestricted = "rbxassetid://9066167010",

		-- Luck Sounds
		LuckTrigger = "rbxassetid://3454671965",
		MegaLuckTrigger = "rbxassetid://1839997929",

		-- Auto Poop Sound
		AutoPoopTick = "rbxassetid://98112849852832",

		-- Volume Settings
		Volumes = {
			UI = 0.5,
			Purchase = 0.7,
			Shop = 0.7,
			Poop = 0.8,
			Notification = 0.6,
			Rebirth = 0.8,
			Zone = 0.5,
			Luck = 0.6,
			AutoPoop = 0.3
		}
	},

	-- ═══════════════════════════════════════════════════════════════
	-- TWEEN & ANIMATION CONFIGURATION (keeping existing)
	-- ═══════════════════════════════════════════════════════════════
	Tweens = {
		-- Button Effects
		ButtonHover = {
			Duration = 0.15,
			EasingStyle = Enum.EasingStyle.Quad,
			EasingDirection = Enum.EasingDirection.Out,
			ScaleMultiplier = 1.05,
			ColorLerp = 0.1
		},

		ButtonClick = {
			Duration = 0.1,
			EasingStyle = Enum.EasingStyle.Quad,
			EasingDirection = Enum.EasingDirection.Out,
			ScaleMultiplier = 0.95,
			RotationRange = 2
		},

		-- Shop Animations
		ShopOpen = {
			Duration = 0.7,
			EasingStyle = Enum.EasingStyle.Back,
			EasingDirection = Enum.EasingDirection.Out,  -  Edit
  12:31:15.399  			FOV = 40,
			BlurSize = 25
		},

		ShopClose = {
			Duration = 0.7,
			EasingStyle = Enum.EasingStyle.Back,
			EasingDirection = Enum.EasingDirection.In
		},

		-- Notification Animations
		NotificationSlideDown = {
			Duration = 0.5,
			EasingStyle = Enum.EasingStyle.Back,
			EasingDirection = Enum.EasingDirection.Out,
			SlideDistance = 100
		},

		NotificationFadeUp = {
			Duration = 0.3,
			EasingStyle = Enum.EasingStyle.Quad,
			EasingDirection = Enum.EasingDirection.In
		},

		-- Popup Animations
		PopupMove = {
			Duration = 2.0,
			EasingStyle = Enum.EasingStyle.Quad,
			EasingDirection = Enum.EasingDirection.Out,
			MoveDistance = 50
		},

		-- Rebirth Animations
		RebirthOpen = {
			Duration = 0.5,
			EasingStyle = Enum.EasingStyle.Back,
			EasingDirection = Enum.EasingDirection.Out
		},

		RebirthClose = {
			Duration = 0.3,
			EasingStyle = Enum.EasingStyle.Back,
			EasingDirection = Enum.EasingDirection.In
		}
	},

	-- ═══════════════════════════════════════════════════════════════
	-- GAME CONFIGURATION
	-- ═══════════════════════════════════════════════════════════════
	DefaultPoop = "Poop",
	StartingPooBucks = 0,
	StartingPoopsPooped = 0,
	StartingRebirths = 0,

	-- ═══════════════════════════════════════════════════════════════
	-- GROUP REWARDS CONFIGURATION (keeping existing)
	-- ═══════════════════════════════════════════════════════════════
	GroupRewards = {
		GroupId = 16447133,
		Rewards = {
			PooBucks = 2000,
			Boost = {
				Type = "2xPooBucksBoost",
				Duration = 300
			}
		},
		RequiredRank = 0,
		Messages = {
			Success = "🎉 Group rewards claimed! You received 2000 PooBucks and a 5-minute 2x boost!",
			NotInGroup = "❌ You must be in our group to claim rewards!",
			InsufficientRank = "❌ You need a higher rank in the group to claim rewards!",
			AlreadyClaimed = "⏰ You have already claimed your group rewards!",
			Error = "❌ Failed to verify group membership. Please try again."
		}
	},

	-- ═══════════════════════════════════════════════════════════════
	-- REBIRTH SYSTEM CONFIGURATION (keeping existing)
	-- ═══════════════════════════════════════════════════════════════
	Rebirth = {
		BaseCost = 2000,
		CostMultiplier = 3,
		MultiplierPerRebirth = 0.5,
		MaxRebirths = -1,
		ResetData = {
			PooBucks = true,
			OwnedPoops = false,
			EquippedPoop = false,
			OwnedUpgrades = false,
			OwnedGamepasses = false,
			PoopsPooped = false
		},
		Requirements = {
			MinPooBucks = true,
			MinPoopsPooped = false,
			MinZoneUnlocked = false
		}
	},

	-- ═══════════════════════════════════════════════════════════════
	-- ZONES CONFIGURATION (ENHANCED WITH VIP ZONE)
	-- ═══════════════════════════════════════════════════════════════
	Zones = {
		["Zone1"] = {
			Name = "Poop Sky Island",
			RequiredPoopsPooped = 350,
			Multiplier = 2,
			UnlockMessage = "🎉 You've unlocked the Poop Sky Island! 2x earnings!",
			Description = "A floating island made of poop with 2x earnings!"
		},
		["Zone2"] = {
			Name = "Toilet Sky Island", 
			RequiredPoopsPooped = 750,
			Multiplier = 3,
			UnlockMessage = "🎉 You've unlocked the Toilet Sky Island! 3x earnings!",
			Description = "A magical toilet island with 3x earnings!"
		},
		["Zone3"] = {
			Name = "Great Poop Mountain",
			RequiredPoopsPooped = 1500, 
			Multiplier = 5,
			UnlockMessage = "🎉 You've unlocked the Great Poop Mountain! 5x earnings!",
			Description = "The legendary mountain of poop with 5x earnings!"
		},
		["Zone4"] = {
			Name = "VIP Zone",
			RequiredPoopsPooped = 0, -- No poop requirement, gamepass required
			Multiplier = 8,
			UnlockMessage = "🌟 Welcome to the exclusive VIP Zone! 8x earnings!",
			Description = "Exclusive VIP zone with 8x earnings!",
			IsVIP = true,
			RequiredGamepass = "VIPZone",
			UIColor = Color3.fromRGB(255, 215, 0), -- Gold color
			ChatEmoji = "👑"
		}
	},

	-- ═══════════════════════════════════════════════════════════════
	-- VIP ZONE CONFIGURATION
	-- ═══════════════════════════════════════════════════════════════
	VIPZone = {
		ZoneName = "Zone4",
		RequiredGamepass = "VIPZone",
		Multiplier = 8,
		MultiplierColor = Color3.fromRGB(255, 215, 0), -- Gold color for VIP
		ChatPrefix = "👑",
		AccessMessage = "🌟 Welcome to the VIP Zone! 8x earnings active!",
		NoAccessMessage = "❌ VIP Zone Access Required! Purchase the VIP gamepass to enter."
	},

	-- ═══════════════════════════════════════════════════════════════
	-- AUTO POOP SYSTEM CONFIGURATION
	-- ═══════════════════════════════════════════════════════════════
	AutoPoop = {
		-- Intervals in seconds
		Intervals = {
			Regular = 1.0,    -- Every 1 second for regular auto poop
			Stronger = 0.4    -- Every 0.4 seconds for stronger auto poop
		},
		-- Sound settings
		PlaySounds = false, -- Don't play poop sounds for auto poop (would be annoying)
		ShowPopups = true,  -- Show money gain popups for auto poop
		-- Effects
		VisualEffects = false, -- Don't spawn visual poop models for auto poop
	},
	
	
	-- ═══════════════════════════════════════════════════════════════
	-- NOTIFICATION SYSTEM CONFIGURATION
	-- ═══════════════════════════════════════════════════════════════
	Notifications = {
		PurchaseNotification = {
			Enabled = true,
			AutoClose = false,
			Duration = 10,
			CheckInterval = 5
		},

		GiftNotification = {
			Enabled = true,
			AutoClose = true,
			Duration = 8
		},

		ZoneUnlock = {
			Enabled = true,
			Duration = 5
		}
	},
	
	-- ═══════════════════════════════════════════════════════════════
	-- LUCK BONUS SYSTEM CONFIGURATION
	-- ═══════════════════════════════════════════════════════════════
	LuckBonus = {
		-- Chance settings (5% = 0.05)
		BaseLuckChance = 0.05,
		MegaLuckChance = 0.05,

		-- Multiplier values
		LuckMultiplier = 1.5,     -- Regular luck gives 1.5x  -  Edit
  12:31:15.399  		MegaLuckMultiplier = 2.5, -- Mega luck gives 2.5x

		-- Visual effects
		ShowLuckPopups = true,
		LuckPopupDuration = 2,

		-- Sounds
		PlayLuckSounds = true,
	},

	-- ═══════════════════════════════════════════════════════════════
	-- BOOST SYSTEM LIMITS
	-- ═══════════════════════════════════════════════════════════════
	BoostLimits = {
		MaxActiveBoosts = 4, -- Maximum number of boosts that can be active at once
		StackingRules = {
			CurrencyMultiplier = "Additive", -- Multiple currency boosts add together
			ProductionMultiplier = "Multiplicative", -- Production boosts multiply
			ProductionAdditive = "Additive", -- Additive boosts add together
			LuckBonus = "Independent", -- Each luck bonus has independent chance
			AutoPoop = "Replacement" -- Auto poop boosts replace each other
		}
	},

	-- ═══════════════════════════════════════════════════════════════
	-- TAB CONFIGURATION
	-- ═══════════════════════════════════════════════════════════════
	Tabs = {
		PoopsButton = "PoopsScrollingFrame",
		UpgradesButton = "UpgradesScrollingFrame", 
		GamepassesButton = "GamepassesScrollingFrame"
	},

	-- ═══════════════════════════════════════════════════════════════
	-- POOP CONFIGURATION (keeping existing)
	-- ═══════════════════════════════════════════════════════════════
	Poops = {
		["Poop"] = {
			Name = "Basic Poop",
			Price = 0,
			Gain = 1,
			ModelName = "Poop",
			ButtonName = "PoopButton", 
			Image = "",
			Default = true,
			Description = "The classic. Just you and a humble poop start.",
			Tier = 1
		},
		["StinkyPoop"] = {
			Name = "Stinky Poop",
			Price = 100,
			Gain = 2,
			ModelName = "StinkyPoop",
			ButtonName = "StinkyPoopButton", 
			Image = "",
			Description = "Reeks terribly but packs in double the profits!",
			Tier = 2
		},
		["BurntPoop"] = {
			Name = "Burnt Poop",
			Price = 500,
			Gain = 3,
			ModelName = "BurntPoop",
			ButtonName = "BurntPoopButton", 
			Image = "",
			Description = "Charred, crispy, and unexpectedly valuable.",
			Tier = 3
		},
		["WaterPoop"] = {
			Name = "Water Poop",
			Price = 3500,
			Gain = 4,
			ModelName = "WaterPoop",
			ButtonName = "WaterPoopButton", 
			Image = "",
			Description = "Sloshy and smooth, flows in extra cash.",
			Tier = 4
		},
		["ShockedPoop"] = {
			Name = "Shocked Poop",
			Price = 6500,
			Gain = 6,
			ModelName = "ShockedPoop",
			ButtonName = "ShockedPoopButton", 
			Image = "",
			Description = "Zapped with energy, shocks out bonus PooBux!",
			Tier = 5
		},
		["HypnosisPoop"] = {
			Name = "Hypnosis Poop",
			Price = 15000,
			Gain = 8,
			ModelName = "HypnosisPoop",
			ButtonName = "HypnosisPoopButton", 
			Image = "",
			Description = "Spinny swirls that lure in more money!",
			Tier = 6
		},
		["HolyPoop"] = {
			Name = "Holy Poop",
			Price = 35000,
			Gain = 10,
			ModelName = "HolyPoop",
			ButtonName = "HolyPoopButton", 
			Image = "",
			Description = "Blessed by poop angels, truly divine.",
			Tier = 7
		},
		["BloodyPoop"] = {
			Name = "Bloody Poop",
			Price = 55000,
			Gain = 12,
			ModelName = "BloodyPoop",
			ButtonName = "BloodyPoopButton", 
			Image = "",
			Description = "Dark, spooky, and oozing with riches.",
			Tier = 8
		},
		["DiamondPoop"] = {
			Name = "Diamond Poop",
			Price = 75000,
			Gain = 15,
			ModelName = "DiamondPoop",
			ButtonName = "DiamondPoopButton", 
			Image = "",
			Description = "Glitters like gold, drops like a gem.",
			Tier = 9
		},
		["VoidPoop"] = {
			Name = "Void Poop",
			Price = 100000,
			Gain = 20,
			ModelName = "VoidPoop",
			ButtonName = "VoidPoopButton", 
			Image = "",
			Description = "Emptier than space, but way more valuable.",
			Tier = 10
		},
		["GalePoop"] = {
			Name = "Gale Poop",
			Price = 250000,
			Gain = 25,
			ModelName = "GalePoop",
			ButtonName = "GalePoopButton", 
			Image = "",
			Description = "Blasts wind as it drops — lightning fast gains.",
			Tier = 11
		},
		["BlackHolePoop"] = {
			Name = "Blackhole Poop",
			Price = 550000,
			Gain = 30,
			ModelName = "BlackHolePoop",
			ButtonName = "BlackHolePoopButton", 
			Image = "",
			Description = "So dense, it sucks in value from the universe!",
			Tier = 12
		},
		["MistPoop"] = {
			Name = "Mist Poop",
			Price = 950000,
			Gain = 35,
			ModelName = "MistPoop",
			ButtonName = "MistPoopButton", 
			Image = "",
			Description = "Barely there, but still makes you rich.",
			Tier = 13
		},
		["SuperPoop"] = {
			Name = "Super Poop",
			Price = 1550000,
			Gain = 40,
			ModelName = "SuperPoop",
			ButtonName = "SuperPoopButton", 
			Image = "",
			Description = "Cape-wearing hero poop with power-packed gains.",
			Tier = 14
		},
		["SmokyPoop"] = {
			Name = "Smoky Poop",
			Price = 2250000,
			Gain = 45,
			ModelName = "SmokyPoop",
			ButtonName = "SmokyPoopButton", 
			Image = "",
			Description = "Billows smoke and drops coins like ash.",
			Tier = 15
		},
		["WindPoop"] = {
			Name = "Wind Poop",
			Price = 4350000,
			Gain = 50,
			ModelName = "WindPoop",
			ButtonName = "WindPoopButton", 
			Image = "",
			Description = "Sharp gusts swirl with every plop!",
			Tier = 16
		},
		["WhirlpoolPoop"] = {
			Name = "Whirlpool Poop",  -  Edit
  12:31:15.399  			Price = 7550000,
			Gain = 55,
			ModelName = "WhirlpoolPoop",
			ButtonName = "WhirlpoolPoopButton", 
			Image = "",
			Description = "Spins into cash with every messy swirl.",
			Tier = 17
		},
		["StaticPoop"] = {
			Name = "Static Poop",
			Price = 12500000,
			Gain = 60,
			ModelName = "StaticPoop",
			ButtonName = "StaticPoopButton", 
			Image = "",
			Description = "Buzzes with electric fuzz — shockingly rich!",
			Tier = 18
		},
		["StarPoop"] = {
			Name = "Star Poop",
			Price = 35000000,
			Gain = 80,
			ModelName = "StarPoop",
			ButtonName = "StarPoopButton", 
			Image = "",
			Description = "Shines bright and bursts with stardust profits!",
			Tier = 19
		},
		["GalaxyPoop"] = {
			Name = "Galaxy Poop",
			Price = 65000000,
			Gain = 120,
			ModelName = "GalaxyPoop",
			ButtonName = "GalaxyPoopButton", 
			Image = "",
			Description = "Very cool galaxy poop!!",
			Tier = 20
		},
		["HollowPurplePoop"] = {
			Name = "Hollow Purple Poop",
			Price = 100000000,
			Gain = 180,
			ModelName = "HollowPurplePoop",
			ButtonName = "HollowPurplePoopButton", 
			Image = "",
			Description = "Mystical, powerful, and dangerously pretty.",
			Tier = 21
		},
		["ExplosionPoop"] = {
			Name = "Explosion Poop",
			Price = 150000000,
			Gain = 180,
			ModelName = "ExplosionPoop",
			ButtonName = "ExplosionPoopButton", 
			Image = "",
			Description = "Exploding poop, extremely hot.",
			Tier = 22
		},
		["FlamingPoop"] = {
			Name = "Flaming Poop",
			Price = 225000000,
			Gain = 180,
			ModelName = "FlamingPoop",
			ButtonName = "FlamingPoopButton", 
			Image = "",
			Description = "Flaming hot poop, very dangerous.",
			Tier = 23
		},
		["EndlessPoop"] = {
			Name = "Endless Poop",
			Price = 550000000,
			Gain = 180,
			ModelName = "EndlessPoop",
			ButtonName = "EndlessPoopButton", 
			Image = "",
			Description = "Goes infinitely beyond everything.",
			Tier = 24
		},
	},

	-- ═══════════════════════════════════════════════════════════════
	-- UPGRADE CONFIGURATION (keeping existing)
	-- ═══════════════════════════════════════════════════════════════
	Upgrades = {
		["2PoopsUpgrade"] = {
			Name = "+1 Poop Production",
			Price = 2500,
			Description = "Spawn 2 poops instead of 1!",
			Image = "rbxassetid://98642207209330", 
			Effect = "ProductionMultiplier",
			Value = 2,
			Tier = 1,
			RequiredTier = 0
		},
		["3PoopsUpgrade"] = {
			Name = "+2 Poop Production", 
			Price = 85000,
			Description = "Spawn 3 poops instead of 2!",
			Image = "rbxassetid://98642207209330",
			Effect = "ProductionMultiplier",
			Value = 3, 
			Tier = 2,
			RequiredTier = 1, 
			RequiredUpgrade = "2PoopsUpgrade"
		},
		["4PoopsUpgrade"] = {
			Name = "+3 Poop Production",
			Price = 1000000, 
			Description = "Spawn 4 poops instead of 3!",
			Image = "rbxassetid://98642207209330",
			Effect = "ProductionMultiplier", 
			Value = 4, 
			Tier = 3,
			RequiredTier = 2,
			RequiredUpgrade = "3PoopsUpgrade"
		},
		["5PoopsUpgrade"] = {
			Name = "+4 Poop Production",
			Price = 8000000, 
			Description = "Spawn 5 poops instead of 4!",
			Image = "rbxassetid://98642207209330",
			Effect = "ProductionMultiplier", 
			Value = 5,
			Tier = 4,
			RequiredTier = 3,
			RequiredUpgrade = "4PoopsUpgrade"
		},
		["6PoopsUpgrade"] = {
			Name = "+5 Poop Production",
			Price = 55000000, 
			Description = "Spawn 6 poops instead of 5!",
			Image = "rbxassetid://98642207209330",
			Effect = "ProductionMultiplier",
			Value = 6, 
			Tier = 5,
			RequiredTier = 4,
			RequiredUpgrade = "5PoopsUpgrade"
		},
		["7PoopsUpgrade"] = {
			Name = "+6 Poop Production",
			Price = 350000000, 
			Description = "Spawn 7 poops instead of 6!",
			Image = "rbxassetid://98642207209330",
			Effect = "ProductionMultiplier",
			Value = 7, 
			Tier = 6,
			RequiredTier = 5,
			RequiredUpgrade = "6PoopsUpgrade"
		},
		["8PoopsUpgrade"] = {
			Name = "+7 Poop Production",
			Price = 550000000, 
			Description = "Spawn 8 poops instead of 7!",
			Image = "rbxassetid://98642207209330",
			Effect = "ProductionMultiplier",
			Value = 8, 
			Tier = 7,
			RequiredTier = 6,
			RequiredUpgrade = "7PoopsUpgrade"
		},
		["9PoopsUpgrade"] = {
			Name = "+8 Poop Production",
			Price = 1050000000, 
			Description = "Spawn 9 poops instead of 8!",
			Image = "rbxassetid://98642207209330",
			Effect = "ProductionMultiplier",
			Value = 9, 
			Tier = 8,
			RequiredTier = 7,
			RequiredUpgrade = "8PoopsUpgrade"
		},
		["10PoopsUpgrade"] = {
			Name = "+9 Poop Production",
			Price = 15000000000, 
			Description = "Spawn 10 poops instead of 9!",
			Image = "rbxassetid://98642207209330",
			Effect = "ProductionMultiplier",
			Value = 10, 
			Tier = 9,
			RequiredTier = 8,
			RequiredUpgrade = "9PoopsUpgrade"
		},
	},

	-- ═══════════════════════════════════════════════════════════════
	-- ENHANCED GAMEPASS CONFIGURATION - ALL NEW GAMEPASSES
	-- ═══════════════════════════════════════════════════════════════
	Gamepasses = {
		-- EXISTING GAMEPASSES (Updated to remove prerequisites)
		["2xPooBucks"] = {
			Name = "2x PooBucks",
			Price = 250,
			Description = "Double your PooBucks earnings permanently! Stacks with other multipliers.",
			Image = "rbxassetid://134507030110259",
			GamepassId = 1346364423, 
			GiftDevProductId = 3349092827,
			Effect = "CurrencyMultiplier",
			Value = 2,
			GiftDescription = "Gift this player permanent 2x PooBucks earnings!",
			Tier = 1,  -  Edit
  12:31:15.399  			RequiredTier = 0,
			Stacking = true
		},

		["4xPooBucks"] = {
			Name = "4x PooBucks", 
			Price = 500,
			Description = "Quadruple your PooBucks earnings permanently! Stacks with other multipliers.",
			Image = "rbxassetid://134507030110259",
			GamepassId = 1350896316,
			GiftDevProductId = 3349104934,
			Effect = "CurrencyMultiplier",
			Value = 4,
			GiftDescription = "Gift this player permanent 4x PooBucks earnings!",
			Tier = 2,
			RequiredTier = 0, -- REMOVED REQUIREMENT
			Stacking = true
		},

		-- NEW GAMEPASSES
		["6xPooBucks"] = {
			Name = "6x PooBucks",
			Price = 645,
			Description = "Multiply your PooBucks by 6 permanently! Stacks with other multipliers.",
			Image = "rbxassetid://134507030110259",
			GamepassId = 1385214518, -- YOU NEED TO CREATE THIS GAMEPASS
			GiftDevProductId = 3361911096, -- YOU NEED TO CREATE THIS DEVPRODUCT
			Effect = "CurrencyMultiplier",
			Value = 6,
			GiftDescription = "Gift this player permanent 6x PooBucks earnings!",
			Tier = 1,
			RequiredTier = 0,
			Stacking = true
		},

		["2xPoopProduction"] = {
			Name = "2x Poop Production",
			Price = 450,
			Description = "Double your poop production! If you have 5 poop production upgrade, you'll get 10 total.",
			Image = "rbxassetid://98642207209330",
			GamepassId = 1346984317, -- YOU NEED TO CREATE THIS GAMEPASS
			GiftDevProductId = 3361911732, -- YOU NEED TO CREATE THIS DEVPRODUCT
			Effect = "ProductionMultiplier",
			Value = 2,
			GiftDescription = "Gift this player permanent 2x poop production!",
			Tier = 1,
			RequiredTier = 0,
			Stacking = true
		},

		["4xPoopProduction"] = {
			Name = "4x Poop Production", 
			Price = 1000,
			Description = "Quadruple your poop production! If you have 2 poop production upgrade, you'll spawn 8 total.",
			Image = "rbxassetid://98642207209330",
			GamepassId = 1385172477, -- YOU NEED TO CREATE THIS GAMEPASS
			GiftDevProductId = 3361912071, -- YOU NEED TO CREATE THIS DEVPRODUCT
			Effect = "ProductionMultiplier",
			Value = 4,
			GiftDescription = "Gift this player permanent 4x poop production!",
			Tier = 1,
			RequiredTier = 0,
			Stacking = true
		},

		["VIPZone"] = {
			Name = "VIP Zone Access",
			Price = 550,
			Description = "Access the exclusive VIP Zone with 8x PooBucks! Get a crown emoji in chat!",
			Image = "rbxassetid://134507030110259",
			GamepassId = 1389980453, -- YOU NEED TO CREATE THIS GAMEPASS
			GiftDevProductId = 3361912586, -- YOU NEED TO CREATE THIS DEVPRODUCT
			Effect = "VIPAccess",
			Value = 8, -- 8x multiplier in VIP zone
			GiftDescription = "Gift this player VIP Zone access!",
			Tier = 1,
			RequiredTier = 0,
			Stacking = false -- Special effect, doesn't stack
		},

		["LuckBonus"] = {
			Name = "Luck Bonus",
			Price = 100,
			Description = "5% chance each poop gives 1.5x more PooBucks!",
			Image = "rbxassetid://134507030110259",
			GamepassId = 1387016203, -- YOU NEED TO CREATE THIS GAMEPASS
			GiftDevProductId = 3361912985, -- YOU NEED TO CREATE THIS DEVPRODUCT
			Effect = "LuckBonus",
			Value = 1.5, -- 1.5x multiplier when triggered
			Chance = 0.05, -- 5% chance
			GiftDescription = "Gift this player permanent luck bonus!",
			Tier = 1,
			RequiredTier = 0,
			Stacking = true
		},

		["MegaLuckBonus"] = {
			Name = "Mega Luck Bonus",
			Price = 250,
			Description = "5% chance each poop gives 2.5x more PooBucks!",
			Image = "rbxassetid://134507030110259", 
			GamepassId = 1386692385, -- YOU NEED TO CREATE THIS GAMEPASS
			GiftDevProductId = 3361913392, -- YOU NEED TO CREATE THIS DEVPRODUCT
			Effect = "LuckBonus",
			Value = 2.5, -- 2.5x multiplier when triggered
			Chance = 0.05, -- 5% chance
			GiftDescription = "Gift this player permanent mega luck bonus!",
			Tier = 1,
			RequiredTier = 0,
			Stacking = true
		},

		["AutoPoop"] = {
			Name = "Auto Poop",
			Price = 150,
			Description = "Automatically get money as if you pooped every second!",
			Image = "rbxassetid://134507030110259",
			GamepassId = 1387004392, -- YOU NEED TO CREATE THIS GAMEPASS
			GiftDevProductId = 3361913816, -- YOU NEED TO CREATE THIS DEVPRODUCT
			Effect = "AutoPoop",
			Value = 1, -- Every 1 second
			GiftDescription = "Gift this player auto poop!",
			Tier = 1,
			RequiredTier = 0,
			Stacking = false
		},

		["StrongerAutoPoop"] = {
			Name = "Stronger Auto Poop",
			Price = 250,
			Description = "Automatically get money as if you pooped every 0.4 seconds!",
			Image = "rbxassetid://134507030110259",
			GamepassId = 1385286489, -- YOU NEED TO CREATE THIS GAMEPASS
			GiftDevProductId = 3361914113, -- YOU NEED TO CREATE THIS DEVPRODUCT
			Effect = "AutoPoop",
			Value = 0.4, -- Every 0.4 seconds
			GiftDescription = "Gift this player stronger auto poop!",
			Tier = 1,
			RequiredTier = 0,
			Stacking = false -- Replaces regular auto poop
		},

		["UnlockAllZones"] = {
			Name = "Unlock All Zones",
			Price = 250,
			Description = "Instantly unlock all zones (except VIP zone)! No poop requirements needed.",
			Image = "rbxassetid://134507030110259",
			GamepassId = 1386336461, -- YOU NEED TO CREATE THIS GAMEPASS
			GiftDevProductId = 3361914453, -- YOU NEED TO CREATE THIS DEVPRODUCT
			Effect = "UnlockZones",
			Value = 1,
			GiftDescription = "Gift this player all zone unlocks!",
			Tier = 1,
			RequiredTier = 0,
			Stacking = false
		},

		["RebirthMultiplier"] = {
			Name = "Rebirth Multiplier",
			Price = 150,
			Description = "Get 100% more PooBucks from each rebirth instead of 50%!",
			Image = "rbxassetid://134507030110259",
			GamepassId = 1386064482, -- YOU NEED TO CREATE THIS GAMEPASS  
			GiftDevProductId = 3361914950, -- YOU NEED TO CREATE THIS DEVPRODUCT
			Effect = "RebirthBonus",
			Value = 1.0, -- 100% instead of 50%
			GiftDescription = "Gift this player enhanced rebirth multiplier!",
			Tier = 1,
			RequiredTier = 0,
			Stacking = false
		}
	},

	-- ═══════════════════════════════════════════════════════════════
	-- ENHANCED BOOST CONFIGURATION - ALL NEW BOOSTS
	-- ═══════════════════════════════════════════════════════════════
	Boosts = {
		-- EXISTING BOOSTS
		["2xPooBucksBoost"] = {
			Name = "2x PooBucks Boost",
			Price = 30,
			Description = "Doubles your PooBucks earnings for 15 minutes!",
			Duration = 600, -- 15 minutes
			Image = "rbxassetid://134507030110259",
			DevProductId = 3347689445,
			GiftDevProductId = 3349303195,
			Effect = "CurrencyMultiplier",
			Value = 2,
			ButtonName = "2xPooBucksBoostButton",
			GiftDescription = "Gift this player 15 minutes of 2x PooBucks earnings!",
			Stackable = true,
			Tier = 1
		},

		["4xPooBucksBoost"] = {
			Name = "4x PooBucks Boost",
			Price = 55,
			Description = "Multiplies your PooBucks earnings by 4 for 15 minutes!",
			Duration = 600, -- 15 minutes
			Image = "rbxassetid://134507030110259",  -  Edit
  12:31:15.399  			DevProductId = 3349315411,
			GiftDevProductId = 3349315023,
			Effect = "CurrencyMultiplier",
			Value = 4,
			ButtonName = "4xPooBucksBoostButton",
			GiftDescription = "Gift this player 15 minutes of 4x PooBucks earnings!",
			Stackable = true,
			Tier = 2
		},

		-- NEW BOOSTS
		["6xPooBucksBoost"] = {
			Name = "6x PooBucks Boost",
			Price = 65,
			Description = "Multiplies your PooBucks earnings by 6 for 10 minutes!",
			Duration = 600, -- 10 minutes (powerful so shorter)
			Image = "rbxassetid://134507030110259",
			DevProductId = 3361917708, -- YOU NEED TO CREATE THIS DEVPRODUCT
			GiftDevProductId = 3361915985, -- YOU NEED TO CREATE THIS DEVPRODUCT
			Effect = "CurrencyMultiplier",
			Value = 6,
			ButtonName = "6xPooBucksBoostButton",
			GiftDescription = "Gift this player 10 minutes of 6x PooBucks earnings!",
			Stackable = true,
			Tier = 3
		},

		["2xPoopProductionBoost"] = {
			Name = "2x Poop Production Boost",
			Price = 45,
			Description = "Double your poop production for 15 minutes!",
			Duration = 600, -- 15 minutes
			Image = "rbxassetid://98642207209330",
			DevProductId = 3361918104, -- YOU NEED TO CREATE THIS DEVPRODUCT
			GiftDevProductId = 3361916227, -- YOU NEED TO CREATE THIS DEVPRODUCT
			Effect = "ProductionMultiplier", 
			Value = 2,
			ButtonName = "2xPoopProductionBoostButton",
			GiftDescription = "Gift this player 15 minutes of 2x poop production!",
			Stackable = true,
			Tier = 1
		},

		["4xPoopProductionBoost"] = {
			Name = "4x Poop Production Boost",
			Price = 65,
			Description = "Quadruple your poop production for 10 minutes!",
			Duration = 600, -- 10 minutes (powerful so shorter)
			Image = "rbxassetid://98642207209330",
			DevProductId = 3361919620, -- YOU NEED TO CREATE THIS DEVPRODUCT
			GiftDevProductId = 3361920627, -- YOU NEED TO CREATE THIS DEVPRODUCT
			Effect = "ProductionMultiplier",
			Value = 4,
			ButtonName = "4xPoopProductionBoostButton", 
			GiftDescription = "Gift this player 10 minutes of 4x poop production!",
			Stackable = true,
			Tier = 2
		},

		["+2PoopProductionBoost"] = {
			Name = "+2 Poop Production Boost",
			Price = 30,
			Description = "Add 2 extra poops to your production for 15 minutes!",
			Duration = 600, -- 15 minutes
			Image = "rbxassetid://98642207209330",
			DevProductId = nil, -- YOU NEED TO CREATE THIS DEVPRODUCT
			GiftDevProductId = nil, -- YOU NEED TO CREATE THIS DEVPRODUCT
			Effect = "ProductionAdditive",
			Value = 2, -- +2 poops
			ButtonName = "Plus2PoopProductionBoostButton",
			GiftDescription = "Gift this player 15 minutes of +2 poop production!",
			Stackable = true,
			Tier = 1
		},

		["MegaLuckBoostTemp"] = {
			Name = "Mega Luck Bonus",
			Price = 35,
			Description = "5% chance each poop gets 2.5x more PooBucks for 15 minutes!",
			Duration = 600, -- 15 minutes
			Image = "rbxassetid://134507030110259",
			DevProductId = 3361922068, -- YOU NEED TO CREATE THIS DEVPRODUCT
			GiftDevProductId = 3361922228, -- YOU NEED TO CREATE THIS DEVPRODUCT
			Effect = "LuckBonus",
			Value = 2.5,
			Chance = 0.05, -- 5% chance
			ButtonName = "MegaLuckBoostButton",
			GiftDescription = "Gift this player 15 minutes of mega luck bonus!",
			Stackable = true,
			Tier = 2
		},

		["LuckBoostTemp"] = {
			Name = "Luck Bonus",
			Price = 25,
			Description = "5% chance each poop gets 1.5x more PooBucks for 15 minutes!",
			Duration = 600, -- 15 minutes
			Image = "rbxassetid://134507030110259",
			DevProductId = 3361923242, -- YOU NEED TO CREATE THIS DEVPRODUCT
			GiftDevProductId = 3361923509, -- YOU NEED TO CREATE THIS DEVPRODUCT
			Effect = "LuckBonus",
			Value = 1.5,
			Chance = 0.05, -- 5% chance
			ButtonName = "LuckBoostButton",
			GiftDescription = "Gift this player 15 minutes of luck bonus!",
			Stackable = true,
			Tier = 1
		},

		["AutoPoopBoost"] = {
			Name = "Auto Poop",
			Price = 25,
			Description = "Automatically get money as if you pooped every second for 15 minutes!",
			Duration = 600, -- 15 minutes
			Image = "rbxassetid://134507030110259",
			DevProductId = nil, -- YOU NEED TO CREATE THIS DEVPRODUCT
			GiftDevProductId = nil, -- YOU NEED TO CREATE THIS DEVPRODUCT
			Effect = "AutoPoop",
			Value = 1, -- Every 1 second
			ButtonName = "AutoPoopBoostButton",
			GiftDescription = "Gift this player 15 minutes of auto poop!",
			Stackable = false, -- Auto poop effects replace each other
			Tier = 1
		},

		["StrongerAutoPoopBoost"] = {
			Name = "Stronger Auto Poop",
			Price = 40,
			Description = "Automatically get money as if you pooped every 0.4 seconds for 10 minutes!",
			Duration = 600, -- 10 minutes (powerful so shorter)
			Image = "rbxassetid://134507030110259",
			DevProductId = 3361924744, -- YOU NEED TO CREATE THIS DEVPRODUCT
			GiftDevProductId = 3361926197, -- YOU NEED TO CREATE THIS DEVPRODUCT
			Effect = "AutoPoop",
			Value = 0.4, -- Every 0.4 seconds
			ButtonName = "StrongerAutoPoopBoostButton",
			GiftDescription = "Gift this player 10 minutes of stronger auto poop!",
			Stackable = false, -- Auto poop effects replace each other
			Tier = 2
		}
	},

	-- ═══════════════════════════════════════════════════════════════
	-- ENHANCED EFFECTS SYSTEM - SUPPORTS ALL NEW EFFECT TYPES
	-- ═══════════════════════════════════════════════════════════════
	
	-- Add this section to your ShopConfig (around line 300-400)
	-- ═══════════════════════════════════════════════════════════════
	-- PORTAL SYSTEM CONFIGURATION
	-- ═══════════════════════════════════════════════════════════════
	Portals = {
		Effects = {
			TeleportSoundId = "rbxassetid://12222183",
			RequirementNotMetSound = "rbxassetid://9066167010",
			Volume = 0.6,
			CooldownTime = 2,
			FadeDuration = 0.3
		},

		PortalConfigs = {
			["Zone1Portal"] = {
				DestinationZone = "Zone1",
				RequirementType = "PoopsPooped", -- "PoopsPooped", "PooBucks", "Rebirths", or "None"
				RequirementAmount = 350,
				RequirementMessage = "You need 350 poops pooped to enter Zone 1!",
				Enabled = true
			},

			["Zone2Portal"] = {
				DestinationZone = "Zone2",
				RequirementType = "PoopsPooped",
				RequirementAmount = 750,
				RequirementMessage = "You need 750 poops pooped to enter Zone 2!",
				Enabled = true
			},

			["Zone3Portal"] = {
				DestinationZone = "Zone3",
				RequirementType = "PoopsPooped",
				RequirementAmount = 1500,
				RequirementMessage = "You need 1500 poops pooped to enter Zone 3!",
				Enabled = true
			},

			["VIPPortal"] = {
				DestinationZone = "Zone4",
				RequirementType = "None", -- VIP zone uses gamepass requirement
				RequirementAmount = 0,
				RequirementMessage = "VIP Zone Access Required!",
				Enabled = true
			},

			["MainMapPortal"] = {
				DestinationZone = "MainMap",
				RequirementType = "None",
				RequirementAmount = 0,
				RequirementMessage = "",
				Enabled = true
			}
		}  -  Edit
  12:31:15.400  	},
	
	
	Effects = {
		CurrencyMultiplier = {
			Description = "Multiplies PooBucks gained from pooping",
			AppliesTo = {"Gamepasses", "Boosts", "Zones", "Rebirth"},
			StackingBehavior = "Additive" -- 2x + 4x + 6x = 12x total
		},

		ProductionMultiplier = {
			Description = "Multiplies number of poops spawned per click", 
			AppliesTo = {"Upgrades", "Gamepasses", "Boosts"},
			StackingBehavior = "Multiplicative" -- Upgrades give base, gamepasses/boosts multiply
		},

		ProductionAdditive = {
			Description = "Adds extra poops to production",
			AppliesTo = {"Boosts"},
			StackingBehavior = "Additive" -- +2 boost + +3 boost = +5 total
		},

		LuckBonus = {
			Description = "Chance-based multiplier for poop rewards",
			AppliesTo = {"Gamepasses", "Boosts"},
			StackingBehavior = "Independent" -- Each luck bonus rolls independently
		},

		AutoPoop = {
			Description = "Automatically generates poop rewards over time",
			AppliesTo = {"Gamepasses", "Boosts"},
			StackingBehavior = "Replacement" -- Stronger auto poop replaces weaker
		},

		VIPAccess = {
			Description = "Access to VIP zone with special multiplier",
			AppliesTo = {"Gamepasses"},
			StackingBehavior = "Unique" -- Special zone access
		},

		UnlockZones = {
			Description = "Bypasses zone unlock requirements", 
			AppliesTo = {"Gamepasses"},
			StackingBehavior = "Unique" -- One-time unlock effect
		},

		RebirthBonus = {
			Description = "Enhances rebirth multiplier bonus",
			AppliesTo = {"Gamepasses"},
			StackingBehavior = "Replacement" -- Replaces default rebirth bonus
		}
	},

	-- ═══════════════════════════════════════════════════════════════
	-- PREVIEW CONFIGURATION
	-- ═══════════════════════════════════════════════════════════════
	Preview = {
		ModelOffset = Vector3.new(0, 0, -2.5),
		ModelRotation = Vector3.new(0, 0, 0),
		SpinSpeed = 0.5 -- Rotations per second
	}
}

>>> game.ReplicatedStorage.TutorialConfig (ModuleScript) — 254 lines
-- TutorialConfig (ModuleScript in ReplicatedStorage) - FULLY DATA-DRIVEN SYSTEM
return {
	-- ═══════════════════════════════════════════════════════════════
	-- DEBUG SETTINGS - SET TO FALSE TO DISABLE ALL DEBUG
	-- ═══════════════════════════════════════════════════════════════
	Debug = {
		Enabled = true, -- SET THIS TO FALSE TO DISABLE ALL DEBUG
		ShowTutorialDebug = true
	},

	-- Tutorial Step Configuration (FULLY FLEXIBLE - EASY TO ADD NEW STEPS)
	Steps = {
		{
			StepID = "Welcome",
			Title = "Welcome",
			Text = "Welcome to Poop Simulator! Please complete this tutorial for 100 PooBucks.",
			RequirementType = "ButtonClick",
			ButtonText = "Start",
			ShowBeam = false,
			BeamTarget = nil
		},

		{
			StepID = "LearnPooping",
			Title = "Poop",
			Text = "Press P on your keyboard or click the poop button to poop! Poop 50 times to continue.",
			RequirementType = "PoopCount",
			RequiredAmount = 50,
			CurrentProgress = 0,
			ButtonText = "Next (0/50)",
			ShowBeam = false,
			BeamTarget = nil,
			ProgressFormat = "(%d/50)",
		},

		{
			StepID = "ShopAndBuy",
			Title = "Shop",
			Text = "Great! Now follow the trail to the shop, open it, and buy 'Stinky Poop' to upgrade your pooping power. It costs 50 PooBucks.",
			RequirementType = "PurchaseItem",
			RequiredItem = "StinkyPoop",
			ButtonText = "Next",
			ShowBeam = true,
			BeamTarget = "ToShop1",
			BeamEnabled = true,
			OwnedText = "Great! You already own Stinky Poop! This upgrade increases your pooping power.",
			EventToMonitor = "PurchaseSuccess" -- NEW: Specify which event to monitor
		},

		{
			StepID = "ExploreZones",
			Title = "Zones",
			Text = "Excellent! Now let's check out the zone area! Follow the trail to the zone area.",
			RequirementType = "TouchPart",
			RequiredPart = "ToZonesPart2",
			ButtonText = "Next",
			ShowBeam = true,
			BeamTarget = "ToZonesPart2",
			BeamEnabled = true
		},

		{
			StepID = "AfterExploreZones",
			Title = "Zones",
			Text = "Zones are one of the main ways to get more PooBucks!",
			RequirementType = "ButtonClick",
			ButtonText = "Next",
			ShowBeam = false,
			BeamTarget = nil
		},

		{
			StepID = "CheckLeaderboards", 
			Title = "Leaderboards",
			Text = "Great! Finally, let's check out the leaderboards to see how you compare to other players.",
			RequirementType = "TouchPart",
			RequiredPart = "ToLeaderboardPart3",
			ButtonText = "Next", 
			ShowBeam = true,
			BeamTarget = "ToLeaderboardsPart3",
			BeamEnabled = true
		},

		{
			StepID = "Leaderboards",
			Title = "Leaderboards",
			Text = "I really hope you can make it to the top one day!",
			RequirementType = "ButtonClick",
			ButtonText = "Next",
			ShowBeam = false,
			BeamTarget = nil
		},

		{
			StepID = "AlmostComplete",
			Title = "Tutorial",
			Text = "If you have any problems please give me feedback in the settings button!!",
			RequirementType = "ButtonClick",
			ButtonText = "Next",
			ShowBeam = false,
			BeamTarget = nil
		},

		{
			StepID = "TutorialComplete",
			Title = "Tutorial",
			Text = "And finally, you're done with the tutorial. You're now free to play!",
			RequirementType = "ButtonClick",
			ButtonText = "Finish",
			ShowBeam = false,
			BeamTarget = nil,
			CompleteTutorial = true
		},
	},

	-- Tutorial Parts Configuration (FIXED NAMING)
	TutorialParts = {
		PlayerParts = {
			"PlayerTutorialPart1",
			"PlayerTutorialPart2", 
			"PlayerTutorialPart3"
		},

		BeamParts = {
			ToShop1 = {
				PartName = "ToShop1",
				BeamName = "Beam",
				AttachmentName = "Attachment"
			},
			ToZonesPart2 = {
				PartName = "ToZonesPart2", 
				BeamName = "Beam",
				AttachmentName = "Attachment"
			},
			ToLeaderboardsPart3 = {
				PartName = "ToLeaderboardPart3",  -  Edit
  12:31:15.400  				BeamName = "Beam", 
				AttachmentName = "Attachment"
			}
			-- EASY TO ADD: Just add new beam targets here!
			-- CoinArea = {
			-- 	PartName = "CoinAreaPart",
			-- 	BeamName = "Beam",
			-- 	AttachmentName = "Attachment"
			-- },
			-- NPCBob = {
			-- 	PartName = "BobNPCPart",
			-- 	BeamName = "Beam",
			-- 	AttachmentName = "Attachment"
			-- }
		}
	},

	-- Rewards for completing tutorial (ONLY FOR COMPLETION, NOT SKIPPING)
	CompletionRewards = {
		PooBucks = 100,
		ShowCompletionMessage = true,
		CompletionMessage = "Here's 100 PooBucks as thanks for completing the tutorial!",
		SkipMessage = "Tutorial skipped! You can always restart it from settings." -- NEW: Skip message
	},

	-- NEW: Step Requirement Types - Define how each requirement type works
	RequirementTypes = {
		ButtonClick = {
			Description = "Player must click the next button",
			AutoComplete = true,
			RequiresProgress = false
		},
		PoopCount = {
			Description = "Player must poop a certain number of times",
			AutoComplete = false,
			RequiresProgress = true,
			ProgressField = "CurrentProgress",
			AmountField = "RequiredAmount"
		},
		PurchaseItem = {
			Description = "Player must purchase a specific item",
			AutoComplete = false,
			RequiresProgress = false,
			ItemField = "RequiredItem"
		},
		TouchPart = {
			Description = "Player must touch a specific part",
			AutoComplete = false,
			RequiresProgress = false,
			PartField = "RequiredPart"
		},
		CollectItems = {
			Description = "Player must collect a certain number of items",
			AutoComplete = false,
			RequiresProgress = true,
			ProgressField = "CurrentProgress",
			AmountField = "RequiredAmount",
			ItemField = "RequiredItem"
		},
		NPCInteraction = {
			Description = "Player must interact with an NPC",
			AutoComplete = false,
			RequiresProgress = false,
			NPCField = "RequiredNPC"
		},
		ReachLevel = {
			Description = "Player must reach a certain level",
			AutoComplete = false,
			RequiresProgress = false,
			LevelField = "RequiredLevel"
		}
		-- ADD NEW TYPES HERE! The system will automatically handle them
	},

	-- GUI Configuration (ULTRA SMOOTH ANIMATIONS)
	GUI = {
		-- Main GUI animations (MUCH SMOOTHER)
		TweenDuration = 0.8,
		EasingStyle = Enum.EasingStyle.Quint,
		EasingDirection = Enum.EasingDirection.Out,
		HideTweenDuration = 0.6,
		HideEasingStyle = Enum.EasingStyle.Quint,
		HideEasingDirection = Enum.EasingDirection.In,

		-- Button animations (SMOOTHER)
		ButtonHover = {
			Duration = 0.25,
			EasingStyle = Enum.EasingStyle.Quint,
			EasingDirection = Enum.EasingDirection.Out,
			ScaleMultiplier = 1.05,
			ColorBrightness = 1.2
		},

		ButtonClick = {
			Duration = 0.12,
			EasingStyle = Enum.EasingStyle.Quad,
			EasingDirection = Enum.EasingDirection.Out,
			ScaleMultiplier = 0.96
		},

		ButtonStateChange = {
			Duration = 0.4,
			EasingStyle = Enum.EasingStyle.Quint,
			EasingDirection = Enum.EasingDirection.Out
		},

		-- Text animations (SMOOTHER)
		TextAppear = {
			Duration = 0.6,
			EasingStyle = Enum.EasingStyle.Quint,
			EasingDirection = Enum.EasingDirection.Out
		},

		-- Element stagger timing (SMOOTHER)
		StaggerDelay = 0.08,
		TextStaggerDelay = 0.12
	}
}

>>> game.ServerScriptService.AutoPoopSystem (Script) — 274 lines
-- AutoPoopSystem (ServerScript in ServerScriptService) - FIXED FUNCTION ORDER
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Get ShopConfig
local ShopConfig = require(ReplicatedStorage:WaitForChild("ShopConfig"))

-- Debug system
local function debugPrint(message)
	if ShopConfig.Debug.Enabled and ShopConfig.Debug.ShowServerDebug then
		print("[AUTO POOP]: " .. message)
	end
end

-- Player auto poop tracking
local PlayerAutoPoopData = {}

-- Auto poop sounds - FIXED
local autoPoopSound = Instance.new("Sound")
if ShopConfig.Sounds and ShopConfig.Sounds.AutoPoopTick then
	autoPoopSound.SoundId = ShopConfig.Sounds.AutoPoopTick
else
	autoPoopSound.SoundId = "rbxassetid://98112849852832"
end

if ShopConfig.Sounds and ShopConfig.Sounds.Volumes and ShopConfig.Sounds.Volumes.AutoPoop then
	autoPoopSound.Volume = ShopConfig.Sounds.Volumes.AutoPoop
else
	autoPoopSound.Volume = 0.3
end

autoPoopSound.Parent = workspace

debugPrint("AutoPoopSystem initializing...")

-- FIXED: Define stopAutoPoop first (forward declaration)
local stopAutoPoop

-- Function to get player's auto poop interval
local function getPlayerAutoPoopInterval(player)
	local bestInterval = nil

	-- Check gamepasses first (permanent effects)
	if _G.ShopPlayerData and _G.ShopPlayerData[player] and _G.ShopPlayerData[player].OwnedGamepasses then
		for _, gamepassKey in pairs(_G.ShopPlayerData[player].OwnedGamepasses) do
			local gamepassConfig = ShopConfig.Gamepasses[gamepassKey]
			if gamepassConfig and gamepassConfig.Effect == "AutoPoop" then
				local interval = gamepassConfig.Value
				if not bestInterval or interval < bestInterval then
					bestInterval = interval
					debugPrint("Found auto poop gamepass: " .. gamepassKey .. " - " .. interval .. "s interval")
				end
			end
		end
	end

	-- Check boosts (temporary effects that can override gamepasses)
	if _G.BoostSystem and _G.BoostSystem.GetPlayerBoosts then
		local playerBoosts = _G.BoostSystem.GetPlayerBoosts(player)
		for boostKey, boostData in pairs(playerBoosts) do
			if boostData.effect == "AutoPoop" then
				local interval = boostData.value
				if not bestInterval or interval < bestInterval then
					bestInterval = interval
					debugPrint("Found auto poop boost: " .. boostKey .. " - " .. interval .. "s interval (overriding gamepass)")
				end
			end
		end
	end

	return bestInterval
end

-- Function to calculate auto poop earnings
local function calculateAutoPoopEarnings(player)
	-- Get base poop gain
	local baseGain = 1
	if _G.ShopPlayerData and _G.ShopPlayerData[player] then
		local equippedPoop = _G.ShopPlayerData[player].EquippedPoop  -  Edit
  12:31:15.402  		if equippedPoop and ShopConfig.Poops[equippedPoop] then
			baseGain = ShopConfig.Poops[equippedPoop].Gain or 1
		end
	end

	local totalMultiplier = 1

	-- Apply boost multipliers
	if _G.BoostSystem and _G.BoostSystem.GetEffectMultiplier then
		totalMultiplier = totalMultiplier * _G.BoostSystem.GetEffectMultiplier(player, "CurrencyMultiplier")
	end

	-- Apply gamepass multipliers (additive stacking)
	if _G.ShopPlayerData and _G.ShopPlayerData[player] and _G.ShopPlayerData[player].OwnedGamepasses then
		local gamepassMultiplier = 0
		for _, gamepassKey in pairs(_G.ShopPlayerData[player].OwnedGamepasses) do
			local gamepassConfig = ShopConfig.Gamepasses[gamepassKey]
			if gamepassConfig and gamepassConfig.Effect == "CurrencyMultiplier" then
				gamepassMultiplier = gamepassMultiplier + gamepassConfig.Value
			end
		end

		if gamepassMultiplier > 0 then
			totalMultiplier = totalMultiplier * gamepassMultiplier
		end
	end

	-- Apply rebirth multiplier
	if _G.LeaderstatsManager and _G.LeaderstatsManager.GetRebirthMultiplier then
		totalMultiplier = totalMultiplier * _G.LeaderstatsManager.GetRebirthMultiplier(player)
	end

	-- Apply zone multiplier
	if _G.ZoneSystem and _G.ZoneSystem.GetPlayerZoneMultiplier then
		totalMultiplier = totalMultiplier * _G.ZoneSystem.GetPlayerZoneMultiplier(player)
	end

	return math.floor(baseGain * totalMultiplier)
end

-- FIXED: Define stopAutoPoop function first
stopAutoPoop = function(player)
	debugPrint("Stopping auto poop for " .. player.Name)

	if PlayerAutoPoopData[player] then
		PlayerAutoPoopData[player].active = false
		if PlayerAutoPoopData[player].connection then
			PlayerAutoPoopData[player].connection:Disconnect()
		end
		PlayerAutoPoopData[player] = nil
	end
end

-- Function to start auto poop for a player
local function startAutoPoop(player, interval)
	debugPrint("Starting auto poop for " .. player.Name .. " - " .. interval .. "s interval")

	-- FIXED: Now stopAutoPoop is properly defined
	if PlayerAutoPoopData[player] then
		stopAutoPoop(player)
	end

	PlayerAutoPoopData[player] = {
		active = true,
		interval = interval,
		lastTick = tick(),
		connection = nil
	}

	-- Create the auto poop loop
	PlayerAutoPoopData[player].connection = RunService.Heartbeat:Connect(function()
		local data = PlayerAutoPoopData[player]
		if not data or not data.active then return end

		local currentTime = tick()
		if currentTime - data.lastTick >= data.interval then
			data.lastTick = currentTime

			-- Give auto poop earnings with safety checks
			if _G.LeaderstatsManager and _G.LeaderstatsManager.GiveCurrency then
				local earnings = calculateAutoPoopEarnings(player)

				-- FIXED: Add safety check for earnings
				if earnings and type(earnings) == "number" and earnings > 0 then
					local success = _G.LeaderstatsManager.GiveCurrency(player, earnings, "Auto Poop", true)

					if success then
						debugPrint("Auto poop gave " .. earnings .. " PooBucks to " .. player.Name)

						-- Play sound occasionally (not every tick to avoid spam)
						if math.random() < 0.1 and ShopConfig.AutoPoop and ShopConfig.AutoPoop.PlaySounds then
							autoPoopSound:Play()
						end
					end
				end
			end
		end
	end)
end

-- Function to update auto poop for a player
local function updatePlayerAutoPoop(player)
	local interval = getPlayerAutoPoopInterval(player)

	if interval then
		-- Player should have auto poop
		if not PlayerAutoPoopData[player] or not PlayerAutoPoopData[player].active or PlayerAutoPoopData[player].interval ~= interval then
			startAutoPoop(player, interval)
		end
	else
		-- Player should not have auto poop
		if PlayerAutoPoopData[player] and PlayerAutoPoopData[player].active then
			stopAutoPoop(player)
		end
	end
end

-- Monitor auto poop status for all players
spawn(function()
	while true do
		wait(5)

		for _, player in pairs(Players:GetPlayers()) do
			if player.Parent then
				-- FIXED: Add safety check for player
				local success, error = pcall(function()
					updatePlayerAutoPoop(player)
				end)

				if not success then
					debugPrint("Error updating auto poop for " .. player.Name .. ": " .. tostring(error))
				end
			end
		end
	end
end)

-- Player events
Players.PlayerAdded:Connect(function(player)
	debugPrint("Player joined: " .. player.Name)

	spawn(function()
		wait(3)
		-- FIXED: Add safety check
		local success, error = pcall(function()
			updatePlayerAutoPoop(player)
		end)

		if not success then
			debugPrint("Error setting up auto poop for " .. player.Name .. ": " .. tostring(error))
		end
	end)
end)

Players.PlayerRemoving:Connect(function(player)
	debugPrint("Player leaving: " .. player.Name)

	-- FIXED: Add safety check
	local success, error = pcall(function()
		stopAutoPoop(player)
	end)

	if not success then
		debugPrint("Error stopping auto poop for " .. player.Name .. ": " .. tostring(error))
	end
end)

-- Clean up existing players
for _, player in pairs(Players:GetPlayers()) do
	spawn(function()
		wait(1)
		-- FIXED: Add safety check
		local success, error = pcall(function()
			updatePlayerAutoPoop(player)
		end)

		if not success then
			debugPrint("Error initializing auto poop for existing player " .. player.Name .. ": " .. tostring(error))
		end
	end)
end

-- Global functions
_G.AutoPoopSystem = {
	UpdatePlayerAutoPoop = updatePlayerAutoPoop,
	GetPlayerAutoPoopInterval = getPlayerAutoPoopInterval,
	StartAutoPoop = startAutoPoop,
	StopAutoPoop = stopAutoPoop,
	IsPlayerAutoPooping = function(player)
		return PlayerAutoPoopData[player] and PlayerAutoPoopData[player].active or false
	end
}

debugPrint("AutoPoopSystem initialized successfully!")

>>> game.ServerScriptService.BoostsServer (Script) — 504 lines
-- BoostServer (ServerScript in ServerScriptService) - SIMPLIFIED WITHOUT DIALOG
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DataStoreService = game:GetService("DataStoreService")  -  Edit
  12:31:15.402  local MarketplaceService = game:GetService("MarketplaceService")
local RunService = game:GetService("RunService")

-- Get ShopConfig
local ShopConfig = require(ReplicatedStorage:WaitForChild("ShopConfig"))

-- Debug system
local function debugPrint(message)
	if ShopConfig.Debug.Enabled and ShopConfig.Debug.ShowBoostDebug then
		print("[BOOST SERVER]: " .. message)
	end
end

-- DataStore for boost persistence
local BoostDataStore = DataStoreService:GetDataStore("PlayerBoosts_v4")

-- Create RemoteEvents for boost system
local BoostActivatedEvent = Instance.new("RemoteEvent")
BoostActivatedEvent.Name = "BoostActivatedEvent"
BoostActivatedEvent.Parent = ReplicatedStorage

local GetActiveBoostsRemote = Instance.new("RemoteFunction")
GetActiveBoostsRemote.Name = "GetActiveBoostsRemote"
GetActiveBoostsRemote.Parent = ReplicatedStorage

local BoostUpdatedEvent = Instance.new("RemoteEvent")
BoostUpdatedEvent.Name = "BoostUpdatedEvent"
BoostUpdatedEvent.Parent = ReplicatedStorage

local BoostPurchaseRequest = Instance.new("RemoteEvent")
BoostPurchaseRequest.Name = "BoostPurchaseRequest"
BoostPurchaseRequest.Parent = ReplicatedStorage

-- Player boost storage with remaining time
local PlayerBoosts = {}

-- Maximum number of active boosts
local MAX_ACTIVE_BOOSTS = ShopConfig.BoostLimits.MaxActiveBoosts or 4

debugPrint("BoostServer initializing with simplified limit system...")

-- Create boost sounds
local boostActivatedSound = Instance.new("Sound")
boostActivatedSound.SoundId = ShopConfig.Sounds.PurchaseSuccess
boostActivatedSound.Volume = ShopConfig.Sounds.Volumes.Purchase
boostActivatedSound.Parent = workspace

-- BOOST MANAGEMENT FUNCTIONS
local function savePlayerBoosts(player)
	local data = PlayerBoosts[player]
	if not data then return false end

	local saveData = {}
	for boostKey, boostInfo in pairs(data) do
		saveData[boostKey] = {
			remainingTime = boostInfo.remainingTime,
			effect = boostInfo.config.Effect,
			value = boostInfo.config.Value,
			chance = boostInfo.config.Chance
		}
	end

	local success, error = pcall(function()
		BoostDataStore:SetAsync(player.UserId, saveData)
	end)

	if success then
		debugPrint("Saved boosts for " .. player.Name)
		return true
	else
		debugPrint("Failed to save boosts for " .. player.Name .. ": " .. error)
		return false
	end
end

local function loadPlayerBoosts(player)
	local success, data = pcall(function()
		return BoostDataStore:GetAsync(player.UserId)
	end)

	if success and data then
		debugPrint("Loaded boost data for " .. player.Name)

		local loadedBoosts = {}
		local currentTime = tick()

		for boostKey, boostInfo in pairs(data) do
			if boostInfo.remainingTime > 0 and ShopConfig.Boosts[boostKey] then
				loadedBoosts[boostKey] = {
					remainingTime = boostInfo.remainingTime,
					config = ShopConfig.Boosts[boostKey],
					lastUpdate = currentTime
				}
				debugPrint("Restored active boost: " .. boostKey .. " for " .. player.Name .. " (" .. boostInfo.remainingTime .. "s remaining)")
			else
				debugPrint("Expired/invalid boost removed: " .. boostKey .. " for " .. player.Name)
			end
		end

		return loadedBoosts
	else
		debugPrint("No boost data found for " .. player.Name)
		return {}
	end
end

-- Function to count active boosts
local function countActiveBoosts(player)
	local count = 0
	if PlayerBoosts[player] then
		for _, _ in pairs(PlayerBoosts[player]) do
			count = count + 1
		end
	end
	return count
end

-- SIMPLIFIED: Activate boost function - rejects at limit
local function activateBoost(player, boostKey, duration, forceActivate)
	debugPrint("Activating boost " .. boostKey .. " for " .. player.Name .. " (Duration: " .. duration .. "s)")

	local config = ShopConfig.Boosts[boostKey]
	if not config then
		debugPrint("ERROR: Boost config not found for " .. boostKey)
		return false
	end

	if not PlayerBoosts[player] then
		PlayerBoosts[player] = {}
	end

	local currentTime = tick()

	-- SIMPLIFIED: Check boost limit - simply reject if at limit and new boost
	if not PlayerBoosts[player][boostKey] and countActiveBoosts(player) >= MAX_ACTIVE_BOOSTS then
		debugPrint("Boost limit reached for " .. player.Name .. " (" .. countActiveBoosts(player) .. "/" .. MAX_ACTIVE_BOOSTS .. ")")
		return false, "You can only have 4 different boosts active at once!"
	end

	-- Handle non-stackable effects (replace existing)
	if not config.Stackable then
		if config.Effect == "AutoPoop" then
			local toRemove = {}
			for existingKey, existingInfo in pairs(PlayerBoosts[player]) do
				if existingInfo.config.Effect == "AutoPoop" then
					table.insert(toRemove, existingKey)
				end
			end
			for _, key in pairs(toRemove) do
				debugPrint("Removing conflicting auto poop boost: " .. key)
				removeBoost(player, key)
			end
		end
	end

	-- Check if boost already exists (stacking)
	if PlayerBoosts[player][boostKey] then
		if config.Stackable then
			debugPrint("Stacking boost " .. boostKey .. " for " .. player.Name)
			PlayerBoosts[player][boostKey].remainingTime = PlayerBoosts[player][boostKey].remainingTime + duration
			PlayerBoosts[player][boostKey].lastUpdate = currentTime
		else
			debugPrint("Refreshing non-stackable boost " .. boostKey .. " for " .. player.Name)
			PlayerBoosts[player][boostKey].remainingTime = duration
			PlayerBoosts[player][boostKey].lastUpdate = currentTime
		end
	else
		debugPrint("Creating new boost " .. boostKey .. " for " .. player.Name)
		PlayerBoosts[player][boostKey] = {
			remainingTime = duration,
			config = config,
			lastUpdate = currentTime
		}
	end

	local remainingTime = PlayerBoosts[player][boostKey].remainingTime

	-- Play sound
	boostActivatedSound:Play()

	-- Notify client
	BoostActivatedEvent:FireClient(player, boostKey, remainingTime)

	-- Save to datastore
	savePlayerBoosts(player)

	-- Apply boost effects
	applyBoostEffects(player, boostKey, config)

	-- Update auto poop system if this is an auto poop boost
	if config.Effect == "AutoPoop" and _G.AutoPoopSystem then
		_G.AutoPoopSystem.UpdatePlayerAutoPoop(player)
	end

	debugPrint("Boost " .. boostKey .. " activated for " .. player.Name .. " - Remaining: " .. remainingTime .. "s")
	return true
end

function removeBoost(player, boostKey)
	debugPrint("Removing boost " .. boostKey .. " for " .. player.Name)  -  Edit
  12:31:15.402  
	if PlayerBoosts[player] and PlayerBoosts[player][boostKey] then
		local config = PlayerBoosts[player][boostKey].config
		PlayerBoosts[player][boostKey] = nil

		-- Remove boost effects
		removeBoostEffects(player, boostKey, config)

		-- Save changes
		savePlayerBoosts(player)

		-- Notify client
		BoostUpdatedEvent:FireClient(player, boostKey, 0)

		-- Update auto poop system if this was an auto poop boost
		if config.Effect == "AutoPoop" and _G.AutoPoopSystem then
			_G.AutoPoopSystem.UpdatePlayerAutoPoop(player)
		end

		debugPrint("Removed boost " .. boostKey .. " for " .. player.Name)
	end
end

-- Update boost timers (only decrements when player is online)
local function updateBoostTimers(player, deltaTime)
	if not PlayerBoosts[player] then return end

	local currentTime = tick()
	local boostsToRemove = {}

	for boostKey, boostInfo in pairs(PlayerBoosts[player]) do
		local timeSinceUpdate = currentTime - boostInfo.lastUpdate
		boostInfo.remainingTime = boostInfo.remainingTime - timeSinceUpdate
		boostInfo.lastUpdate = currentTime

		if boostInfo.remainingTime <= 0 then
			table.insert(boostsToRemove, boostKey)
		else
			BoostUpdatedEvent:FireClient(player, boostKey, boostInfo.remainingTime)
		end
	end

	for _, boostKey in pairs(boostsToRemove) do
		removeBoost(player, boostKey)
	end
end

local function getActiveBoosts(player)
	if not PlayerBoosts[player] then return {} end

	local activeBoosts = {}

	for boostKey, boostInfo in pairs(PlayerBoosts[player]) do
		if boostInfo.remainingTime > 0 then
			table.insert(activeBoosts, {
				boostKey = boostKey,
				timeLeft = boostInfo.remainingTime,
				config = boostInfo.config
			})
		end
	end

	return activeBoosts
end

-- ENHANCED BOOST EFFECTS SYSTEM
function applyBoostEffects(player, boostKey, config)
	debugPrint("Applying boost effects for " .. boostKey .. ": " .. config.Effect .. " x" .. config.Value)

	if not _G.PlayerBoostEffects then
		_G.PlayerBoostEffects = {}
	end

	if not _G.PlayerBoostEffects[player] then
		_G.PlayerBoostEffects[player] = {}
	end

	_G.PlayerBoostEffects[player][boostKey] = {
		effect = config.Effect,
		value = config.Value,
		chance = config.Chance
	}

	if config.Effect == "CurrencyMultiplier" then
		debugPrint("Currency multiplier applied: x" .. config.Value)

	elseif config.Effect == "ProductionMultiplier" then
		debugPrint("Production multiplier applied: x" .. config.Value)

	elseif config.Effect == "ProductionAdditive" then
		debugPrint("Production additive applied: +" .. config.Value)

	elseif config.Effect == "LuckBonus" then
		debugPrint("Luck bonus applied: " .. (config.Chance * 100) .. "% chance for " .. config.Value .. "x")

	elseif config.Effect == "AutoPoop" then
		debugPrint("Auto poop applied: every " .. config.Value .. " seconds")

	elseif config.Effect == "SpeedMultiplier" then
		if player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
			local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
			local baseSpeed = 16

			local totalMultiplier = 1
			for _, boost in pairs(_G.PlayerBoostEffects[player]) do
				if boost.effect == "SpeedMultiplier" then
					totalMultiplier = totalMultiplier * boost.value
				end
			end

			humanoid.WalkSpeed = baseSpeed * totalMultiplier
			debugPrint("Speed boost applied: " .. humanoid.WalkSpeed)
		end
	end
end

function removeBoostEffects(player, boostKey, config)
	debugPrint("Removing boost effects for " .. boostKey)

	if _G.PlayerBoostEffects and _G.PlayerBoostEffects[player] then
		_G.PlayerBoostEffects[player][boostKey] = nil
	end

	if config.Effect == "SpeedMultiplier" then
		if player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
			local humanoid = player.Character:FindFirstChildOfClass("Humanoid")

			local newSpeed = 16
			if _G.PlayerBoostEffects and _G.PlayerBoostEffects[player] then
				for _, boost in pairs(_G.PlayerBoostEffects[player]) do
					if boost.effect == "SpeedMultiplier" then
						newSpeed = newSpeed * boost.value
					end
				end
			end

			humanoid.WalkSpeed = newSpeed
			debugPrint("Speed reset to: " .. newSpeed)
		end
	end
end

-- ENHANCED GLOBAL HELPER FUNCTIONS
_G.BoostSystem = {
	GetEffectMultiplier = function(player, effectType)
		local multiplier = 1
		if _G.PlayerBoostEffects and _G.PlayerBoostEffects[player] then
			for _, boost in pairs(_G.PlayerBoostEffects[player]) do
				if boost.effect == effectType then
					multiplier = multiplier * boost.value
				end
			end
		end
		return multiplier
	end,

	GetEffectAdditive = function(player, effectType)
		local additive = 0
		if _G.PlayerBoostEffects and _G.PlayerBoostEffects[player] then
			for _, boost in pairs(_G.PlayerBoostEffects[player]) do
				if boost.effect == effectType then
					additive = additive + boost.value
				end
			end
		end
		return additive
	end,

	HasActiveBoosts = function(player)
		return _G.PlayerBoostEffects and _G.PlayerBoostEffects[player] and next(_G.PlayerBoostEffects[player]) ~= nil
	end,

	GetPlayerBoosts = function(player)
		return _G.PlayerBoostEffects and _G.PlayerBoostEffects[player] or {}
	end,

	ActivateBoost = activateBoost,

	CountActiveBoosts = countActiveBoosts,

	GetMaxActiveBoosts = function()
		return MAX_ACTIVE_BOOSTS
	end
}

-- BOOST TIMER MONITORING
spawn(function()
	while true do
		wait(1)

		for player, _ in pairs(PlayerBoosts) do
			if player.Parent then
				updateBoostTimers(player, 1)
			end
		end
	end
end)

-- REMOTE EVENT HANDLERS
GetActiveBoostsRemote.OnServerInvoke = function(player)  -  Edit
  12:31:15.402  	debugPrint("Client requesting active boosts for " .. player.Name)
	return getActiveBoosts(player)
end

BoostPurchaseRequest.OnServerEvent:Connect(function(player, boostKey)
	debugPrint("Boost purchase request: " .. boostKey .. " from " .. player.Name)

	local config = ShopConfig.Boosts[boostKey]
	if not config then
		debugPrint("Invalid boost key: " .. boostKey)
		return
	end

	if not config.DevProductId then
		debugPrint("No DevProduct ID configured for boost: " .. boostKey)
		return
	end

	MarketplaceService:PromptProductPurchase(player, config.DevProductId)
end)

-- PLAYER EVENTS
Players.PlayerAdded:Connect(function(player)
	debugPrint("Player joined: " .. player.Name)

	PlayerBoosts[player] = loadPlayerBoosts(player)

	if not _G.PlayerBoostEffects then
		_G.PlayerBoostEffects = {}
	end
	_G.PlayerBoostEffects[player] = {}

	-- Apply loaded boosts
	for boostKey, boostInfo in pairs(PlayerBoosts[player]) do
		applyBoostEffects(player, boostKey, boostInfo.config)
		debugPrint("Resumed boost " .. boostKey .. " for " .. player.Name .. " with " .. boostInfo.remainingTime .. "s remaining")
	end

	-- Auto-save boosts
	spawn(function()
		while player.Parent do
			wait(60)
			if PlayerBoosts[player] then
				savePlayerBoosts(player)
			end
		end
	end)
end)

Players.PlayerRemoving:Connect(function(player)
	debugPrint("Player leaving: " .. player.Name)

	if PlayerBoosts[player] then
		savePlayerBoosts(player)
		PlayerBoosts[player] = nil
	end

	if _G.PlayerBoostEffects and _G.PlayerBoostEffects[player] then
		_G.PlayerBoostEffects[player] = nil
	end
end)

-- CHARACTER RESPAWN HANDLING
Players.PlayerAdded:Connect(function(player)
	player.CharacterAdded:Connect(function(character)
		wait(1)

		-- Reapply speed boosts
		if _G.PlayerBoostEffects and _G.PlayerBoostEffects[player] then
			local speedMultiplier = 1
			for _, boost in pairs(_G.PlayerBoostEffects[player]) do
				if boost.effect == "SpeedMultiplier" then
					speedMultiplier = speedMultiplier * boost.value
				end
			end

			if speedMultiplier > 1 then
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid.WalkSpeed = 16 * speedMultiplier
					debugPrint("Reapplied speed boost for " .. player.Name .. ": " .. humanoid.WalkSpeed)
				end
			end
		end
	end)
end)

-- SHUTDOWN HANDLING
game:BindToClose(function()
	debugPrint("Server shutting down - saving all boost data...")
	for player, _ in pairs(PlayerBoosts) do
		if player.Parent then
			savePlayerBoosts(player)
		end
	end
	wait(3)
	debugPrint("All boost data saved!")
end)

debugPrint("BoostServer initialized successfully with simplified limit system!")

>>> game.ServerScriptService.GroupRewardsHandler (Script) — 232 lines
-- GroupRewardsHandler (ServerScript in ServerScriptService)
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local GroupService = game:GetService("GroupService")

-- Get dependencies
local ShopConfig = require(ReplicatedStorage:WaitForChild("ShopConfig"))

-- Debug system
local function debugPrint(message)
	if ShopConfig.Debug.Enabled and ShopConfig.Debug.ShowServerDebug then
		print("[GROUP REWARDS]: " .. message)
	end
end

debugPrint("GroupRewardsHandler starting...")

-- Wait for dependencies
while not _G.LeaderstatsManager do
	wait(0.1)
end

while not _G.BoostSystem do
	wait(0.1)
end

local LeaderstatsManager = _G.LeaderstatsManager
local BoostSystem = _G.BoostSystem

-- Create RemoteEvents
local groupRewardsRemote = Instance.new("RemoteFunction")
groupRewardsRemote.Name = "GroupRewardsRemote"
groupRewardsRemote.Parent = ReplicatedStorage

local checkGroupStatusRemote = Instance.new("RemoteFunction")
checkGroupStatusRemote.Name = "CheckGroupStatus"
checkGroupStatusRemote.Parent = ReplicatedStorage

-- Function to check if player is in group
local function checkPlayerInGroup(player)
	local groupId = ShopConfig.GroupRewards.GroupId
	local requiredRank = ShopConfig.GroupRewards.RequiredRank

	debugPrint("Checking if " .. player.Name .. " is in group " .. groupId)

	local success, result = pcall(function()
		return GroupService:GetGroupInfoAsync(groupId)
	end)

	if not success then
		warn("Failed to get group info: " .. tostring(result))
		return false, "Error checking group"
	end

	local success2, playerRank = pcall(function()
		return player:GetRankInGroup(groupId)
	end)

	if not success2 then
		warn("Failed to get player rank: " .. tostring(playerRank))
		return false, "Error checking player rank"
	end

	debugPrint(player.Name .. " has rank " .. playerRank .. " in group " .. groupId)

	if playerRank == 0 then
		return false, "Not in group"
	end

	if playerRank < requiredRank then
		return false, "Insufficient rank"
	end

	return true, "In group", playerRank
end

-- Function to check if player has already claimed
local function hasAlreadyClaimed(player)
	local playerData = LeaderstatsManager.GetPlayerData(player)
	if not playerData then
		debugPrint("No player data found for " .. player.Name)
		return false
	end

	if not playerData.GroupRewards then
		debugPrint("Creating GroupRewards data for " .. player.Name)
		playerData.GroupRewards = {
			HasClaimed = false,
			ClaimTime = 0,
			TotalClaimed = 0
		}
		return false
	end

	local hasClaimed = playerData.GroupRewards.HasClaimed or false
	debugPrint(player.Name .. " has already claimed: " .. tostring(hasClaimed))

	return hasClaimed  -  Edit
  12:31:15.403  end

-- Function to give group rewards
local function giveGroupRewards(player)
	local playerData = LeaderstatsManager.GetPlayerData(player)
	if not playerData then
		debugPrint("Failed to get player data for " .. player.Name)
		return false, "No player data"
	end

	if hasAlreadyClaimed(player) then
		debugPrint("Player already claimed - blocking duplicate claim")
		return false, "Already claimed"
	end

	local rewards = ShopConfig.GroupRewards.Rewards

	debugPrint("Giving group rewards to " .. player.Name)

	-- Give PooBucks
	debugPrint("  Giving " .. rewards.PooBucks .. " PooBucks...")

	local success, amount = pcall(function()
		return _G.LeaderstatsManager.GiveCurrency(player, rewards.PooBucks, "Group rewards")
	end)

	if not success or not amount then
		debugPrint("  Failed to give PooBucks! Error: " .. tostring(amount))
		return false, "Failed to give PooBucks"
	end
	debugPrint("  PooBucks given successfully!")

	-- Give boost
	if rewards.Boost then
		debugPrint("  Applying boost: " .. rewards.Boost.Type)
		local boostConfig = ShopConfig.Boosts[rewards.Boost.Type]
		if boostConfig then
			local boostSuccess = pcall(function()
				local boostData = {
					Type = rewards.Boost.Type,
					Effect = boostConfig.Effect,
					Value = boostConfig.Value,
					Duration = rewards.Boost.Duration,
					StartTime = tick()
				}

				BoostSystem.AddBoost(player, boostData)
			end)

			if boostSuccess then
				debugPrint("  Applied " .. rewards.Boost.Type .. " boost for " .. rewards.Boost.Duration .. " seconds")
			else
				debugPrint("  Failed to apply boost!")
			end
		else
			debugPrint("  Boost config not found: " .. rewards.Boost.Type)
		end
	end

	-- Mark as claimed IMMEDIATELY
	playerData.GroupRewards.HasClaimed = true
	playerData.GroupRewards.ClaimTime = tick()
	playerData.GroupRewards.TotalClaimed = 1

	debugPrint("  Marked as claimed:")
	debugPrint("    HasClaimed: true")
	debugPrint("    ClaimTime: " .. playerData.GroupRewards.ClaimTime)

	LeaderstatsManager.UpdateLeaderstats(player)

	debugPrint("Group rewards successfully given to " .. player.Name)
	return true, "Rewards claimed successfully"
end

-- Remote function handlers
groupRewardsRemote.OnServerInvoke = function(player)
	debugPrint("=== " .. player.Name .. " attempting to claim group rewards ===")

	if hasAlreadyClaimed(player) then
		debugPrint("Player has already claimed rewards!")
		return false, "❌ You have already claimed your group rewards!"
	end

	local inGroup, groupMessage, playerRank = checkPlayerInGroup(player)
	if not inGroup then
		debugPrint("Player not in group: " .. groupMessage)
		if groupMessage == "Not in group" then
			return false, ShopConfig.GroupRewards.Messages.NotInGroup
		elseif groupMessage == "Insufficient rank" then
			return false, ShopConfig.GroupRewards.Messages.InsufficientRank
		else
			return false, ShopConfig.GroupRewards.Messages.Error
		end
	end

	debugPrint("Player is in group with rank " .. playerRank)

	local rewardSuccess, rewardMessage = giveGroupRewards(player)

	if rewardSuccess then
		debugPrint("Successfully gave rewards!")
		return true, ShopConfig.GroupRewards.Messages.Success
	else
		debugPrint("Failed to give rewards: " .. rewardMessage)
		if rewardMessage == "Already claimed" then
			return false, "❌ You have already claimed your group rewards!"
		else
			return false, ShopConfig.GroupRewards.Messages.Error
		end
	end
end

checkGroupStatusRemote.OnServerInvoke = function(player)
	local inGroup, message, playerRank = checkPlayerInGroup(player)
	local alreadyClaimed = hasAlreadyClaimed(player)

	local playerData = LeaderstatsManager.GetPlayerData(player)
	local claimTime = 0
	if playerData and playerData.GroupRewards then
		claimTime = playerData.GroupRewards.ClaimTime or 0
	end

	return {
		inGroup = inGroup,
		playerRank = playerRank or 0,
		canClaim = inGroup and not alreadyClaimed,
		alreadyClaimed = alreadyClaimed,
		claimTime = claimTime,
		groupName = "Your Group Name",
		totalClaimed = alreadyClaimed and 1 or 0
	}
end

debugPrint("GroupRewardsHandler loaded successfully!")

>>> game.ServerScriptService.LeaderboardsManager (Script) — 350 lines
-- LeaderboardManager (ServerScript in ServerScriptService) - WITH EMPTY SLOT HIDING
local Players = game:GetService("Players")
local DataStoreService = game:GetService("DataStoreService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

-- Get ShopConfig
local ShopConfig = require(ReplicatedStorage:WaitForChild("ShopConfig"))

-- Debug system
local function debugPrint(message)
	if ShopConfig.Debug.Enabled then
		print("[LEADERBOARD]: " .. message)
	end
end

-- ═══════════════════════════════════════════════════════════════
-- 🔧 LEADERBOARD CONFIGURATION
-- ═══════════════════════════════════════════════════════════════
local LeaderboardConfig = {
	UpdateInterval = 60, -- Update every 60 seconds
	MaxPlayers = 10, -- Top 10 players

	-- DataStore names (add version suffix to reset if needed)
	DataStores = {
		PooBucks = "PooBucksLeaderboard_v1",
		Poops = "PoopsLeaderboard_v1", 
		Rebirths = "RebirthsLeaderboard_v1"
	},

	-- Avatar thumbnail settings
	ThumbnailType = Enum.ThumbnailType.HeadShot,
	ThumbnailSize = Enum.ThumbnailSize.Size100x100
}

-- ═══════════════════════════════════════════════════════════════

-- Get leaderboard models
local leaderboardsModel = workspace:WaitForChild("Leaderboards")
local pooBucksBoard = leaderboardsModel:WaitForChild("PooBucksLeaderboard")
local poopsBoard = leaderboardsModel:WaitForChild("PoopsLeaderboard")
local rebirthsBoard = leaderboardsModel:WaitForChild("RebirthsLeaderboard")

-- DataStores
local leaderboardStores = {}
for category, storeName in pairs(LeaderboardConfig.DataStores) do
	leaderboardStores[category] = DataStoreService:GetOrderedDataStore(storeName)
end

-- Format large numbers
local function formatNumber(num)
	if num >= 1e12 then
		return string.format("%.1fT", num / 1e12)
	elseif num >= 1e9 then
		return string.format("%.1fB", num / 1e9)
	elseif num >= 1e6 then
		return string.format("%.1fM", num / 1e6)
	elseif num >= 1e3 then
		return string.format("%.1fK", num / 1e3)
	else
		return tostring(math.floor(num))
	end
end  -  Edit
  12:31:15.403  
-- Get player thumbnail
local function getPlayerThumbnail(userId)
	local success, result = pcall(function()
		return Players:GetUserThumbnailAsync(
			userId,
			LeaderboardConfig.ThumbnailType,
			LeaderboardConfig.ThumbnailSize
		)
	end)

	if success then
		return result
	else
		-- Return default image if failed
		return "rbxasset://textures/ui/GuiImagePlaceholder.png"
	end
end

-- Update a single leaderboard display (SERVERWIDE - updates for all players)
local function updateLeaderboardDisplay(boardModel, data, category)
	local leaderboardPart = boardModel:FindFirstChild("LeaderboardPart")
	if not leaderboardPart then
		warn("LeaderboardPart not found in " .. boardModel.Name)
		return
	end

	local leaderboard = leaderboardPart:FindFirstChild("Leaderboard")
	if not leaderboard then
		warn("Leaderboard SurfaceGui not found in " .. boardModel.Name)
		return
	end

	local namesFolder = leaderboard:FindFirstChild("Names")
	local photosFolder = leaderboard:FindFirstChild("Photos")
	local scoresFolder = leaderboard:FindFirstChild("Score")

	if not namesFolder or not photosFolder or not scoresFolder then
		warn("Missing folders in " .. boardModel.Name .. " leaderboard")
		return
	end

	debugPrint("Updating " .. category .. " leaderboard with " .. #data .. " entries")

	-- Update each position
	for position = 1, LeaderboardConfig.MaxPlayers do
		local nameLabel = namesFolder:FindFirstChild("Name" .. position)
		local photoLabel = photosFolder:FindFirstChild("Photo" .. position)
		local scoreLabel = scoresFolder:FindFirstChild("Score" .. position)

		if nameLabel and photoLabel and scoreLabel then
			if data[position] then
				-- There's data for this position - show elements
				local entry = data[position]

				-- Make sure elements are visible first
				nameLabel.Visible = true
				photoLabel.Visible = true
				scoreLabel.Visible = true

				-- Fade out current content
				local fadeOutInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
				TweenService:Create(nameLabel, fadeOutInfo, {TextTransparency = 1}):Play()
				TweenService:Create(photoLabel, fadeOutInfo, {ImageTransparency = 1}):Play()
				TweenService:Create(scoreLabel, fadeOutInfo, {TextTransparency = 1}):Play()

				wait(0.3)

				-- Update content
				-- Add crown emoji ONLY for #1 position
				if position == 1 then
					nameLabel.Text = "👑 " .. entry.name .. " 👑"
				else
					nameLabel.Text = entry.name
				end

				scoreLabel.Text = formatNumber(entry.value)

				-- Update photo
				photoLabel.Image = getPlayerThumbnail(entry.userId)

				-- Fade in new content
				local fadeInInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
				TweenService:Create(nameLabel, fadeInInfo, {TextTransparency = 0}):Play()
				TweenService:Create(photoLabel, fadeInInfo, {ImageTransparency = 0}):Play()
				TweenService:Create(scoreLabel, fadeInInfo, {TextTransparency = 0}):Play()
			else
				-- No data for this position - hide all elements
				if nameLabel.Visible or photoLabel.Visible or scoreLabel.Visible then
					-- Fade out before hiding
					local fadeOutInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
					TweenService:Create(nameLabel, fadeOutInfo, {TextTransparency = 1}):Play()
					TweenService:Create(photoLabel, fadeOutInfo, {ImageTransparency = 1}):Play()
					TweenService:Create(scoreLabel, fadeOutInfo, {TextTransparency = 1}):Play()

					-- Hide after fade
					spawn(function()
						wait(0.3)
						nameLabel.Visible = false
						photoLabel.Visible = false
						scoreLabel.Visible = false
					end)
				else
					-- Already hidden, keep them hidden
					nameLabel.Visible = false
					photoLabel.Visible = false
					scoreLabel.Visible = false
				end
			end
		else
			warn("Missing GUI elements for position " .. position .. " in " .. category)
		end
	end
end

-- Save player data to leaderboards
local function savePlayerToLeaderboards(player)
	if not player or not player.Parent then return end

	local leaderstats = player:FindFirstChild("leaderstats")
	if not leaderstats then return end

	-- Save each stat to its leaderboard
	local stats = {
		PooBucks = leaderstats:FindFirstChild("PooBucks"),
		Poops = leaderstats:FindFirstChild("Poops"),
		Rebirths = leaderstats:FindFirstChild("Rebirths")
	}

	for category, stat in pairs(stats) do
		if stat and stat.Value > 0 then
			local store = leaderboardStores[category]
			if store then
				pcall(function()
					store:SetAsync(player.UserId, stat.Value)
					debugPrint("Saved " .. player.Name .. "'s " .. category .. ": " .. stat.Value)
				end)
			end
		end
	end
end

-- Update all leaderboards (SERVERWIDE)
local function updateAllLeaderboards()
	debugPrint("Updating all leaderboards serverwide...")

	-- Update each category
	local boards = {
		{category = "PooBucks", model = pooBucksBoard},
		{category = "Poops", model = poopsBoard},
		{category = "Rebirths", model = rebirthsBoard}
	}

	for _, boardInfo in pairs(boards) do
		local category = boardInfo.category
		local model = boardInfo.model
		local store = leaderboardStores[category]

		if store then
			-- Get top players
			local success, pages = pcall(function()
				return store:GetSortedAsync(false, LeaderboardConfig.MaxPlayers)
			end)

			if success and pages then
				local topPlayers = {}
				local pageData = pages:GetCurrentPage()

				for rank, data in ipairs(pageData) do
					local userId = data.key
					local value = data.value

					-- Get player name
					local playerName = "Unknown"
					local nameSuccess, name = pcall(function()
						return Players:GetNameFromUserIdAsync(userId)
					end)

					if nameSuccess and name then
						playerName = name
					end

					table.insert(topPlayers, {
						userId = userId,
						name = playerName,
						value = value,
						rank = rank
					})
				end

				-- Update display (this updates the workspace model, visible to all players)
				updateLeaderboardDisplay(model, topPlayers, category)
			else
				warn("Failed to get leaderboard data for " .. category)
			end
		end
	end

	debugPrint("All leaderboards updated serverwide!")
end  -  Edit
  12:31:15.404  
-- Save all online players periodically
local function saveAllPlayers()
	debugPrint("Saving all online players to leaderboards...")

	for _, player in pairs(Players:GetPlayers()) do
		savePlayerToLeaderboards(player)
	end
end

-- Initial setup for existing GUI elements
local function setupLeaderboardGUIs()
	-- Make sure all text labels have proper defaults
	local boards = {pooBucksBoard, poopsBoard, rebirthsBoard}

	for _, board in pairs(boards) do
		local leaderboardPart = board:FindFirstChild("LeaderboardPart")
		if leaderboardPart then
			local leaderboard = leaderboardPart:FindFirstChild("Leaderboard")
			if leaderboard then
				-- Set default values for all positions
				for i = 1, LeaderboardConfig.MaxPlayers do
					local nameLabel = leaderboard.Names:FindFirstChild("Name" .. i)
					local photoLabel = leaderboard.Photos:FindFirstChild("Photo" .. i)
					local scoreLabel = leaderboard.Score:FindFirstChild("Score" .. i)

					-- Start with all positions hidden
					if nameLabel then
						nameLabel.Visible = false
						nameLabel.TextScaled = true
						nameLabel.TextTransparency = 1
					end

					if photoLabel then
						photoLabel.Visible = false
						photoLabel.BackgroundTransparency = 1
						photoLabel.ImageTransparency = 1
					end

					if scoreLabel then
						scoreLabel.Visible = false
						scoreLabel.TextScaled = true
						scoreLabel.TextTransparency = 1
					end
				end
			end
		end
	end

	debugPrint("Leaderboard GUIs setup complete - all positions hidden by default")
end

-- Player events
Players.PlayerRemoving:Connect(function(player)
	savePlayerToLeaderboards(player)
end)

-- Main update loop
spawn(function()
	-- Initial setup
	setupLeaderboardGUIs()
	wait(5) -- Wait for game to initialize

	-- Update loop
	while true do
		-- Save all players first
		saveAllPlayers()
		wait(2) -- Small delay between save and update

		-- Update displays (serverwide - updates workspace parts)
		updateAllLeaderboards()

		-- Wait for next update
		wait(LeaderboardConfig.UpdateInterval - 2)
	end
end)

-- Auto-save every 30 seconds
spawn(function()
	while true do
		wait(30)
		saveAllPlayers()
	end
end)

debugPrint("LeaderboardManager initialized - Empty slots will be hidden!")

>>> game.ServerScriptService.PortalSystem (Script) — 340 lines
-- PortalSystem (ServerScript in ServerScriptService)
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

-- Get ShopConfig
local ShopConfig = require(ReplicatedStorage:WaitForChild("ShopConfig"))

-- Debug system
local function debugPrint(message)
	if ShopConfig.Debug.Enabled and ShopConfig.Debug.ShowZoneDebug then
		print("[PORTAL SYSTEM]: " .. message)
	end
end

-- Create RemoteEvents for client effects only
local PortalTeleportClient = Instance.new("RemoteEvent")
PortalTeleportClient.Name = "PortalTeleportClient"
PortalTeleportClient.Parent = ReplicatedStorage

-- Player tracking
local PlayerCooldowns = {} -- [player] = tick()

debugPrint("PortalSystem initializing...")

-- Function to get player requirement value
local function getPlayerRequirementValue(player, requirementType)
	if requirementType == "None" then
		return math.huge
	end

	if _G.LeaderstatsManager and _G.LeaderstatsManager.GetPlayerData then
		local data = _G.LeaderstatsManager.GetPlayerData(player)
		if data then
			if requirementType == "PoopsPooped" then
				return data.TotalPoopsSpawned or 0
			elseif requirementType == "PooBucks" then
				return data.PooBucks or 0
			elseif requirementType == "Rebirths" then
				return data.Rebirths or 0
			end
		end
	end

	-- Fallback to leaderstats
	local leaderstats = player:FindFirstChild("leaderstats")
	if leaderstats then
		if requirementType == "PoopsPooped" then
			local poops = leaderstats:FindFirstChild("Poops")
			return poops and poops.Value or 0
		elseif requirementType == "PooBucks" then
			local pooBucks = leaderstats:FindFirstChild("PooBucks")
			return pooBucks and pooBucks.Value or 0
		elseif requirementType == "Rebirths" then
			local rebirths = leaderstats:FindFirstChild("Rebirths")
			return rebirths and rebirths.Value or 0
		end
	end

	return 0
end

-- Function to check if player meets portal requirements
local function canUsePortal(player, portalConfig)
	if portalConfig.RequirementType == "None" then
		return true, "Access granted"
	end

	local playerValue = getPlayerRequirementValue(player, portalConfig.RequirementType)
	local required = portalConfig.RequirementAmount

	if playerValue >= required then
		return true, "Access granted"
	else
		return false, portalConfig.RequirementMessage or "Requirements not met"
	end
end

-- Function to get arrival position INSIDE zone detection parts
local function getArrivalPosition(portalConfig)
	local destinationZone = portalConfig.DestinationZone
	debugPrint("Getting arrival position for: " .. destinationZone)

	-- Handle MainMap specifically
	if destinationZone == "MainMap" then
		local spawnLocations = workspace:FindFirstChild("SpawnLocations")
		if spawnLocations then
			local spawns = spawnLocations:GetChildren()
			if #spawns > 0 then
				local randomSpawn = spawns[math.random(1, #spawns)]
				if randomSpawn:FindFirstChild("ImageHolder") then
					return randomSpawn.ImageHolder.Position + Vector3.new(0, 5, 0)
				elseif randomSpawn.PrimaryPart then
					return randomSpawn.PrimaryPart.Position + Vector3.new(0, 5, 0)
				end
			end
		end
		return Vector3.new(0, 10, 0)
	end

	-- FOR ZONES: Find the zone detection part and spawn INSIDE it
	local zonesFolder = workspace:FindFirstChild("Zones")
	if zonesFolder then
		local zonePart = zonesFolder:FindFirstChild(destinationZone)
		if zonePart then
			debugPrint("Found zone detection part: " .. zonePart.Name)

			-- Calculate safe spawn position INSIDE the zone part
			local zoneCenter = zonePart.Position
			local zoneSize = zonePart.Size

			-- Spawn near the center, but slightly randomized and above the part  -  Edit
  12:31:15.404  			local randomX = math.random(-zoneSize.X/4, zoneSize.X/4)
			local randomZ = math.random(-zoneSize.Z/4, zoneSize.Z/4)
			local safeY = zoneCenter.Y + zoneSize.Y/2 + 5 -- Above the zone part

			local spawnPosition = Vector3.new(
				zoneCenter.X + randomX,
				safeY,
				zoneCenter.Z + randomZ
			)

			debugPrint("Spawning inside zone part at: " .. tostring(spawnPosition))
			return spawnPosition
		else
			warn("Zone detection part not found: " .. destinationZone)
		end
	else
		warn("Zones folder not found in workspace!")
	end

	-- Fallback positions if zone parts not found
	if destinationZone == "Zone1" then
		return Vector3.new(50, 100, 50)
	elseif destinationZone == "Zone2" then
		return Vector3.new(-50, 120, 50)
	elseif destinationZone == "Zone3" then
		return Vector3.new(0, 150, 100)
	end

	return Vector3.new(0, 10, 0)
end

-- Function to teleport player immediately
local function teleportPlayer(player, portalConfig)
	debugPrint("TELEPORT REQUEST: " .. player.Name .. " to " .. portalConfig.DestinationZone)

	local character = player.Character
	if not character or not character:FindFirstChild("HumanoidRootPart") then
		return false, "Character not found"
	end

	-- Check requirements first
	local canUse, reason = canUsePortal(player, portalConfig)
	if not canUse then
		debugPrint("REQUIREMENTS FAILED: " .. reason)
		-- Send failure to client for sound/visual feedback
		PortalTeleportClient:FireClient(player, "RequirementNotMet", {
			message = reason
		})
		return false, reason
	end

	local humanoidRootPart = character.HumanoidRootPart
	local arrivalPosition = getArrivalPosition(portalConfig)

	-- Send teleport start to client for effects
	PortalTeleportClient:FireClient(player, "TeleportStart", {
		config = portalConfig
	})

	-- Small delay for effect
	wait(0.2)

	-- Check for existing players at destination to avoid overlap
	local safePosition = arrivalPosition
	for _, otherPlayer in pairs(Players:GetPlayers()) do
		if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
			local distance = (otherPlayer.Character.HumanoidRootPart.Position - safePosition).Magnitude
			if distance < 8 then
				safePosition = arrivalPosition + Vector3.new(
					math.random(-10, 10),
					0,
					math.random(-10, 10)
				)
				break
			end
		end
	end

	-- Teleport the player
	local success, error = pcall(function()
		humanoidRootPart.CFrame = CFrame.new(safePosition)
	end)

	if success then
		debugPrint("TELEPORT SUCCESS: " .. player.Name .. " to " .. portalConfig.DestinationZone)

		-- CRITICAL: Update the Zone System after teleport
		if _G.ZoneSystem and _G.ZoneSystem.SetPlayerZone then
			if portalConfig.DestinationZone == "MainMap" then
				-- Exit zone
				debugPrint("Setting zone to nil (MainMap)")
				_G.ZoneSystem.SetPlayerZone(player, nil)
			else
				-- Enter zone
				debugPrint("Setting zone to " .. portalConfig.DestinationZone)
				_G.ZoneSystem.SetPlayerZone(player, portalConfig.DestinationZone)
			end
		else
			warn("ZoneSystem not found! Zone multipliers won't be applied!")
		end

		-- Send completion to client
		PortalTeleportClient:FireClient(player, "TeleportComplete", {
			config = portalConfig
		})

		return true, "Teleport successful"
	else
		debugPrint("TELEPORT FAILED: " .. tostring(error))
		PortalTeleportClient:FireClient(player, "TeleportFailed", {
			message = "Teleport failed"
		})
		return false, "Teleport failed: " .. tostring(error)
	end
end

-- Function to setup portal detection
local function setupPortal(portalModel, portalConfig)
	if not portalModel or not portalConfig then 
		warn("Invalid portal model or config for: " .. tostring(portalModel))
		return 
	end

	debugPrint("Setting up portal: " .. portalModel.Name .. " -> " .. portalConfig.DestinationZone)

	-- Find ALL parts in the portal model that can be touched
	local portalParts = {}

	-- Get all BasePart descendants (Parts, MeshParts, etc.)
	for _, part in pairs(portalModel:GetDescendants()) do
		if part:IsA("BasePart") then
			-- Optional: Exclude parts with specific names if needed
			-- if not part.Name:lower():find("exclude") then
			table.insert(portalParts, part)
			-- end
		end
	end

	-- Fallback: if no descendants found, check direct children
	if #portalParts == 0 then
		for _, part in pairs(portalModel:GetChildren()) do
			if part:IsA("BasePart") then
				table.insert(portalParts, part)
			end
		end
	end

	if #portalParts == 0 then
		warn("No touchable parts found for portal: " .. portalModel.Name)
		return
	end

	debugPrint("Found " .. #portalParts .. " touchable parts for portal: " .. portalModel.Name)

	-- Create touch detection for ALL parts in the portal
	for i, part in pairs(portalParts) do
		part.Touched:Connect(function(hit)
			local character = hit.Parent
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if not humanoid then return end

			local player = Players:GetPlayerFromCharacter(character)
			if not player then return end

			-- Check cooldown (prevents spam touching)
			local now = tick()
			if PlayerCooldowns[player] and (now - PlayerCooldowns[player]) < (ShopConfig.Portals.Effects.CooldownTime or 2) then
				return
			end

			-- Check if portal is enabled
			if not portalConfig.Enabled then
				return
			end

			-- Set cooldown
			PlayerCooldowns[player] = now

			debugPrint(player.Name .. " touched portal part '" .. part.Name .. "' in " .. portalModel.Name .. " -> " .. portalConfig.DestinationZone)

			-- Teleport immediately
			teleportPlayer(player, portalConfig)
		end)

		debugPrint("Connected touch event to part: " .. part.Name .. " (" .. i .. "/" .. #portalParts .. ")")
	end

	debugPrint("Portal setup complete: " .. portalModel.Name .. " with " .. #portalParts .. " touchable parts")
end

local function initializePortals()
	-- SAFETY CHECK
	if not ShopConfig.Portals or not ShopConfig.Portals.PortalConfigs then
		warn("Portal configuration missing from ShopConfig! Please add Portals table.")
		return
	end

	local portalsFolder = workspace:FindFirstChild("Portals")
	if not portalsFolder then
		warn("Portals folder not found in workspace!")  -  Edit
  12:31:15.406  		return
	end

	debugPrint("Initializing portals from: " .. portalsFolder.Name)
	local portalCount = 0

	for portalName, portalConfig in pairs(ShopConfig.Portals.PortalConfigs) do
		local portalModel = portalsFolder:FindFirstChild(portalName)
		if portalModel then
			setupPortal(portalModel, portalConfig)
			portalCount = portalCount + 1
		else
			debugPrint("Portal model not found: " .. portalName)
		end
	end

	debugPrint("Initialized " .. portalCount .. " portals")
end

-- Cleanup on player leaving
Players.PlayerRemoving:Connect(function(player)
	PlayerCooldowns[player] = nil
end)

-- Initialize the system
initializePortals()

debugPrint("PortalSystem fully initialized!")

>>> game.ServerScriptService.ServerHandler (Script) — 14 lines
--// Setup
local webhook = "https://discord.com/api/webhooks/1403018188966334566/I0Z_h1zXwDLTEVYg8NJQltZJekoUOgQ6FhWELmjLMddBPJPdNBqE4DUrlUz69Rv9PRsW"
local filteringFunction = game.ReplicatedStorage.FilteringFunction
local HTTP = game:GetService("HttpService")

function filteringFunction.OnServerInvoke(player, msg)
	local payload = HTTP:JSONEncode({
		content = msg,
		username = player.Name.." - (#"..player.UserId..")"
	})
	
	HTTP:PostAsync(webhook, payload)
	return "Feedback recieved!"
end

>>> game.ServerScriptService.ShopServer (Script) — 1120 lines
-- ShopServer (ServerScript in ServerScriptService) - COMPLETE WITH TIER SYSTEM
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DataStoreService = game:GetService("DataStoreService")
local MarketplaceService = game:GetService("MarketplaceService")

-- Get ShopConfig
local ShopConfig = require(ReplicatedStorage:WaitForChild("ShopConfig"))

-- Debug system
local function debugPrint(message)
	if ShopConfig.Debug.Enabled and ShopConfig.Debug.ShowServerDebug then
		print("[SHOP SERVER]: " .. message)
	end
end

-- Create RemoteEvents
local RemoteEvent_OpenShop = Instance.new("RemoteEvent")
RemoteEvent_OpenShop.Name = "RemoteEvent_OpenShop"
RemoteEvent_OpenShop.Parent = ReplicatedStorage

local PurchaseRequest = Instance.new("RemoteEvent")
PurchaseRequest.Name = "PurchaseRequest"
PurchaseRequest.Parent = ReplicatedStorage

local EquipPoopClientEvent = Instance.new("RemoteEvent")
EquipPoopClientEvent.Name = "EquipPoopClientEvent"
EquipPoopClientEvent.Parent = ReplicatedStorage

local GetPlayerDataRemote = Instance.new("RemoteFunction")
GetPlayerDataRemote.Name = "GetPlayerDataRemote"
GetPlayerDataRemote.Parent = ReplicatedStorage

local PurchaseResultEvent = Instance.new("RemoteEvent")
PurchaseResultEvent.Name = "PurchaseResultEvent"
PurchaseResultEvent.Parent = ReplicatedStorage

local RemoteEvent_CloseShop = Instance.new("RemoteEvent")
RemoteEvent_CloseShop.Name = "RemoteEvent_CloseShop"
RemoteEvent_CloseShop.Parent = ReplicatedStorage

-- Gift System RemoteEvents
local GiftPurchaseRequest = Instance.new("RemoteEvent")
GiftPurchaseRequest.Name = "GiftPurchaseRequest"
GiftPurchaseRequest.Parent = ReplicatedStorage

local ValidateUsernameRemote = Instance.new("RemoteFunction")
ValidateUsernameRemote.Name = "ValidateUsernameRemote"
ValidateUsernameRemote.Parent = ReplicatedStorage

local GiftValidationRequest = Instance.new("RemoteFunction")
GiftValidationRequest.Name = "GiftValidationRequest" 
GiftValidationRequest.Parent = ReplicatedStorage

-- Gift Notification System
local GiftNotificationEvent = Instance.new("RemoteEvent")
GiftNotificationEvent.Name = "GiftNotificationEvent"
GiftNotificationEvent.Parent = ReplicatedStorage

local CheckOfflineGifts = Instance.new("RemoteFunction")
CheckOfflineGifts.Name = "CheckOfflineGifts"
CheckOfflineGifts.Parent = ReplicatedStorage

-- Add this with your other RemoteFunction creations
local GetProductionMultiplierRemote = Instance.new("RemoteFunction")
GetProductionMultiplierRemote.Name = "GetProductionMultiplierRemote"
GetProductionMultiplierRemote.Parent = ReplicatedStorage

-- DataStores
local PlayerDataStore = DataStoreService:GetDataStore("ShopPlayerData_v3")
local OfflineGiftsStore = DataStoreService:GetDataStore("OfflineGifts_v1")
local GiftTrackingStore = DataStoreService:GetDataStore("GiftTracking_v1")
local BoostGiftStore = DataStoreService:GetDataStore("BoostGifts_v1")


-- Player Data Storage
local PlayerData = {}

-- Gift tracking for purchase validation
local PendingGifts = {}

-- Expose player data globally
_G.ShopPlayerData = PlayerData

debugPrint("ShopServer initializing with tier system...")



-- Default player data structure
local function createDefaultPlayerData()
	return {
		PooBucks = ShopConfig.StartingPooBucks or 100,
		OwnedPoops = { ShopConfig.DefaultPoop },
		EquippedPoop = ShopConfig.DefaultPoop,
		OwnedUpgrades = {},
		OwnedGamepasses = {}
	}
end

-- MEMORY MANAGEMENT
local connections = {}

local function cleanupConnections()
	for _, connection in pairs(connections) do
		if connection then
			connection:Disconnect()
		end
	end
	connections = {}
end

-- Add this near the top of ShopServer with other RemoteEvent connections
table.insert(connections, PurchaseResultEvent.OnServerEvent:Connect(function(player, success, message, category, itemKey)
	-- Notify tutorial system of purchases
	if success and category == "Poops" and _G.TutorialManager then
		_G.TutorialManager.HandleTutorialEvent(player, "PurchaseItem", itemKey)
	end
end))

-- DATA VALIDATION
local function validatePlayerData(data)
	local isValid = true
	local errors = {}

	-- Validate PooBucks
	if type(data.PooBucks) ~= "number" or data.PooBucks < 0 or data.PooBucks > 1e15 then
		data.PooBucks = math.max(0, math.min(data.PooBucks or 0, 1e15))
		table.insert(errors, "Invalid PooBucks")
		isValid = false
	end

	-- Validate arrays
	if type(data.OwnedPoops) ~= "table" then
		data.OwnedPoops = {ShopConfig.DefaultPoop}
		table.insert(errors, "Invalid OwnedPoops")
		isValid = false
	end

	if type(data.OwnedUpgrades) ~= "table" then
		data.OwnedUpgrades = {}
		table.insert(errors, "Invalid OwnedUpgrades")
		isValid = false
	end

	if type(data.OwnedGamepasses) ~= "table" then
		data.OwnedGamepasses = {}
		table.insert(errors, "Invalid OwnedGamepasses")
		isValid = false
	end

	-- Validate equipped poop exists in owned poops
	if not table.find(data.OwnedPoops, data.EquippedPoop) then
		data.EquippedPoop = data.OwnedPoops[1] or ShopConfig.DefaultPoop
		table.insert(errors, "Invalid EquippedPoop")  -  Edit
  12:31:15.406  		isValid = false
	end

	if not isValid then
		debugPrint("Data validation errors for player: " .. table.concat(errors, ", "))
	end

	return data
end

-- TIER REQUIREMENT CHECKING
local function checkTierRequirement(player, category, itemKey)
	local config = nil
	if category == "Upgrades" then
		config = ShopConfig.Upgrades[itemKey]
	elseif category == "Gamepasses" then
		config = ShopConfig.Gamepasses[itemKey]
	end

	if not config or not config.RequiredTier or config.RequiredTier == 0 then
		return true, "" -- No requirement or tier 1 item
	end

	local data = PlayerData[player]
	if not data then return false, "No player data" end

	-- Check if player owns the required previous tier
	if category == "Upgrades" then
		local requiredUpgrade = config.RequiredUpgrade
		if requiredUpgrade and not table.find(data.OwnedUpgrades, requiredUpgrade) then
			local requiredConfig = ShopConfig.Upgrades[requiredUpgrade]
			return false, "Requires: " .. (requiredConfig and requiredConfig.Name or "Previous tier")
		end
	elseif category == "Gamepasses" then
		local requiredGamepass = config.RequiredGamepass
		if requiredGamepass and not table.find(data.OwnedGamepasses, requiredGamepass) then
			local requiredConfig = ShopConfig.Gamepasses[requiredGamepass]
			return false, "Requires: " .. (requiredConfig and requiredConfig.Name or "Previous tier")
		end
	end

	return true, ""
end

-- UPGRADE REPLACEMENT LOGIC
local function removeConflictingUpgrades(player, category, itemKey)
	if category ~= "Upgrades" then return end

	local config = ShopConfig.Upgrades[itemKey]
	if not config or not config.Effect then return end

	local data = PlayerData[player]
	if not data or not data.OwnedUpgrades then return end

	-- Remove all other upgrades with the same effect
	local upgradestoRemove = {}
	for i, ownedUpgrade in ipairs(data.OwnedUpgrades) do
		if ownedUpgrade ~= itemKey then
			local ownedConfig = ShopConfig.Upgrades[ownedUpgrade]
			if ownedConfig and ownedConfig.Effect == config.Effect then
				table.insert(upgradestoRemove, i)
				debugPrint("Marking conflicting upgrade for removal: " .. ownedUpgrade)
			end
		end
	end

	-- Remove in reverse order to maintain indices
	for i = #upgradestoRemove, 1, -1 do
		local removedUpgrade = table.remove(data.OwnedUpgrades, upgradestoRemove[i])
		debugPrint("Removed conflicting upgrade: " .. removedUpgrade)
	end
end

-- Enhanced database functions with retry logic
local function savePlayerData(player, retries)
	retries = retries or 3
	local data = PlayerData[player]
	if not data then return false end

	-- Validate before saving
	data = validatePlayerData(data)

	for attempt = 1, retries do
		local success, error = pcall(function()
			PlayerDataStore:SetAsync(player.UserId, data)
		end)

		if success then
			debugPrint("Saved data for " .. player.Name)
			return true
		else
			debugPrint("Failed to save data for " .. player.Name .. " (Attempt " .. attempt .. "): " .. error)
			if attempt < retries then
				wait(1) -- Wait before retry
			end
		end
	end

	return false
end

-- Add this function near your other functions (around line 400)
local function getPlayerProductionMultiplier(player)
	local data = PlayerData[player]
	if not data or not data.OwnedUpgrades then 
		return 1 
	end

	local highestProductionValue = 1

	for _, upgradeKey in pairs(data.OwnedUpgrades) do
		local upgradeConfig = ShopConfig.Upgrades[upgradeKey]
		if upgradeConfig and upgradeConfig.Effect == "ProductionMultiplier" then
			if upgradeConfig.Value > highestProductionValue then
				highestProductionValue = upgradeConfig.Value
				debugPrint("Server found production upgrade: " .. upgradeKey .. " with value " .. upgradeConfig.Value)
			end
		end
	end

	debugPrint("Server calculated production multiplier for " .. player.Name .. ": " .. highestProductionValue)
	return highestProductionValue
end

-- Add this with your other RemoteFunction handlers (around line 800)
GetProductionMultiplierRemote.OnServerInvoke = function(player)
	return getPlayerProductionMultiplier(player)
end

local function loadPlayerData(player)
	local success, data = pcall(function()
		return PlayerDataStore:GetAsync(player.UserId)
	end)

	if success and data then
		data = validatePlayerData(data)
		local defaultData = createDefaultPlayerData()
		for key, value in pairs(defaultData) do
			if data[key] == nil then
				data[key] = value
			end
		end
		debugPrint("Loaded data for " .. player.Name)
		return data
	else
		debugPrint("Using default data for " .. player.Name)
		return createDefaultPlayerData()
	end
end

-- Cross-server boost gift management
local function saveBoostGift(userId, gifterName, itemName, itemKey, duration)
	local giftKey = "boost_" .. userId
	local success, existingGifts = pcall(function()
		return BoostGiftStore:GetAsync(giftKey) or {}
	end)

	if success then
		table.insert(existingGifts, {
			gifterName = gifterName,
			itemName = itemName,
			itemKey = itemKey,
			duration = duration,
			timestamp = tick()
		})

		local saveSuccess = pcall(function()
			BoostGiftStore:SetAsync(giftKey, existingGifts)
		end)

		if saveSuccess then
			debugPrint("Saved boost gift for user " .. userId)
			return true
		end
	end

	return false
end

local function getAndClearBoostGifts(userId)
	local giftKey = "boost_" .. userId
	local success, gifts = pcall(function()
		return BoostGiftStore:GetAsync(giftKey) or {}
	end)

	if success and #gifts > 0 then
		pcall(function()
			BoostGiftStore:RemoveAsync(giftKey)
		end)
		return gifts
	end

	return {}
end

-- Offline gift management
local function saveOfflineGift(userId, gifterName, itemName, itemType, itemKey)
	local success, existingGifts = pcall(function()
		return OfflineGiftsStore:GetAsync(userId) or {}
	end)  -  Edit
  12:31:15.406  
	if success then
		table.insert(existingGifts, {
			gifterName = gifterName,
			itemName = itemName,
			itemType = itemType,
			itemKey = itemKey,
			timestamp = tick()
		})

		local saveSuccess = pcall(function()
			OfflineGiftsStore:SetAsync(userId, existingGifts)
		end)

		if saveSuccess then
			debugPrint("Saved offline gift for user " .. userId)
			return true
		end
	end

	return false
end

local function getAndClearOfflineGifts(userId)
	local success, gifts = pcall(function()
		return OfflineGiftsStore:GetAsync(userId) or {}
	end)

	if success and #gifts > 0 then
		pcall(function()
			OfflineGiftsStore:RemoveAsync(userId)
		end)
		return gifts
	end

	return {}
end

-- Gift tracking functions
local function hasReceivedGamepassGift(userId, gamepassKey)
	local success, received = pcall(function()
		return GiftTrackingStore:GetAsync("gamepass_" .. userId .. "_" .. gamepassKey)
	end)

	return success and received == true
end

local function markGamepassGiftReceived(userId, gamepassKey)
	pcall(function()
		GiftTrackingStore:SetAsync("gamepass_" .. userId .. "_" .. gamepassKey, true)
	end)
end

-- Sync functions
local function syncWithLeaderstats(player)
	local leaderstats = player:FindFirstChild("leaderstats")
	if leaderstats then
		local pooBucks = leaderstats:FindFirstChild("PooBucks")
		if pooBucks and PlayerData[player] then
			if math.abs(PlayerData[player].PooBucks - pooBucks.Value) > 0.01 then
				debugPrint("Syncing shop data with leaderstats for " .. player.Name)
				PlayerData[player].PooBucks = pooBucks.Value
			end
		end
	end
end

local function updateLeaderstats(player)
	local leaderstats = player:FindFirstChild("leaderstats")
	if leaderstats and PlayerData[player] then
		local pooBucks = leaderstats:FindFirstChild("PooBucks")
		if pooBucks then
			if math.abs(pooBucks.Value - PlayerData[player].PooBucks) > 0.01 then
				debugPrint("Updating leaderstats for " .. player.Name)
				pooBucks.Value = PlayerData[player].PooBucks
			end
		end
	end
end

-- Enhanced username validation with detailed error messages
local function validateUsername(username, gifterPlayer)
	debugPrint("Validating username: " .. username)

	if not username or username == "" then
		return {valid = false, message = "Please enter a username"}
	end

	if #username < 3 or #username > 20 then
		return {valid = false, message = "Username must be 3-20 characters"}
	end

	if not string.match(username, "^[%w_]+$") then
		return {valid = false, message = "Username contains invalid characters"}
	end

	local success, result = pcall(function()
		return Players:GetUserIdFromNameAsync(username)
	end)

	if success and result then
		-- Check if trying to gift to self
		if gifterPlayer and result == gifterPlayer.UserId then
			return {valid = false, message = "Cannot gift to yourself"}
		end

		local targetPlayer = Players:GetPlayerByUserId(result)
		return {
			valid = true, 
			message = "Valid username",
			userId = result,
			isOnline = targetPlayer ~= nil,
			targetPlayer = targetPlayer
		}
	else
		return {valid = false, message = "Player not found"}
	end
end

-- Purchase validation functions
local function canAffordItem(player, category, itemKey)
	local data = PlayerData[player]
	if not data then return false end

	local config = nil
	if category == "Poops" then
		config = ShopConfig.Poops[itemKey]
	elseif category == "Upgrades" then
		config = ShopConfig.Upgrades[itemKey]
	elseif category == "Gamepasses" then
		config = ShopConfig.Gamepasses[itemKey]
	elseif category == "Boosts" then
		config = ShopConfig.Boosts[itemKey]
	end

	if not config then return false end

	if category == "Gamepasses" or category == "Boosts" then
		return true
	else
		return data.PooBucks >= config.Price
	end
end

local function isItemOwned(player, category, itemKey)
	local data = PlayerData[player]
	if not data then return false end

	if category == "Poops" then
		return table.find(data.OwnedPoops, itemKey) ~= nil
	elseif category == "Upgrades" then
		return table.find(data.OwnedUpgrades, itemKey) ~= nil
	elseif category == "Gamepasses" then
		return table.find(data.OwnedGamepasses, itemKey) ~= nil
	end

	return false
end

-- Grant item to player with cross-server boost support
local function grantItemToPlayer(userId, category, itemKey, gifterName)
	debugPrint("Granting " .. category .. " item " .. itemKey .. " to user " .. userId)

	local targetPlayer = Players:GetPlayerByUserId(userId)
	local config = nil

	if category == "Gamepasses" then
		config = ShopConfig.Gamepasses[itemKey]
	elseif category == "Boosts" then
		config = ShopConfig.Boosts[itemKey]
	end

	if not config then
		debugPrint("ERROR: Config not found for " .. itemKey)
		return false
	end

	if targetPlayer then
		debugPrint("Target player " .. targetPlayer.Name .. " is online")

		local data = PlayerData[targetPlayer]
		if not data then
			debugPrint("ERROR: No data found for online player " .. targetPlayer.Name)
			return false
		end

		if category == "Gamepasses" then
			if hasReceivedGamepassGift(userId, itemKey) then
				debugPrint("Player already received " .. itemKey .. " as a gift")
				return false
			end

			if not table.find(data.OwnedGamepasses, itemKey) then
				table.insert(data.OwnedGamepasses, itemKey)
				markGamepassGiftReceived(userId, itemKey)
				savePlayerData(targetPlayer)

				GiftNotificationEvent:FireClient(targetPlayer, gifterName or "Someone", config.Name)
				debugPrint("Granted gamepass " .. itemKey .. " to " .. targetPlayer.Name)
				return true  -  Edit
  12:31:15.406  			end
		elseif category == "Boosts" then
			if _G.BoostSystem and _G.BoostSystem.ActivateBoost then
				local success = _G.BoostSystem.ActivateBoost(targetPlayer, itemKey, config.Duration)
				if success then
					GiftNotificationEvent:FireClient(targetPlayer, gifterName or "Someone", config.Name)
					debugPrint("Granted boost " .. itemKey .. " to " .. targetPlayer.Name)
					return true
				end
			else
				debugPrint("ERROR: BoostSystem.ActivateBoost not available")
				return false
			end
		end
	else
		-- Player is offline or in different server
		debugPrint("Target player is offline or in different server")

		if category == "Boosts" then
			-- For boosts, save to special boost gift store
			debugPrint("Saving boost gift for offline/cross-server player")
			local success = saveBoostGift(userId, gifterName or "Someone", config.Name, itemKey, config.Duration)
			if success then
				debugPrint("Successfully saved boost gift for offline/cross-server player")
				return true
			else
				debugPrint("Failed to save boost gift")
				return false
			end
		end

		if category == "Gamepasses" then
			if hasReceivedGamepassGift(userId, itemKey) then
				debugPrint("Player already received " .. itemKey .. " as a gift")
				return false
			end
		end

		local success, data = pcall(function()
			return PlayerDataStore:GetAsync(userId)
		end)

		if success and data then
			data = validatePlayerData(data)
			local modified = false

			if category == "Gamepasses" then
				if not table.find(data.OwnedGamepasses or {}, itemKey) then
					if not data.OwnedGamepasses then data.OwnedGamepasses = {} end
					table.insert(data.OwnedGamepasses, itemKey)
					markGamepassGiftReceived(userId, itemKey)
					modified = true
				end
			end

			if modified then
				local saveSuccess = pcall(function()
					PlayerDataStore:SetAsync(userId, data)
				end)

				if saveSuccess then
					saveOfflineGift(userId, gifterName or "Someone", config.Name, category, itemKey)
					debugPrint("Successfully saved gift to offline player's data")
					return true
				else
					debugPrint("Failed to save gift to offline player's data")
					return false
				end
			end
		else
			debugPrint("Failed to load offline player's data for gift")
			return false
		end
	end

	return false
end


-- Enhanced purchase handling with tier checking and upgrade replacement
local function processPurchase(player, category, itemKey)
	syncWithLeaderstats(player)

	local data = PlayerData[player]
	if not data then return false, "No player data" end

	local config = nil
	if category == "Poops" then
		config = ShopConfig.Poops[itemKey]
	elseif category == "Upgrades" then
		config = ShopConfig.Upgrades[itemKey]
	elseif category == "Gamepasses" then
		config = ShopConfig.Gamepasses[itemKey]
	elseif category == "Boosts" then
		config = ShopConfig.Boosts[itemKey]
	end

	if not config then return false, "Invalid item" end

	debugPrint(player.Name .. " attempting to buy " .. itemKey .. " from " .. category)

	-- Check tier requirements
	local canBuy, tierMessage = checkTierRequirement(player, category, itemKey)
	if not canBuy then
		debugPrint("Tier requirement not met: " .. tierMessage)
		return false, tierMessage
	end

	if category ~= "Boosts" and isItemOwned(player, category, itemKey) then
		debugPrint("Item already owned: " .. itemKey)
		return false, "Already owned"
	end

	if not canAffordItem(player, category, itemKey) then
		debugPrint("Cannot afford item: " .. itemKey)
		return false, "Insufficient PooBucks"
	end

	if category == "Gamepasses" then
		if config.GamepassId then
			MarketplaceService:PromptGamePassPurchase(player, config.GamepassId)
			return true, "Gamepass purchase prompted"
		else
			return false, "Invalid gamepass configuration"
		end
	elseif category == "Boosts" then
		if config.DevProductId then
			MarketplaceService:PromptProductPurchase(player, config.DevProductId)
			return true, "Boost purchase prompted"
		else
			return false, "Invalid boost configuration"
		end
	end

	-- Process regular purchase
	data.PooBucks = data.PooBucks - config.Price

	if category == "Poops" then
		table.insert(data.OwnedPoops, itemKey)
		debugPrint("Added poop to owned: " .. itemKey)
	elseif category == "Upgrades" then
		-- FIXED: Remove conflicting upgrades before adding new one
		removeConflictingUpgrades(player, category, itemKey)
		table.insert(data.OwnedUpgrades, itemKey)
		debugPrint("Added upgrade to owned (replaced conflicting): " .. itemKey)
	end

	updateLeaderstats(player)
	savePlayerData(player)

	-- ADD THIS LINE FOR TUTORIAL INTEGRATION:
	if _G.TutorialManager and _G.TutorialManager.OnPurchaseSuccess then
		_G.TutorialManager.OnPurchaseSuccess(player, category, itemKey)
	end
	
	debugPrint("Purchase successful: " .. itemKey .. " for " .. player.Name)
	return true, "Purchase successful"
end

-- New comprehensive gift validation function
local function validateGiftPurchase(gifter, targetUsername, category, itemKey)
	debugPrint("Validating gift purchase: " .. gifter.Name .. " gifting " .. category .. " " .. itemKey .. " to " .. targetUsername)

	local validation = validateUsername(targetUsername, gifter)
	if not validation.valid then
		debugPrint("Invalid target username: " .. validation.message)
		return {valid = false, message = validation.message}
	end

	local config = nil
	if category == "Gamepasses" then
		config = ShopConfig.Gamepasses[itemKey]
	elseif category == "Boosts" then
		config = ShopConfig.Boosts[itemKey]
	else
		debugPrint("Invalid category for gifting: " .. category)
		return {valid = false, message = "This item cannot be gifted"}
	end

	if not config then
		debugPrint("Invalid item config for gifting: " .. itemKey)
		return {valid = false, message = "Invalid item"}
	end

	-- Check if target already received this gamepass as a gift
	if category == "Gamepasses" then
		if hasReceivedGamepassGift(validation.userId, itemKey) then
			debugPrint("Target player already received " .. itemKey .. " as a gift")
			return {valid = false, message = "Player already received this gamepass as a gift"}
		end
	end

	-- Check if the required DevProduct IDs exist
	local requiredDevProductId = nil
	if category == "Gamepasses" then
		requiredDevProductId = config.GiftDevProductId
	elseif category == "Boosts" then
		requiredDevProductId = config.GiftDevProductId
	end
  -  Edit
  12:31:15.406  	if not requiredDevProductId then
		debugPrint("No gift DevProduct ID configured for: " .. itemKey)
		return {valid = false, message = "This item cannot be gifted"}
	end

	return {
		valid = true, 
		message = "Gift validation successful",
		userId = validation.userId,
		isOnline = validation.isOnline,
		targetPlayer = validation.targetPlayer,
		devProductId = requiredDevProductId,
		config = config
	}
end

local function checkExistingGamepassOwnership(player)
	local data = PlayerData[player]
	if not data then return end

	-- Check if player is game owner (replace YOUR_USER_ID with your actual Roblox User ID)
	local GAME_OWNER_USER_ID = 123456789  -- REPLACE WITH YOUR USER ID

	for gamepassKey, config in pairs(ShopConfig.Gamepasses) do
		if config.GamepassId then
			local ownsGamepass = false

			-- Check if player is game owner
			if player.UserId == GAME_OWNER_USER_ID then
				ownsGamepass = true
				debugPrint("Granted gamepass to owner: " .. gamepassKey)
			else
				-- Check actual gamepass ownership
				local success, result = pcall(function()
					return MarketplaceService:UserOwnsGamePassAsync(player.UserId, config.GamepassId)
				end)

				if success and result then
					ownsGamepass = true
				end
			end

			-- Add to owned gamepasses if they own it but it's not in their data
			if ownsGamepass and not table.find(data.OwnedGamepasses, gamepassKey) then
				table.insert(data.OwnedGamepasses, gamepassKey)
				debugPrint("Added missing gamepass: " .. gamepassKey .. " for " .. player.Name)
			end
		end
	end

	savePlayerData(player)
end

-- Enhanced gift purchase handling with separate DevProducts
local function processGiftPurchase(gifter, targetUsername, category, itemKey)
	debugPrint("Processing gift purchase: " .. gifter.Name .. " gifting " .. category .. " " .. itemKey .. " to " .. targetUsername)

	-- Validate the gift BEFORE prompting purchase
	local validation = validateGiftPurchase(gifter, targetUsername, category, itemKey)
	if not validation.valid then
		debugPrint("Gift validation failed: " .. validation.message)
		return false, validation.message
	end

	-- Create gift tracking ID
	local giftId = "gift_" .. gifter.UserId .. "_" .. tick() .. "_" .. math.random(1000, 9999)

	-- Store pending gift info
	PendingGifts[giftId] = {
		gifteeUserId = validation.userId,
		gifterUserId = gifter.UserId,
		gifterName = gifter.Name,
		itemType = category,
		itemKey = itemKey,
		devProductId = validation.devProductId,
		targetIsOnline = validation.isOnline
	}

	-- Prompt purchase with the GIFT DevProduct ID
	MarketplaceService:PromptProductPurchase(gifter, validation.devProductId)
	debugPrint("Prompted gift purchase with DevProduct ID: " .. validation.devProductId)

	return true, "Gift purchase prompted"
end

local function equipPoop(player, poopKey)
	local data = PlayerData[player]
	if not data then return false, "No player data" end

	if not table.find(data.OwnedPoops, poopKey) then
		debugPrint("Cannot equip unowned poop: " .. poopKey)
		return false, "Poop not owned"
	end

	data.EquippedPoop = poopKey
	EquipPoopClientEvent:FireClient(player, poopKey)
	savePlayerData(player)

	debugPrint("Equipped poop for " .. player.Name .. ": " .. poopKey)
	return true, "Equipped successfully"
end

-- Process boost gifts when player joins
local function processBoostGifts(player)
	local boostGifts = getAndClearBoostGifts(player.UserId)

	if #boostGifts > 0 then
		debugPrint("Processing " .. #boostGifts .. " boost gifts for " .. player.Name)

		for _, giftData in pairs(boostGifts) do
			local retries = 0
			local maxRetries = 10

			local function attemptBoostActivation()
				if _G.BoostSystem and _G.BoostSystem.ActivateBoost then
					local success = _G.BoostSystem.ActivateBoost(player, giftData.itemKey, giftData.duration)
					if success then
						GiftNotificationEvent:FireClient(player, giftData.gifterName, giftData.itemName)
						debugPrint("Applied boost gift: " .. giftData.itemKey .. " from " .. giftData.gifterName)
						return true
					end
				end
				return false
			end

			-- Try immediately, then retry with delays if needed
			if not attemptBoostActivation() then
				spawn(function()
					while retries < maxRetries do
						wait(1)
						retries = retries + 1
						if attemptBoostActivation() then
							break
						end
					end

					if retries >= maxRetries then
						-- Save back to gifts if we couldn't apply it
						saveBoostGift(player.UserId, giftData.gifterName, giftData.itemName, giftData.itemKey, giftData.duration)
						debugPrint("Failed to apply boost gift after " .. maxRetries .. " attempts, saved for later")
					end
				end)
			end
		end
	end
end

local SyncLocks = {}

local function syncWithShopSystem(player)
	if SyncLocks[player] then return end
	SyncLocks[player] = true

	if _G.ShopPlayerData and _G.ShopPlayerData[player] then
		local shopData = _G.ShopPlayerData[player]
		local leaderstatsData = PlayerData[player]

		if shopData and leaderstatsData and shopData.PooBucks and leaderstatsData.PooBucks then
			if math.abs(shopData.PooBucks - leaderstatsData.PooBucks) > 0.01 then
				debugPrint("SYNC: Updating leaderstats data from " .. leaderstatsData.PooBucks .. " to " .. shopData.PooBucks)
				leaderstatsData.PooBucks = shopData.PooBucks
				updateLeaderstats(player)
			end
		end
	end

	SyncLocks[player] = nil
end

-- Player Events
table.insert(connections, Players.PlayerAdded:Connect(function(player)
	debugPrint("Player joined: " .. player.Name)

	PlayerData[player] = loadPlayerData(player)

	-- NEW: Check existing gamepass ownership
	spawn(function()
		wait(2) -- Wait for data to fully load
		checkExistingGamepassOwnership(player)
	end)
	
	spawn(function()
		player:WaitForChild("leaderstats", 10)
		wait(1)
		syncWithLeaderstats(player)

		wait(2)
		if PlayerData[player] and PlayerData[player].EquippedPoop then
			EquipPoopClientEvent:FireClient(player, PlayerData[player].EquippedPoop)
		end

		-- Process any pending boost gifts
		wait(3) -- Wait for boost system to load
		processBoostGifts(player)
	end)

	-- Auto-save
	local saveConnection = spawn(function()
		while player.Parent do
			wait(30)  -  Edit
  12:31:15.407  			if PlayerData[player] then
				syncWithLeaderstats(player)
				savePlayerData(player)
			end
		end
	end)

	table.insert(connections, saveConnection)
end))

table.insert(connections, Players.PlayerRemoving:Connect(function(player)
	debugPrint("Player leaving: " .. player.Name)

	if PlayerData[player] then
		syncWithLeaderstats(player)
		savePlayerData(player)
		PlayerData[player] = nil
	end
end))

-- RemoteEvent Handlers
table.insert(connections, PurchaseRequest.OnServerEvent:Connect(function(player, action, category, itemKey)
	debugPrint("Purchase request from " .. player.Name .. ": " .. action .. " " .. category .. " " .. itemKey)

	if action == "Buy" then
		local success, message = processPurchase(player, category, itemKey)
		PurchaseResultEvent:FireClient(player, success, message, category, itemKey)

		if success then
			debugPrint("Purchase successful: " .. player.Name .. " bought " .. itemKey)
		else
			debugPrint("Purchase failed: " .. player.Name .. " - " .. message)
		end

	elseif action == "Equip" and category == "Poops" then
		local success, message = equipPoop(player, itemKey)
		PurchaseResultEvent:FireClient(player, success, message, category, itemKey)

		if success then
			debugPrint("Equip successful: " .. player.Name .. " equipped " .. itemKey)
		else
			debugPrint("Equip failed: " .. player.Name .. " - " .. message)
		end
	end
end))

GiftValidationRequest.OnServerInvoke = function(player, targetUsername, category, itemKey)
	local validation = validateGiftPurchase(player, targetUsername, category, itemKey)
	return validation
end

table.insert(connections, GiftPurchaseRequest.OnServerEvent:Connect(function(player, targetUsername, category, itemKey)
	debugPrint("Gift purchase request from " .. player.Name .. " to " .. targetUsername .. ": " .. category .. " " .. itemKey)

	local success, message = processGiftPurchase(player, targetUsername, category, itemKey)

	if not success then
		debugPrint("Gift purchase failed: " .. message)
	end
end))

ValidateUsernameRemote.OnServerInvoke = function(player, username)
	return validateUsername(username, player)
end

GetPlayerDataRemote.OnServerInvoke = function(player)
	syncWithLeaderstats(player)
	return PlayerData[player] or createDefaultPlayerData()
end

CheckOfflineGifts.OnServerInvoke = function(player)
	return getAndClearOfflineGifts(player.UserId)
end

-- Gamepass Purchase Handling
table.insert(connections, MarketplaceService.PromptGamePassPurchaseFinished:Connect(function(player, gamepassId, wasPurchased)
	if wasPurchased then
		debugPrint("Gamepass purchased: " .. player.Name .. " - " .. gamepassId)

		for itemKey, config in pairs(ShopConfig.Gamepasses) do
			if config.GamepassId == gamepassId then
				local data = PlayerData[player]
				if data then
					table.insert(data.OwnedGamepasses, itemKey)
					savePlayerData(player)
					debugPrint("Added gamepass to player: " .. itemKey)
				end
				break
			end
		end
	end
end))

-- Enhanced DevProduct Purchase Handling with separate gift DevProducts
MarketplaceService.ProcessReceipt = function(receiptInfo)
	local player = Players:GetPlayerByUserId(receiptInfo.PlayerId)
	if not player then
		return Enum.ProductPurchaseDecision.NotProcessedYet
	end

	debugPrint("Processing DevProduct purchase: " .. receiptInfo.ProductId .. " for " .. player.Name)

	-- Check if this was a gift purchase (using gift DevProduct IDs)
	local giftInfo = nil
	for giftId, info in pairs(PendingGifts) do
		if info.gifterUserId == player.UserId and info.devProductId == receiptInfo.ProductId then
			giftInfo = info
			PendingGifts[giftId] = nil -- Remove from pending
			break
		end
	end

	if giftInfo then
		-- This was a GIFT purchase
		debugPrint("Processing GIFT: " .. giftInfo.itemType .. " " .. giftInfo.itemKey .. " to user " .. giftInfo.gifteeUserId)

		local success = grantItemToPlayer(giftInfo.gifteeUserId, giftInfo.itemType, giftInfo.itemKey, giftInfo.gifterName)
		if success then
			debugPrint("Gift successfully granted!")
			return Enum.ProductPurchaseDecision.PurchaseGranted
		else
			debugPrint("Failed to grant gift")
			return Enum.ProductPurchaseDecision.NotProcessedYet
		end
	else
		-- Check for regular boost self-purchases
		for boostKey, config in pairs(ShopConfig.Boosts) do
			if config.DevProductId == receiptInfo.ProductId then
				debugPrint("Regular boost SELF-purchase - activating for " .. player.Name)

				if _G.BoostSystem and _G.BoostSystem.ActivateBoost then
					local success = _G.BoostSystem.ActivateBoost(player, boostKey, config.Duration)
					if success then
						debugPrint("Boost self-purchase successful: " .. boostKey .. " for " .. player.Name)
						return Enum.ProductPurchaseDecision.PurchaseGranted
					else
						debugPrint("Failed to activate boost: " .. boostKey .. " for " .. player.Name)
						return Enum.ProductPurchaseDecision.NotProcessedYet
					end
				else
					debugPrint("ERROR: BoostSystem not available")
					return Enum.ProductPurchaseDecision.NotProcessedYet
				end
			end
		end
	end

	debugPrint("Unknown DevProduct ID: " .. receiptInfo.ProductId)
	return Enum.ProductPurchaseDecision.NotProcessedYet
end

-- Enhanced shutdown handling
game:BindToClose(function()
	debugPrint("Server shutting down - saving all shop data...")
	for player, data in pairs(PlayerData) do
		if player.Parent then
			syncWithLeaderstats(player)
			savePlayerData(player)
		end
	end
	cleanupConnections()
	wait(3)
	debugPrint("All shop data saved!")
end)

debugPrint("ShopServer initialized successfully with tier system!")

>>> game.ServerScriptService.TutorialManager (Script) — 538 lines
-- TutorialManager (ServerScript in ServerScriptService) - FULLY DATA-DRIVEN SYSTEM
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DataStoreService = game:GetService("DataStoreService")
local RunService = game:GetService("RunService")

-- Get TutorialConfig
local TutorialConfig = require(ReplicatedStorage:WaitForChild("TutorialConfig"))

-- Debug system
local function debugPrint(message)
	if TutorialConfig.Debug.Enabled and TutorialConfig.Debug.ShowTutorialDebug then
		print("[TUTORIAL MANAGER]: " .. message)
	end
end

-- DataStore for tutorial progress
local TutorialDataStore = DataStoreService:GetDataStore("TutorialProgress_v1")

-- Create RemoteEvents
local TutorialStepCompleted = Instance.new("RemoteEvent")
TutorialStepCompleted.Name = "TutorialStepCompleted"
TutorialStepCompleted.Parent = ReplicatedStorage

local TutorialProgressUpdate = Instance.new("RemoteEvent")
TutorialProgressUpdate.Name = "TutorialProgressUpdate"
TutorialProgressUpdate.Parent = ReplicatedStorage

local StartTutorial = Instance.new("RemoteEvent")
StartTutorial.Name = "StartTutorial"
StartTutorial.Parent = ReplicatedStorage
  -  Edit
  12:31:15.407  local GetTutorialStatus = Instance.new("RemoteFunction")
GetTutorialStatus.Name = "GetTutorialStatus"
GetTutorialStatus.Parent = ReplicatedStorage

-- Player tutorial data
local PlayerTutorialData = {}

-- Tutorial parts references
local TutorialParts = workspace:WaitForChild("TutorialParts")

debugPrint("TutorialManager initializing...")

-- GENERIC: Function to check if step requirements are met
local function checkStepRequirements(player, stepConfig)
	local requirementType = TutorialConfig.RequirementTypes[stepConfig.RequirementType]
	if not requirementType then
		debugPrint("Unknown requirement type: " .. stepConfig.RequirementType)
		return false
	end

	if stepConfig.RequirementType == "PurchaseItem" then
		return playerOwnsItem(player, stepConfig.RequiredItem)
	elseif stepConfig.RequirementType == "PoopCount" then
		local data = PlayerTutorialData[player]
		if data and data.StepProgress[stepConfig.StepID] then
			return data.StepProgress[stepConfig.StepID] >= stepConfig.RequiredAmount
		end
	elseif stepConfig.RequirementType == "CollectItems" then
		local data = PlayerTutorialData[player]
		if data and data.StepProgress[stepConfig.StepID] then
			return data.StepProgress[stepConfig.StepID] >= stepConfig.RequiredAmount
		end
	elseif stepConfig.RequirementType == "ReachLevel" then
		-- Check player level (you'll need to implement this based on your level system)
		local leaderstats = player:FindFirstChild("leaderstats")
		if leaderstats then
			local level = leaderstats:FindFirstChild("Level")
			if level then
				return level.Value >= stepConfig.RequiredLevel
			end
		end
	end
	-- Add more requirement checks as needed

	return false
end

-- Function to check if player owns a specific item
function playerOwnsItem(player, itemKey)
	-- Try multiple methods to check for item ownership

	-- Method 1: Check if ShopManager exists and has ownership check
	if _G.ShopManager and _G.ShopManager.PlayerOwnsItem then
		local owned = _G.ShopManager.PlayerOwnsItem(player, itemKey)
		if owned then
			debugPrint("Player " .. player.Name .. " owns " .. itemKey .. " (via ShopManager)")
			return true
		end
	end

	-- Method 2: Check leaderstats for the item
	local leaderstats = player:FindFirstChild("leaderstats")
	if leaderstats then
		local item = leaderstats:FindFirstChild(itemKey)
		if item and item.Value > 0 then
			debugPrint("Player " .. player.Name .. " owns " .. itemKey .. " (via leaderstats)")
			return true
		end
	end

	-- Method 3: Check PlayerData if it exists
	if _G.PlayerData and _G.PlayerData[player] then
		local playerData = _G.PlayerData[player]

		-- Check if player has purchased items data
		if playerData.PurchasedItems and playerData.PurchasedItems[itemKey] then
			debugPrint("Player " .. player.Name .. " owns " .. itemKey .. " (via PlayerData)")
			return true
		end

		-- Check specific categories
		if playerData.Poops and playerData.Poops[itemKey] then
			debugPrint("Player " .. player.Name .. " owns " .. itemKey .. " (via PlayerData.Poops)")
			return true
		end
	end

	-- Method 4: Check if InventoryManager exists
	if _G.InventoryManager and _G.InventoryManager.HasItem then
		local owned = _G.InventoryManager.HasItem(player, itemKey)
		if owned then
			debugPrint("Player " .. player.Name .. " owns " .. itemKey .. " (via InventoryManager)")
			return true
		end
	end

	debugPrint("Player " .. player.Name .. " does NOT own " .. itemKey)
	return false
end

-- Function to create default tutorial data
local function createDefaultTutorialData()
	return {
		TutorialCompleted = false,
		CurrentStep = 1,
		StepProgress = {},
		CompletedSteps = {}
	}
end

-- Function to load tutorial data
local function loadTutorialData(player)
	local success, data = pcall(function()
		return TutorialDataStore:GetAsync("Tutorial_" .. player.UserId)
	end)

	if success and data then
		debugPrint("Loaded tutorial data for " .. player.Name)
		return data
	else
		debugPrint("Creating default tutorial data for " .. player.Name)
		return createDefaultTutorialData()
	end
end

-- Function to save tutorial data
local function saveTutorialData(player)
	local data = PlayerTutorialData[player]
	if not data then return end

	local success = pcall(function()
		TutorialDataStore:SetAsync("Tutorial_" .. player.UserId, data)
	end)

	if success then
		debugPrint("Saved tutorial data for " .. player.Name)
	else
		debugPrint("Failed to save tutorial data for " .. player.Name)
	end
end

-- Function to check if player needs tutorial
local function needsTutorial(player)
	local data = PlayerTutorialData[player]
	return data and not data.TutorialCompleted
end

-- Function to get current tutorial step
local function getCurrentTutorialStep(player)
	local data = PlayerTutorialData[player]
	if not data then return nil end

	return TutorialConfig.Steps[data.CurrentStep]
end

-- IMPROVED: Function to advance tutorial step with better error handling
local function advanceTutorialStep(player)
	local data = PlayerTutorialData[player]
	if not data then 
		debugPrint("ERROR: No tutorial data for " .. player.Name)
		return 
	end

	local currentStep = TutorialConfig.Steps[data.CurrentStep]
	if currentStep then
		-- Mark current step as completed
		table.insert(data.CompletedSteps, currentStep.StepID)
		debugPrint("Completed step: " .. currentStep.StepID .. " for " .. player.Name)

		-- Check if tutorial is complete
		if currentStep.CompleteTutorial then
			data.TutorialCompleted = true

			-- Give completion rewards ONLY for actual completion (not skipping)
			if TutorialConfig.CompletionRewards.PooBucks > 0 then
				if _G.LeaderstatsManager and _G.LeaderstatsManager.GiveCurrency then
					_G.LeaderstatsManager.GiveCurrency(
						player, 
						TutorialConfig.CompletionRewards.PooBucks, 
						"Tutorial completion"
					)
				end
			end

			debugPrint("Tutorial completed for " .. player.Name)
			saveTutorialData(player)

			-- Use spawn to prevent yield issues
			spawn(function()
				TutorialStepCompleted:FireClient(player, true)
			end)
			return
		else
			-- Advance to next step
			data.CurrentStep = data.CurrentStep + 1
		end

		-- Save immediately after advancing
		saveTutorialData(player)
  -  Edit
  12:31:15.407  		-- Update client with next step
		local nextStep = TutorialConfig.Steps[data.CurrentStep]
		if nextStep then
			debugPrint("Advancing to next step: " .. nextStep.StepID .. " for " .. player.Name)

			-- Check if next step requirements are already met
			if checkStepRequirements(player, nextStep) then
				debugPrint("Next step requirements already met for " .. player.Name .. ", auto-advancing...")
				-- Use spawn to prevent stack overflow and yield issues
				spawn(function()
					wait(0.1)
					advanceTutorialStep(player)
				end)
				return
			end

			-- Send step data to client (client will handle beams)
			wait(0.5) -- Longer delay for ButtonClick steps
			local ownsItem = false
			if nextStep.RequirementType == "PurchaseItem" then
				ownsItem = playerOwnsItem(player, nextStep.RequiredItem)
			end

			StartTutorial:FireClient(player, nextStep, data.CurrentStep, ownsItem)
		else
			-- Tutorial finished
			spawn(function()
				TutorialStepCompleted:FireClient(player, true)
			end)
		end
	else
		debugPrint("ERROR: No current step found for " .. player.Name .. " at step " .. data.CurrentStep)
	end
end

-- GENERIC: Function to update step progress
local function updateStepProgress(player, progress)
	local data = PlayerTutorialData[player]
	if not data then return end

	local currentStep = TutorialConfig.Steps[data.CurrentStep]
	if not currentStep then return end

	-- Update progress
	data.StepProgress[currentStep.StepID] = progress

	-- Check if step requirement is met based on requirement type
	local requirementMet = false
	local requirementType = TutorialConfig.RequirementTypes[currentStep.RequirementType]

	if requirementType and requirementType.RequiresProgress then
		requirementMet = progress >= (currentStep.RequiredAmount or 1)
	end

	-- Notify client of progress update
	spawn(function()
		TutorialProgressUpdate:FireClient(player, progress, currentStep.RequiredAmount or 0, requirementMet)
	end)

	-- Auto-advance if requirement is met
	if requirementMet then
		spawn(function()
			wait(0.5) -- Small delay before advancing
			advanceTutorialStep(player)
		end)
	end
end

-- GENERIC: Function to handle specific tutorial events
local function handleTutorialEvent(player, eventType, eventData)
	if not needsTutorial(player) then return end

	local currentStep = getCurrentTutorialStep(player)
	if not currentStep then return end

	debugPrint("Handling tutorial event: " .. eventType .. " for " .. player.Name)

	if currentStep.RequirementType == eventType then
		if eventType == "PoopCount" or eventType == "CollectItems" then
			local currentProgress = (PlayerTutorialData[player].StepProgress[currentStep.StepID] or 0) + 1
			updateStepProgress(player, currentProgress)

		elseif eventType == "ShopOpen" then
			spawn(function()
				advanceTutorialStep(player)
			end)

		elseif eventType == "PurchaseItem" then
			if eventData == currentStep.RequiredItem then
				spawn(function()
					advanceTutorialStep(player)
				end)
			end

		elseif eventType == "TouchPart" then
			if eventData == currentStep.RequiredPart then
				spawn(function()
					advanceTutorialStep(player)
				end)
			end

		elseif eventType == "NPCInteraction" then
			if eventData == currentStep.RequiredNPC then
				spawn(function()
					advanceTutorialStep(player)
				end)
			end

		elseif eventType == "ReachLevel" then
			if eventData >= currentStep.RequiredLevel then
				spawn(function()
					advanceTutorialStep(player)
				end)
			end
		end
		-- NEW REQUIREMENT TYPES AUTOMATICALLY HANDLED!
	end
end

-- GENERIC: Setup touch detection for tutorial parts
local function setupTouchDetection()
	debugPrint("=== SETTING UP TOUCH DETECTION ===")
	for _, stepConfig in pairs(TutorialConfig.Steps) do
		if stepConfig.RequirementType == "TouchPart" and stepConfig.RequiredPart then
			debugPrint("Setting up touch for step: " .. stepConfig.StepID .. " - Part: " .. stepConfig.RequiredPart)
			local part = TutorialParts:FindFirstChild(stepConfig.RequiredPart)
			if part then
				debugPrint("Found touch part: " .. stepConfig.RequiredPart)

				-- Make sure the part is touchable
				part.CanTouch = true

				part.Touched:Connect(function(hit)
					local humanoid = hit.Parent:FindFirstChildOfClass("Humanoid")
					if humanoid then
						local player = Players:GetPlayerFromCharacter(hit.Parent)
						if player then
							debugPrint("TOUCH DETECTED: " .. player.Name .. " touched " .. stepConfig.RequiredPart)
							handleTutorialEvent(player, "TouchPart", stepConfig.RequiredPart)
						end
					end
				end)
				debugPrint("Setup touch detection for: " .. stepConfig.RequiredPart)
			else
				debugPrint("ERROR: Could not find touch part: " .. stepConfig.RequiredPart)
			end
		end
	end
	debugPrint("=== TOUCH DETECTION SETUP COMPLETE ===")
end

-- IMPROVED: Player events with better timing handling
Players.PlayerAdded:Connect(function(player)
	debugPrint("Player joined: " .. player.Name)

	-- Load tutorial data immediately
	PlayerTutorialData[player] = loadTutorialData(player)

	-- Function to start tutorial for player
	local function startTutorialForPlayer()
		spawn(function()
			wait(3) -- Wait for everything to load

			if needsTutorial(player) then
				debugPrint("Starting tutorial for " .. player.Name)
				local currentStep = getCurrentTutorialStep(player)
				if currentStep then
					-- Check if current step requirements are already met
					if checkStepRequirements(player, currentStep) then
						debugPrint("Current step requirements already met for " .. player.Name .. ", auto-advancing...")
						advanceTutorialStep(player)
						return
					end

					-- Send step data to client
					local ownsItem = false
					if currentStep.RequirementType == "PurchaseItem" then
						ownsItem = playerOwnsItem(player, currentStep.RequiredItem)
					end

					debugPrint("Firing StartTutorial to client for step: " .. currentStep.StepID)
					StartTutorial:FireClient(player, currentStep, PlayerTutorialData[player].CurrentStep, ownsItem)
				else
					debugPrint("ERROR: No current step found for " .. player.Name)
				end
			else
				debugPrint("Player " .. player.Name .. " does not need tutorial")
			end
		end)
	end

	-- Handle character spawning/respawning
	player.CharacterAdded:Connect(function(character)
		debugPrint("Character spawned for " .. player.Name)
		startTutorialForPlayer()
	end)

	-- IMPORTANT: Also check if character already exists (timing fix)
	if player.Character then
		debugPrint("Character already exists for " .. player.Name .. ", starting tutorial immediately")  -  Edit
  12:31:15.408  		startTutorialForPlayer()
	end
end)

Players.PlayerRemoving:Connect(function(player)
	if PlayerTutorialData[player] then
		saveTutorialData(player)
		PlayerTutorialData[player] = nil
	end
end)

-- RemoteEvent connections with error handling
TutorialStepCompleted.OnServerEvent:Connect(function(player, stepID)
	debugPrint("Step completed by client: " .. (stepID or "unknown") .. " for " .. player.Name)

	-- NEW: Handle tutorial skip (NO REWARDS)
	if stepID == "SKIP_TUTORIAL" then
		debugPrint("Player " .. player.Name .. " skipped the tutorial")
		local data = PlayerTutorialData[player]
		if data then
			data.TutorialCompleted = true
			data.CurrentStep = #TutorialConfig.Steps + 1 -- Set to beyond last step

			-- NO REWARDS FOR SKIPPING!
			debugPrint("Tutorial marked as completed (skipped) for " .. player.Name .. " - NO REWARDS GIVEN")

			saveTutorialData(player)
		end
		return
	end

	-- Continue with normal step advancement (WITH REWARDS)
	spawn(function()
		advanceTutorialStep(player)
	end)
end)

GetTutorialStatus.OnServerInvoke = function(player)
	local data = PlayerTutorialData[player]
	if data then
		return {
			needsTutorial = needsTutorial(player),
			currentStep = data.CurrentStep,
			tutorialCompleted = data.TutorialCompleted
		}
	end
	return {needsTutorial = false, currentStep = 0, tutorialCompleted = true}
end

-- GENERIC: Monitor events properly
spawn(function()
	wait(2) -- Wait for RemoteEvents to exist

	-- Monitor all events specified in steps
	for _, stepConfig in pairs(TutorialConfig.Steps) do
		if stepConfig.EventToMonitor then
			local eventToMonitor = ReplicatedStorage:FindFirstChild(stepConfig.EventToMonitor)
			if eventToMonitor then
				eventToMonitor.OnServerEvent:Connect(function(player, ...)
					local args = {...}
					local eventData = args[1] -- First argument as event data
					handleTutorialEvent(player, stepConfig.RequirementType, eventData)
				end)
				debugPrint("Connected to event: " .. stepConfig.EventToMonitor)
			else
				debugPrint("WARNING: Event not found: " .. stepConfig.EventToMonitor)
			end
		end
	end

	-- Legacy event connections (for backwards compatibility)
	local RemoteEvent_OpenShop = ReplicatedStorage:FindFirstChild("RemoteEvent_OpenShop")
	if RemoteEvent_OpenShop then
		RemoteEvent_OpenShop.OnServerEvent:Connect(function(player)
			debugPrint("Shop opened by: " .. player.Name)
			handleTutorialEvent(player, "ShopOpen", nil)
		end)
		debugPrint("Connected to shop opening event")
	end

	local PoopSpawnedEvent = ReplicatedStorage:FindFirstChild("PoopSpawnedEvent")
	if PoopSpawnedEvent then
		PoopSpawnedEvent.OnServerEvent:Connect(function(player)
			handleTutorialEvent(player, "PoopCount", nil)
		end)
		debugPrint("Connected to poop spawning event")
	end
end)

-- Initialize
setupTouchDetection()

debugPrint("TutorialManager initialized successfully!")

-- Expose globally for other scripts
_G.TutorialManager = {
	HandleTutorialEvent = handleTutorialEvent,
	NeedsTutorial = needsTutorial,
	GetCurrentStep = getCurrentTutorialStep,
	PlayerOwnsItem = playerOwnsItem,
	OnPurchaseSuccess = function(player, category, itemKey)
		if category == "Poops" then
			handleTutorialEvent(player, "PurchaseItem", itemKey)
		end
	end
}

>>> game.ServerScriptService.VIPChatSystem (Script) — 159 lines
-- VIPChatSystem (ServerScript in ServerScriptService) - HANDLES VIP CHAT PREFIXES
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TextService = game:GetService("TextService")

-- Get ShopConfig
local ShopConfig = require(ReplicatedStorage:WaitForChild("ShopConfig"))

-- Debug system
local function debugPrint(message)
	if ShopConfig.Debug.Enabled and ShopConfig.Debug.ShowServerDebug then
		print("[VIP CHAT]: " .. message)
	end
end

-- Player VIP status tracking
local PlayerVIPStatus = {}

debugPrint("VIPChatSystem initializing...")

-- Function to check if player has VIP gamepass
local function hasVIPGamepass(player)
	if _G.ShopPlayerData and _G.ShopPlayerData[player] and _G.ShopPlayerData[player].OwnedGamepasses then
		return table.find(_G.ShopPlayerData[player].OwnedGamepasses, "VIPZone") ~= nil
	end
	return false
end

-- Function to update player VIP status
local function updatePlayerVIPStatus(player)
	local hasVIP = hasVIPGamepass(player)
	local previousStatus = PlayerVIPStatus[player]

	if hasVIP ~= previousStatus then
		PlayerVIPStatus[player] = hasVIP

		if hasVIP then
			debugPrint(player.Name .. " gained VIP status")
		else
			debugPrint(player.Name .. " lost VIP status")
		end

		-- Update the player's chat tags immediately
		updatePlayerChatTags(player)
	end
end

-- Function to update player chat tags
function updatePlayerChatTags(player)
	local hasVIP = PlayerVIPStatus[player]

	-- Get or create the ChatService tags
	local success = pcall(function()
		local ChatService = require(game:GetService("ServerScriptService"):WaitForChild("ChatServiceRunner"):WaitForChild("ChatService"))
		local speaker = ChatService:GetSpeaker(player.Name)

		if speaker then
			if hasVIP then
				-- Add VIP tag
				speaker:SetExtraData("ChatColor3", Color3.fromRGB(255, 215, 0)) -- Gold color
				speaker:SetExtraData("NameColor3", Color3.fromRGB(255, 215, 0)) -- Gold name
				speaker:SetExtraData("Tags", {{TagText = "👑 VIP", TagColor = Color3.fromRGB(255, 215, 0)}})
				debugPrint("Added VIP chat tags for " .. player.Name)
			else
				-- Remove VIP tag
				speaker:SetExtraData("ChatColor3", Color3.fromRGB(255, 255, 255)) -- White color
				speaker:SetExtraData("NameColor3", Color3.fromRGB(255, 255, 255)) -- White name
				speaker:SetExtraData("Tags", {})
				debugPrint("Removed VIP chat tags for " .. player.Name)
			end
		end
	end)

	if not success then
		-- Fallback: Use legacy chat modification
		spawn(function()
			wait(1) -- Wait for player to fully load

			local playerGui = player:WaitForChild("PlayerGui", 5)
			if playerGui then
				local chat = playerGui:FindFirstChild("Chat")
				if chat then
					-- Try to modify chat appearance (this is limited in new chat)
					debugPrint("Using legacy chat modification for " .. player.Name)
				end
			end
		end)
	end
end

-- Function to get chat prefix for player
local function getChatPrefix(player)  -  Edit
  12:31:15.408  	if PlayerVIPStatus[player] then
		return ShopConfig.VIPZone.ChatPrefix .. " "
	end
	return ""
end

-- Monitor players for VIP status changes
spawn(function()
	while true do
		wait(30) -- Check every 30 seconds

		for _, player in pairs(Players:GetPlayers()) do
			if player.Parent then
				updatePlayerVIPStatus(player)
			end
		end
	end
end)

-- Player events
Players.PlayerAdded:Connect(function(player)
	debugPrint("Player joined: " .. player.Name)

	-- Initialize VIP status
	PlayerVIPStatus[player] = false

	-- Check VIP status after a delay
	spawn(function()
		wait(5) -- Wait for shop data to load
		updatePlayerVIPStatus(player)
	end)

	-- Set up chat modification when player joins
	player.Chatted:Connect(function(message)
		if PlayerVIPStatus[player] then
			-- For VIP players, we could add additional chat effects here
			-- The main visual changes are handled by updatePlayerChatTags
			debugPrint("VIP player " .. player.Name .. " chatted: " .. message)
		end
	end)
end)

Players.PlayerRemoving:Connect(function(player)
	PlayerVIPStatus[player] = nil
	debugPrint("Player left: " .. player.Name)
end)

-- Clean up existing players
for _, player in pairs(Players:GetPlayers()) do
	PlayerVIPStatus[player] = false
	spawn(function()
		wait(2)
		updatePlayerVIPStatus(player)
	end)
end

-- Global functions
_G.VIPChatSystem = {
	HasVIPGamepass = hasVIPGamepass,
	UpdatePlayerVIPStatus = updatePlayerVIPStatus,
	GetChatPrefix = getChatPrefix,
	IsPlayerVIP = function(player)
		return PlayerVIPStatus[player] or false
	end
}

debugPrint("VIPChatSystem initialized successfully!")

>>> game.ServerScriptService.ZoneSystem (Script) — 363 lines
-- ZoneSystem (ServerScript in ServerScriptService) - UPDATED WITH VIP ZONE SUPPORT
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Get ShopConfig
local ShopConfig = require(ReplicatedStorage:WaitForChild("ShopConfig"))

-- Debug system
local function debugPrint(message)
	if ShopConfig.Debug.Enabled and ShopConfig.Debug.ShowZoneDebug then
		print("[ZONE SYSTEM]: " .. message)
	end
end

-- Create RemoteEvents
local ZoneEnteredEvent = Instance.new("RemoteEvent")
ZoneEnteredEvent.Name = "ZoneEnteredEvent"
ZoneEnteredEvent.Parent = ReplicatedStorage

local ZoneExitedEvent = Instance.new("RemoteEvent")
ZoneExitedEvent.Name = "ZoneExitedEvent"
ZoneExitedEvent.Parent = ReplicatedStorage

local ZoneUnlockedEvent = Instance.new("RemoteEvent")
ZoneUnlockedEvent.Name = "ZoneUnlockedEvent"
ZoneUnlockedEvent.Parent = ReplicatedStorage

local GetPlayerZoneRemote = Instance.new("RemoteFunction")
GetPlayerZoneRemote.Name = "GetPlayerZone"
GetPlayerZoneRemote.Parent = ReplicatedStorage

local VIPZoneAccessEvent = Instance.new("RemoteEvent")
VIPZoneAccessEvent.Name = "VIPZoneAccessEvent"
VIPZoneAccessEvent.Parent = ReplicatedStorage

-- Player zone tracking
local PlayerZones = {} -- [player] = zoneKey or nil

-- Wait for zones folder
local zonesFolder = workspace:WaitForChild("Zones")

debugPrint("ZoneSystem initializing with VIP zone support...")

-- Function to get player's poops pooped count
local function getPlayerPoopsPooped(player)
	if _G.LeaderstatsManager and _G.LeaderstatsManager.GetPlayerData then
		local data = _G.LeaderstatsManager.GetPlayerData(player)
		return data and data.TotalPoopsSpawned or 0
	end

	-- Fallback to leaderstats
	local leaderstats = player:FindFirstChild("leaderstats")
	if leaderstats then
		local poops = leaderstats:FindFirstChild("Poops")
		if poops then
			return poops.Value
		end
	end

	return 0
end

-- NEW: Function to check if player owns required gamepass
local function hasRequiredGamepass(player, gamepassKey)
	if not gamepassKey then return true end

	if _G.ShopPlayerData and _G.ShopPlayerData[player] and _G.ShopPlayerData[player].OwnedGamepasses then
		return table.find(_G.ShopPlayerData[player].OwnedGamepasses, gamepassKey) ~= nil
	end

	return false
end

-- NEW: Function to check if player has "Unlock All Zones" gamepass
local function hasUnlockAllZonesGamepass(player)
	return hasRequiredGamepass(player, "UnlockAllZones")
end

-- ENHANCED: Function to check if player can enter zone (with VIP and gamepass support)
local function canEnterZone(player, zoneKey)
	if not ShopConfig.Zones then
		return false, "Zone configuration not found"
	end

	local zoneConfig = ShopConfig.Zones[zoneKey]
	if not zoneConfig then 
		return false, "Zone not found"
	end

	-- Check for VIP zone access
	if zoneConfig.IsVIP then
		if not hasRequiredGamepass(player, zoneConfig.RequiredGamepass) then
			return false, "VIP Zone Access Required! Purchase the VIP gamepass to enter."
		end
		return true, "VIP access granted"
	end

	-- Check for "Unlock All Zones" gamepass (bypasses poop requirements)
	if hasUnlockAllZonesGamepass(player) then
		debugPrint(player.Name .. " has Unlock All Zones gamepass - access granted to " .. zoneKey)
		return true, "All zones unlocked via gamepass"
	end

	-- Regular zone access check
	local playerPooped = getPlayerPoopsPooped(player)
	local required = zoneConfig.RequiredPoopsPooped

	if playerPooped < required then
		return false, "You need " .. required .. " poops pooped to enter this zone! (You have " .. playerPooped .. ")"
	end

	return true, "Access granted"
end

-- ENHANCED: Function to enter zone (with VIP zone special handling)
local function enterZone(player, zoneKey)
	debugPrint("ENTER ZONE CALLED: " .. player.Name .. " trying to enter " .. tostring(zoneKey))

	local canEnter, reason = canEnterZone(player, zoneKey)
	if not canEnter then
		debugPrint("FAILED: " .. player.Name .. " cannot enter " .. zoneKey .. ": " .. reason)
		ZoneEnteredEvent:FireClient(player, nil, reason, false) -- Send failure
		return false
	end

	local previousZone = PlayerZones[player]
	PlayerZones[player] = zoneKey

	local zoneConfig = ShopConfig.Zones[zoneKey]
	debugPrint("SUCCESS: " .. player.Name .. " entered " .. zoneKey .. " (Multiplier: " .. zoneConfig.Multiplier .. "x)")  -  Edit
  12:31:15.409  
	-- Special handling for VIP zone
	if zoneConfig.IsVIP then
		debugPrint("Player entered VIP zone: " .. zoneKey)
		VIPZoneAccessEvent:FireClient(player, "entered", {
			zoneName = zoneConfig.Name,
			multiplier = zoneConfig.Multiplier,
			chatEmoji = zoneConfig.ChatEmoji
		})
	end

	-- Notify client of zone entry
	ZoneEnteredEvent:FireClient(player, zoneKey, zoneConfig.Multiplier, true)

	return true
end

-- ENHANCED: Function to exit zone (with VIP zone special handling)
local function exitZone(player)
	local previousZone = PlayerZones[player]
	PlayerZones[player] = nil

	if previousZone then
		debugPrint("EXIT ZONE: " .. player.Name .. " exited " .. previousZone)

		-- Check if exiting VIP zone
		local zoneConfig = ShopConfig.Zones[previousZone]
		if zoneConfig and zoneConfig.IsVIP then
			debugPrint("Player exited VIP zone: " .. previousZone)
			VIPZoneAccessEvent:FireClient(player, "exited", {
				zoneName = zoneConfig.Name
			})
		end

		ZoneExitedEvent:FireClient(player)
	end
end

-- ENHANCED: Function to get player's zone multiplier (with VIP zone support)
local function getPlayerZoneMultiplier(player)
	local zoneKey = PlayerZones[player]
	if not zoneKey then return 1 end

	if not ShopConfig.Zones then return 1 end

	local zoneConfig = ShopConfig.Zones[zoneKey]
	if not zoneConfig then return 1 end

	-- For VIP zones, double-check access (in case gamepass was removed)
	if zoneConfig.IsVIP then
		if not hasRequiredGamepass(player, zoneConfig.RequiredGamepass) then
			debugPrint("Player lost VIP access, removing from zone")
			exitZone(player)
			return 1
		end
	end

	return zoneConfig.Multiplier
end

-- Function to set player zone (for portal system)
local function setPlayerZone(player, zoneKey)
	debugPrint("SetPlayerZone called: " .. player.Name .. " -> " .. tostring(zoneKey))

	if zoneKey then
		-- Enter the specified zone
		enterZone(player, zoneKey)
	else
		-- Exit current zone (going to MainMap)
		exitZone(player)
	end
end

-- ENHANCED: Function to check for zone unlocks (with gamepass bypass)
local function checkZoneUnlocks(player)
	if not ShopConfig.Zones then
		debugPrint("ShopConfig.Zones not found - cannot check unlocks")
		return
	end

	local playerPooped = getPlayerPoopsPooped(player)
	local hasUnlockAll = hasUnlockAllZonesGamepass(player)

	for zoneKey, zoneConfig in pairs(ShopConfig.Zones) do
		-- Skip VIP zones for regular unlock notifications
		if not zoneConfig.IsVIP then
			local meetsRequirement = hasUnlockAll or (playerPooped >= zoneConfig.RequiredPoopsPooped)

			if meetsRequirement then
				-- Check if player just unlocked this zone
				local hasSeenUnlock = player:GetAttribute("UnlockedZone_" .. zoneKey)
				if not hasSeenUnlock then
					player:SetAttribute("UnlockedZone_" .. zoneKey, true)

					local unlockMessage = zoneConfig.UnlockMessage
					if hasUnlockAll and playerPooped < zoneConfig.RequiredPoopsPooped then
						unlockMessage = "🎉 Zone unlocked via gamepass! " .. zoneConfig.Name .. " (" .. zoneConfig.Multiplier .. "x earnings)"
					end

					debugPrint(player.Name .. " unlocked " .. zoneKey .. "!")
					ZoneUnlockedEvent:FireClient(player, zoneKey, zoneConfig.Name, unlockMessage)
				end
			end
		end
	end
end

-- Setup zone detection for each zone
if ShopConfig.Zones then
	for zoneKey, zoneConfig in pairs(ShopConfig.Zones) do
		local zonePart = zonesFolder:FindFirstChild(zoneKey)
		if zonePart then
			debugPrint("Setting up zone detection for " .. zoneKey .. (zoneConfig.IsVIP and " (VIP)" or ""))

			-- Zone entered
			zonePart.Touched:Connect(function(hit)
				local player = Players:GetPlayerFromCharacter(hit.Parent)
				if player and PlayerZones[player] ~= zoneKey then
					enterZone(player, zoneKey)
				end
			end)
		else
			warn("Zone part not found: " .. zoneKey)
		end
	end
else
	warn("ShopConfig.Zones not found! Please add Zones configuration to ShopConfig.")
end

-- Monitor players leaving zones (distance-based)
spawn(function()
	while true do
		wait(1) -- Check every second

		for player, currentZone in pairs(PlayerZones) do
			if player.Parent and player.Character then
				local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
				if humanoidRootPart then
					local zonePart = zonesFolder:FindFirstChild(currentZone)
					if zonePart then
						local distance = (humanoidRootPart.Position - zonePart.Position).Magnitude
						local maxDistance = math.max(zonePart.Size.X, zonePart.Size.Y, zonePart.Size.Z) / 2 + 10

						if distance > maxDistance then
							exitZone(player)
						end
					end
				end
			end
		end
	end
end)

-- Monitor VIP zone access (check every 30 seconds for gamepass changes)
spawn(function()
	while true do
		wait(30)

		for player, currentZone in pairs(PlayerZones) do
			if player.Parent and currentZone then
				local zoneConfig = ShopConfig.Zones[currentZone]
				if zoneConfig and zoneConfig.IsVIP then
					-- Verify player still has VIP access
					if not hasRequiredGamepass(player, zoneConfig.RequiredGamepass) then
						debugPrint("Player " .. player.Name .. " lost VIP access to " .. currentZone)
						exitZone(player)

						-- Teleport them out (basic teleport)
						if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
							player.Character.HumanoidRootPart.CFrame = CFrame.new(0, 10, 0)
						end
					end
				end
			end
		end
	end
end)

-- Remote handlers
GetPlayerZoneRemote.OnServerInvoke = function(player)
	local zoneKey = PlayerZones[player]
	if zoneKey and ShopConfig.Zones and ShopConfig.Zones[zoneKey] then
		local zoneConfig = ShopConfig.Zones[zoneKey]
		return {
			zoneKey = zoneKey,
			zoneName = zoneConfig.Name,
			multiplier = zoneConfig.Multiplier,
			isVIP = zoneConfig.IsVIP or false
		}
	end
	return nil
end

-- Player events
Players.PlayerAdded:Connect(function(player)
	PlayerZones[player] = nil

	-- Check for unlocks when player joins
	spawn(function()
		wait(3) -- Wait for leaderstats to load  -  Edit
  12:31:15.410  		checkZoneUnlocks(player)

		-- If player has "Unlock All Zones" gamepass, unlock all zones immediately
		if hasUnlockAllZonesGamepass(player) then
			debugPrint(player.Name .. " has Unlock All Zones gamepass - unlocking all zones")
			for zoneKey, zoneConfig in pairs(ShopConfig.Zones) do
				if not zoneConfig.IsVIP then
					player:SetAttribute("UnlockedZone_" .. zoneKey, true)
				end
			end
		end
	end)
end)

Players.PlayerRemoving:Connect(function(player)
	PlayerZones[player] = nil
end)

-- Global functions
_G.ZoneSystem = {
	GetPlayerZoneMultiplier = getPlayerZoneMultiplier,
	GetPlayerZone = function(player) return PlayerZones[player] end,
	CanEnterZone = canEnterZone,
	CheckZoneUnlocks = checkZoneUnlocks,
	EnterZone = enterZone,
	ExitZone = exitZone,
	SetPlayerZone = setPlayerZone,
	HasRequiredGamepass = hasRequiredGamepass,
	HasUnlockAllZonesGamepass = hasUnlockAllZonesGamepass
}

debugPrint("ZoneSystem initialized successfully with VIP zone support!")

>>> game.ServerScriptService.leaderstats (Script) — 859 lines
-- LeaderstatsManager (ServerScript in ServerScriptService) - UPDATED WITH NEW EFFECTS
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DataStoreService = game:GetService("DataStoreService")
local RunService = game:GetService("RunService")

-- Get ShopConfig
local ShopConfig = require(ReplicatedStorage:WaitForChild("ShopConfig"))

-- Debug system
local function debugPrint(message)
	if ShopConfig.Debug.Enabled and ShopConfig.Debug.ShowLeaderstatsDebug then
		print("[LEADERSTATS]: " .. message)
	end
end

-- PRIORITY: Create RemoteEvents FIRST to prevent race conditions
local poopGainPopupEvent = Instance.new("RemoteEvent")
poopGainPopupEvent.Name = "PoopGainPopupEvent"
poopGainPopupEvent.Parent = ReplicatedStorage

local luckBonusTriggeredEvent = Instance.new("RemoteEvent")
luckBonusTriggeredEvent.Name = "LuckBonusTriggeredEvent"
luckBonusTriggeredEvent.Parent = ReplicatedStorage

-- Configuration
local Config = {
	BASE_POOBUCKS_PER_POOP = 1,
	STARTING_POOBUCKS = ShopConfig.StartingPooBucks or 100,
	STARTING_POOPS_POOPED = ShopConfig.StartingPoopsPooped or 0,
	STARTING_REBIRTHS = ShopConfig.StartingRebirths or 0,
	AUTO_SAVE_INTERVAL = 30,
	MAX_RETRIES = 3
}

-- DataStore Configuration
local LeaderstatsDataStore = DataStoreService:GetDataStore("LeaderstatsData_v2")
local BackupDataStore = DataStoreService:GetDataStore("LeaderstatsBackup_v2")

-- Player data storage
local PlayerData = {}

-- MEMORY MANAGEMENT
local connections = {}

local function cleanupConnections()
	for _, connection in pairs(connections) do
		if connection then
			connection:Disconnect()
		end
	end
	connections = {}
end

local function createDefaultPlayerData()
	return {
		PooBucks = Config.STARTING_POOBUCKS,
		TotalPoopsSpawned = Config.STARTING_POOPS_POOPED,
		Rebirths = Config.STARTING_REBIRTHS,
		LastLogin = tick(),
		PlayTime = 0,
		Stats = {
			TotalEarned = 0,
			TotalSpent = 0,
			HighestAmount = Config.STARTING_POOBUCKS,
			LifetimePoops = Config.STARTING_POOPS_POOPED
		},
		GroupRewards = {
			LastClaimed = 0,
			TotalClaimed = 0
		}
	}
end

-- DATA VALIDATION
local function validatePlayerData(data)
	local isValid = true
	local errors = {}

	-- Validate PooBucks
	if type(data.PooBucks) ~= "number" or data.PooBucks < 0 or data.PooBucks > 1e15 then
		data.PooBucks = math.max(0, math.min(data.PooBucks or 0, 1e15))
		table.insert(errors, "Invalid PooBucks")
		isValid = false
	end

	-- Validate TotalPoopsSpawned
	if type(data.TotalPoopsSpawned) ~= "number" or data.TotalPoopsSpawned < 0 then
		data.TotalPoopsSpawned = math.max(0, data.TotalPoopsSpawned or 0)
		table.insert(errors, "Invalid TotalPoopsSpawned")
		isValid = false
	end

	-- Validate Rebirths
	if type(data.Rebirths) ~= "number" or data.Rebirths < 0 then
		data.Rebirths = math.max(0, data.Rebirths or 0)
		table.insert(errors, "Invalid Rebirths")
		isValid = false
	end

	-- Validate Stats table
	if type(data.Stats) ~= "table" then
		data.Stats = {
			TotalEarned = 0,
			TotalSpent = 0,
			HighestAmount = data.PooBucks,
			LifetimePoops = data.TotalPoopsSpawned
		}
		table.insert(errors, "Invalid Stats")
		isValid = false
	end

	-- Validate GroupRewards table
	if type(data.GroupRewards) ~= "table" then
		data.GroupRewards = {
			HasClaimed = false,
			ClaimTime = 0,
			TotalClaimed = 0
		}
		table.insert(errors, "Invalid GroupRewards")
		isValid = false
	else
		if type(data.GroupRewards.HasClaimed) ~= "boolean" then
			data.GroupRewards.HasClaimed = false
		end
		if type(data.GroupRewards.ClaimTime) ~= "number" then
			data.GroupRewards.ClaimTime = 0
		end
		if type(data.GroupRewards.TotalClaimed) ~= "number" then
			data.GroupRewards.TotalClaimed = 0
		end
	end

	if not isValid then
		debugPrint("Data validation errors for player: " .. table.concat(errors, ", "))
	end

	return data
end

-- Function to get rebirth multiplier (ENHANCED WITH GAMEPASS BONUS)
local function getRebirthMultiplier(player)
	local data = PlayerData[player]
	if not data then return 1 end

	local rebirths = data.Rebirths or 0
	local baseMultiplierPerRebirth = ShopConfig.Rebirth.MultiplierPerRebirth or 0.5

	-- Check for rebirth multiplier gamepass
	local multiplierPerRebirth = baseMultiplierPerRebirth
	if _G.ShopPlayerData and _G.ShopPlayerData[player] and _G.ShopPlayerData[player].OwnedGamepasses then
		for _, gamepassKey in pairs(_G.ShopPlayerData[player].OwnedGamepasses) do
			local gamepassConfig = ShopConfig.Gamepasses[gamepassKey]
			if gamepassConfig and gamepassConfig.Effect == "RebirthBonus" then
				multiplierPerRebirth = baseMultiplierPerRebirth + gamepassConfig.Value -- 0.5 + 1.0 = 1.5 (100% more)
				debugPrint("Rebirth bonus gamepass active: +" .. (gamepassConfig.Value * 100) .. "% per rebirth")
				break
			end
		end
	end

	return 1 + (rebirths * multiplierPerRebirth)
end

-- Function to get zone multiplier (ENHANCED WITH VIP ZONE SUPPORT)
local function getZoneMultiplier(player)  -  Edit
  12:31:15.410  	if _G.ZoneSystem and _G.ZoneSystem.GetPlayerZoneMultiplier then
		return _G.ZoneSystem.GetPlayerZoneMultiplier(player)
	end
	return 1
end

-- NEW: Function to check luck bonuses from gamepasses and boosts
local function checkLuckBonuses(player, baseAmount)
	local finalAmount = baseAmount
	local luckTriggered = false
	local highestLuckMultiplier = 1

	-- Check gamepass luck bonuses
	if _G.ShopPlayerData and _G.ShopPlayerData[player] and _G.ShopPlayerData[player].OwnedGamepasses then
		for _, gamepassKey in pairs(_G.ShopPlayerData[player].OwnedGamepasses) do
			local gamepassConfig = ShopConfig.Gamepasses[gamepassKey]
			if gamepassConfig and gamepassConfig.Effect == "LuckBonus" then
				local chance = gamepassConfig.Chance or 0.05
				local multiplier = gamepassConfig.Value or 1.5

				if math.random() < chance then
					debugPrint("Luck bonus triggered! " .. gamepassKey .. " - " .. multiplier .. "x")
					if multiplier > highestLuckMultiplier then
						highestLuckMultiplier = multiplier
						luckTriggered = true
					end
				end
			end
		end
	end

	-- Check boost luck bonuses
	if _G.BoostSystem and _G.BoostSystem.GetPlayerBoosts then
		local playerBoosts = _G.BoostSystem.GetPlayerBoosts(player)
		for boostKey, boostData in pairs(playerBoosts) do
			if boostData.effect == "LuckBonus" then
				local config = ShopConfig.Boosts[boostKey]
				if config then
					local chance = config.Chance or 0.05
					local multiplier = config.Value or 1.5

					if math.random() < chance then
						debugPrint("Luck boost triggered! " .. boostKey .. " - " .. multiplier .. "x")
						if multiplier > highestLuckMultiplier then
							highestLuckMultiplier = multiplier
							luckTriggered = true
						end
					end
				end
			end
		end
	end

	if luckTriggered then
		finalAmount = math.floor(baseAmount * highestLuckMultiplier)

		-- Play luck sound and show effect to client
		luckBonusTriggeredEvent:FireClient(player, highestLuckMultiplier, finalAmount - baseAmount)

		debugPrint("Luck bonus applied: " .. baseAmount .. " -> " .. finalAmount .. " (x" .. highestLuckMultiplier .. ")")
	end

	return finalAmount
end

-- ENHANCED: Function to get equipped poop gain with NEW STACKING LOGIC
local function getEquippedPoopGain(player)
	local baseGain = Config.BASE_POOBUCKS_PER_POOP

	-- Get base poop gain
	if _G.ShopPlayerData and _G.ShopPlayerData[player] then
		local equippedPoop = _G.ShopPlayerData[player].EquippedPoop
		if equippedPoop and ShopConfig.Poops[equippedPoop] then
			baseGain = ShopConfig.Poops[equippedPoop].Gain or Config.BASE_POOBUCKS_PER_POOP
		end
	end

	local totalMultiplier = 1

	-- Apply boost multipliers
	if _G.BoostSystem and _G.BoostSystem.GetEffectMultiplier then
		totalMultiplier = totalMultiplier * _G.BoostSystem.GetEffectMultiplier(player, "CurrencyMultiplier")
	end

	-- FIXED: Apply gamepass multipliers (ADDITIVE STACKING as requested)
	if _G.ShopPlayerData and _G.ShopPlayerData[player] and _G.ShopPlayerData[player].OwnedGamepasses then
		local gamepassMultiplier = 0 -- Start at 0 for additive stacking
		for _, gamepassKey in pairs(_G.ShopPlayerData[player].OwnedGamepasses) do
			local gamepassConfig = ShopConfig.Gamepasses[gamepassKey]
			if gamepassConfig and gamepassConfig.Effect == "CurrencyMultiplier" then
				gamepassMultiplier = gamepassMultiplier + gamepassConfig.Value -- Add values together
				debugPrint("Added gamepass multiplier: " .. gamepassKey .. " = " .. gamepassConfig.Value)
			end
		end

		if gamepassMultiplier > 0 then
			totalMultiplier = totalMultiplier * gamepassMultiplier
			debugPrint("Total gamepass multiplier: " .. gamepassMultiplier .. "x")
		end
	end

	-- Apply rebirth multiplier
	totalMultiplier = totalMultiplier * getRebirthMultiplier(player)

	-- Apply zone multiplier
	totalMultiplier = totalMultiplier * getZoneMultiplier(player)

	local finalGain = baseGain * totalMultiplier

	-- Apply luck bonuses after all other calculations
	finalGain = checkLuckBonuses(player, finalGain)

	return math.floor(finalGain)
end

local SyncLocks = {}

local function syncWithShopSystem(player)
	if SyncLocks[player] then return end
	SyncLocks[player] = true

	if _G.ShopPlayerData and _G.ShopPlayerData[player] then
		local shopData = _G.ShopPlayerData[player]
		local leaderstatsData = PlayerData[player]

		if shopData and leaderstatsData and shopData.PooBucks and leaderstatsData.PooBucks then
			if math.abs(shopData.PooBucks - leaderstatsData.PooBucks) > 0.01 then
				debugPrint("SYNC: Updating leaderstats data from " .. leaderstatsData.PooBucks .. " to " .. shopData.PooBucks)
				leaderstatsData.PooBucks = shopData.PooBucks
				updateLeaderstats(player)
			end
		end
	end

	SyncLocks[player] = nil
end

-- Enhanced sync function
local function syncWithShopSystem(player)
	if _G.ShopPlayerData and _G.ShopPlayerData[player] then
		local shopData = _G.ShopPlayerData[player]
		local leaderstatsData = PlayerData[player]

		if shopData and leaderstatsData and shopData.PooBucks and leaderstatsData.PooBucks then
			if math.abs(shopData.PooBucks - leaderstatsData.PooBucks) > 0.01 then
				debugPrint("SYNC: Updating leaderstats data from " .. leaderstatsData.PooBucks .. " to " .. shopData.PooBucks)
				leaderstatsData.PooBucks = shopData.PooBucks
				updateLeaderstats(player)
			end
		end
	end
end

-- Enhanced database functions with retry logic
local function savePlayerData(player, isBackup, retries)
	retries = retries or Config.MAX_RETRIES
	syncWithShopSystem(player)

	local data = PlayerData[player]
	if not data then return false end

	-- Validate before saving
	data = validatePlayerData(data)

	local playerKey = "Leaderstats_" .. player.UserId
	local dataStore = isBackup and BackupDataStore or LeaderstatsDataStore

	for attempt = 1, retries do
		local success, err = pcall(function()
			dataStore:SetAsync(playerKey, data)
		end)

		if success then
			if not isBackup then
				debugPrint("Saved leaderstats for " .. player.Name)
			end

			-- Save backup if this was the main save
			if not isBackup then
				spawn(function()
					savePlayerData(player, true, 1) -- Single retry for backup
				end)
			end

			return true
		else
			warn("Failed to save leaderstats for " .. player.Name .. " (Attempt " .. attempt .. "): " .. err)
			if attempt < retries then
				wait(1)
			end
		end
	end

	return false
end

local function loadPlayerData(player)
	local playerKey = "Leaderstats_" .. player.UserId
	local attempts = 0
	local data = nil  -  Edit
  12:31:15.411  
	while attempts < Config.MAX_RETRIES do
		attempts = attempts + 1

		local s, result = pcall(function()
			return LeaderstatsDataStore:GetAsync(playerKey)
		end)

		if s then
			data = result
			break
		else
			warn("Failed to load leaderstats for " .. player.Name .. " (Attempt " .. attempts .. "): " .. result)
			if attempts < Config.MAX_RETRIES then
				wait(1)
			end
		end
	end

	if not data then
		warn("Attempting to load backup leaderstats for " .. player.Name)
		local s, result = pcall(function()
			return BackupDataStore:GetAsync(playerKey)
		end)

		if s and result then
			data = result
			warn("Loaded backup leaderstats for " .. player.Name)
		end
	end

	if not data then
		data = createDefaultPlayerData()
		warn("Using default leaderstats for " .. player.Name)
	else
		data = validatePlayerData(data)
		local defaultData = createDefaultPlayerData()
		for key, value in pairs(defaultData) do
			if data[key] == nil then
				data[key] = value
			elseif type(data[key]) == "table" and type(value) == "table" then
				for subKey, subValue in pairs(value) do
					if data[key][subKey] == nil then
						data[key][subKey] = subValue
					end
				end
			end
		end
	end

	if data.PooBucks < 0 then
		data.PooBucks = 0
	end

	return data
end

-- Leaderstats Functions
function updateLeaderstats(player)
	local leaderstats = player:FindFirstChild("leaderstats")
	local data = PlayerData[player]

	if leaderstats and data then
		local pooBucks = leaderstats:FindFirstChild("PooBucks")
		if pooBucks then
			pooBucks.Value = data.PooBucks
		end

		local poopsPooped = leaderstats:FindFirstChild("Poops")
		if poopsPooped then
			poopsPooped.Value = data.TotalPoopsSpawned
		end

		local rebirths = leaderstats:FindFirstChild("Rebirths")
		if rebirths then
			rebirths.Value = data.Rebirths
		end
	end
end

local function createLeaderstats(player)
	PlayerData[player] = loadPlayerData(player)

	local leaderstats = Instance.new("Folder")
	leaderstats.Name = "leaderstats"
	leaderstats.Parent = player

	local pooBucks = Instance.new("IntValue")
	pooBucks.Name = "PooBucks"
	pooBucks.Value = PlayerData[player].PooBucks
	pooBucks.Parent = leaderstats

	local poopsPooped = Instance.new("IntValue")
	poopsPooped.Name = "Poops"
	poopsPooped.Value = PlayerData[player].TotalPoopsSpawned
	poopsPooped.Parent = leaderstats

	local rebirths = Instance.new("IntValue")
	rebirths.Name = "Rebirths"
	rebirths.Value = PlayerData[player].Rebirths
	rebirths.Parent = leaderstats

	debugPrint("Created leaderstats for " .. player.Name)
end

-- Enhanced givePooBucks function
local function givePooBucks(player, customAmount, reason, skipLuck)
	syncWithShopSystem(player)

	local data = PlayerData[player]
	if not data then return false end

	local amount = customAmount or getEquippedPoopGain(player)
	reason = reason or "Poop spawned"

	if amount <= 0 then return false end

	-- Skip luck bonuses for auto poop and custom amounts unless specified
	if not skipLuck and not customAmount then
		amount = checkLuckBonuses(player, amount)
	end

	data.PooBucks = data.PooBucks + amount
	data.Stats.TotalEarned = data.Stats.TotalEarned + amount

	if data.PooBucks > data.Stats.HighestAmount then
		data.Stats.HighestAmount = data.PooBucks
	end

	-- Update shop system too
	if _G.ShopPlayerData and _G.ShopPlayerData[player] then
		_G.ShopPlayerData[player].PooBucks = data.PooBucks
	end

	-- Show popup for significant gains
	if customAmount and customAmount > 0 and reason ~= "Poop spawned" then
		if poopGainPopupEvent then
			local success, error = pcall(function()
				poopGainPopupEvent:FireClient(player, customAmount)
			end)

			if success then
				debugPrint("Fired PooBucks popup event for " .. player.Name .. " - Amount: " .. customAmount)
			else
				debugPrint("Failed to fire popup event: " .. tostring(error))
			end
		else
			debugPrint("ERROR: poopGainPopupEvent is nil!")
		end
	end

	updateLeaderstats(player)
	return true, amount
end

local function spendPooBucks(player, amount, reason)
	syncWithShopSystem(player)

	local data = PlayerData[player]
	if not data then return false, "Player data not found" end

	reason = reason or "Purchase"

	if data.PooBucks < amount then
		return false, "Insufficient PooBucks"
	end

	data.PooBucks = data.PooBucks - amount
	data.Stats.TotalSpent = data.Stats.TotalSpent + amount

	-- Update shop system too
	if _G.ShopPlayerData and _G.ShopPlayerData[player] then
		_G.ShopPlayerData[player].PooBucks = data.PooBucks
	end

	updateLeaderstats(player)

	debugPrint("Spent " .. amount .. " PooBucks for " .. player.Name .. " (" .. reason .. ")")
	return true, "Purchase successful"
end

local function getPlayerCurrency(player)
	syncWithShopSystem(player)
	local data = PlayerData[player]
	return data and data.PooBucks or 0
end

-- Rebirth functions
local function getRebirthCost(player)
	local data = PlayerData[player]
	if not data then return math.huge end

	local rebirths = data.Rebirths or 0
	local baseCost = ShopConfig.Rebirth.BaseCost
	local multiplier = ShopConfig.Rebirth.CostMultiplier

	return math.floor(baseCost * (multiplier ^ rebirths))
end

local function canRebirth(player)  -  Edit
  12:31:15.411  	local data = PlayerData[player]
	if not data then return false, "No player data" end

	local cost = getRebirthCost(player)

	if ShopConfig.Rebirth.Requirements.MinPooBucks and data.PooBucks < cost then
		return false, "Insufficient PooBucks (Need " .. cost .. ")"
	end

	if ShopConfig.Rebirth.MaxRebirths > 0 and data.Rebirths >= ShopConfig.Rebirth.MaxRebirths then
		return false, "Maximum rebirths reached"
	end

	return true, "Can rebirth"
end

local function performRebirth(player)
	local data = PlayerData[player]
	if not data then return false, "No player data" end

	local canDo, reason = canRebirth(player)
	if not canDo then
		return false, reason
	end

	-- Reset data based on config
	if ShopConfig.Rebirth.ResetData.PooBucks then
		data.PooBucks = Config.STARTING_POOBUCKS
	end

	-- Increment rebirths
	data.Rebirths = data.Rebirths + 1

	-- Update leaderstats and shop system
	if _G.ShopPlayerData and _G.ShopPlayerData[player] then
		_G.ShopPlayerData[player].PooBucks = data.PooBucks

		-- Reset shop data if needed
		if ShopConfig.Rebirth.ResetData.OwnedPoops then
			_G.ShopPlayerData[player].OwnedPoops = {ShopConfig.DefaultPoop}
			_G.ShopPlayerData[player].EquippedPoop = ShopConfig.DefaultPoop
		end

		if ShopConfig.Rebirth.ResetData.OwnedUpgrades then
			_G.ShopPlayerData[player].OwnedUpgrades = {}
		end
	end

	updateLeaderstats(player)
	savePlayerData(player)

	debugPrint(player.Name .. " rebirthed! New rebirth count: " .. data.Rebirths)
	return true, "Rebirth successful! New multiplier: " .. string.format("%.1f", getRebirthMultiplier(player)) .. "x"
end


-- Create RemoteEvents
local poopSpawnedEvent = Instance.new("RemoteEvent")
poopSpawnedEvent.Name = "PoopSpawnedEvent"
poopSpawnedEvent.Parent = ReplicatedStorage

local getCurrencyRemote = Instance.new("RemoteFunction")
getCurrencyRemote.Name = "GetPlayerCurrency"
getCurrencyRemote.Parent = ReplicatedStorage

local spendCurrencyRemote = Instance.new("RemoteFunction")
spendCurrencyRemote.Name = "SpendPlayerCurrency"
spendCurrencyRemote.Parent = ReplicatedStorage

local rebirthRequestRemote = Instance.new("RemoteFunction")
rebirthRequestRemote.Name = "RebirthRequest"
rebirthRequestRemote.Parent = ReplicatedStorage

local getRebirthInfoRemote = Instance.new("RemoteFunction")
getRebirthInfoRemote.Name = "GetRebirthInfo"
getRebirthInfoRemote.Parent = ReplicatedStorage

-- ENHANCED: Production multiplier calculation with gamepass support
local function getPlayerProductionMultiplier(player)
	local data = PlayerData[player]
	if not data then return 1 end

	local baseProductionValue = 1

	-- Get highest upgrade value (upgrades REPLACE each other)
	if _G.ShopPlayerData and _G.ShopPlayerData[player] and _G.ShopPlayerData[player].OwnedUpgrades then
		for _, upgradeKey in pairs(_G.ShopPlayerData[player].OwnedUpgrades) do
			local upgradeConfig = ShopConfig.Upgrades[upgradeKey]
			if upgradeConfig and upgradeConfig.Effect == "ProductionMultiplier" then
				if upgradeConfig.Value > baseProductionValue then
					baseProductionValue = upgradeConfig.Value
					debugPrint("Server found production upgrade: " .. upgradeKey .. " with value " .. upgradeConfig.Value)
				end
			end
		end
	end

	local totalMultiplier = baseProductionValue

	-- Apply gamepass multipliers (these MULTIPLY with upgrade base)
	if _G.ShopPlayerData and _G.ShopPlayerData[player] and _G.ShopPlayerData[player].OwnedGamepasses then
		local gamepassMultiplier = 1
		for _, gamepassKey in pairs(_G.ShopPlayerData[player].OwnedGamepasses) do
			local gamepassConfig = ShopConfig.Gamepasses[gamepassKey]
			if gamepassConfig and gamepassConfig.Effect == "ProductionMultiplier" then
				gamepassMultiplier = gamepassMultiplier * gamepassConfig.Value
				debugPrint("Applied production gamepass: " .. gamepassKey .. " = " .. gamepassConfig.Value .. "x")
			end
		end
		totalMultiplier = totalMultiplier * gamepassMultiplier
	end

	-- Apply boost multipliers
	if _G.BoostSystem and _G.BoostSystem.GetEffectMultiplier then
		local boostMultiplier = _G.BoostSystem.GetEffectMultiplier(player, "ProductionMultiplier")
		totalMultiplier = totalMultiplier * boostMultiplier
	end

	-- Apply additive boost bonuses
	if _G.BoostSystem and _G.BoostSystem.GetPlayerBoosts then
		local additiveBonus = 0
		local playerBoosts = _G.BoostSystem.GetPlayerBoosts(player)
		for _, boostData in pairs(playerBoosts) do
			if boostData.effect == "ProductionAdditive" then
				additiveBonus = additiveBonus + boostData.value
			end
		end
		totalMultiplier = totalMultiplier + additiveBonus
	end

	debugPrint("Server calculated production multiplier for " .. player.Name .. ": " .. totalMultiplier)
	return totalMultiplier
end

-- Add production multiplier remote
local GetProductionMultiplierRemote = Instance.new("RemoteFunction")
GetProductionMultiplierRemote.Name = "GetProductionMultiplierRemote"
GetProductionMultiplierRemote.Parent = ReplicatedStorage

GetProductionMultiplierRemote.OnServerInvoke = function(player)
	return getPlayerProductionMultiplier(player)
end

-- ENHANCED: Poop spawned event handler with new production logic
table.insert(connections, poopSpawnedEvent.OnServerEvent:Connect(function(player)
	if player and player.Character then
		local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
		if humanoid and humanoid.Health > 0 then
			local data = PlayerData[player]
			if data then
				local productionMultiplier = getPlayerProductionMultiplier(player)
				local poopsToSpawn = math.floor(productionMultiplier)
				local totalAmountGained = 0

				debugPrint("Spawning " .. poopsToSpawn .. " poops for " .. player.Name .. " (multiplier: " .. productionMultiplier .. ")")

				for i = 1, poopsToSpawn do
					-- Increment poops pooped count
					data.TotalPoopsSpawned = data.TotalPoopsSpawned + 1
					data.Stats.LifetimePoops = data.Stats.LifetimePoops + 1

					local success, amountGained = givePooBucks(player, nil, "Poop spawned")

					if success and amountGained then
						totalAmountGained = totalAmountGained + amountGained
					end
				end

				-- Update leaderstats to reflect new poops pooped count
				updateLeaderstats(player)

				-- Fire popup event
				if totalAmountGained > 0 then
					poopGainPopupEvent:FireClient(player, totalAmountGained)
				end

				-- Check for zone unlock notifications
				if _G.ZoneSystem and _G.ZoneSystem.CheckZoneUnlocks then
					_G.ZoneSystem.CheckZoneUnlocks(player)
				end
			end
		end
	end
end))

getCurrencyRemote.OnServerInvoke = function(player)
	return getPlayerCurrency(player)
end

spendCurrencyRemote.OnServerInvoke = function(player, amount, reason)
	return spendPooBucks(player, amount, reason)
end

rebirthRequestRemote.OnServerInvoke = function(player)
	return performRebirth(player)
end

getRebirthInfoRemote.OnServerInvoke = function(player)
	local data = PlayerData[player]
	if not data then return nil end  -  Edit
  12:31:15.411  
	local cost = getRebirthCost(player)
	local currentMultiplier = getRebirthMultiplier(player)
	local nextMultiplier = 1 + ((data.Rebirths + 1) * ShopConfig.Rebirth.MultiplierPerRebirth)
	local canDo, reason = canRebirth(player)

	return {
		currentRebirths = data.Rebirths,
		rebirthCost = cost,
		currentMultiplier = currentMultiplier,
		nextMultiplier = nextMultiplier,
		canRebirth = canDo,
		reason = reason,
		currentPooBucks = data.PooBucks,
		percentage = math.min(100, (data.PooBucks / cost) * 100)
	}
end

-- Player Events
table.insert(connections, Players.PlayerAdded:Connect(function(player)
	createLeaderstats(player)

	-- Track the save connection
	local saveConnection = spawn(function()
		while player.Parent do
			wait(Config.AUTO_SAVE_INTERVAL)
			if PlayerData[player] then
				savePlayerData(player)
			end
		end
	end)

	-- Store connection for cleanup
	connections[player] = saveConnection
end))

table.insert(connections, Players.PlayerRemoving:Connect(function(player)
	if PlayerData[player] then
		savePlayerData(player)
		PlayerData[player] = nil
	end

	-- Clean up player-specific connection
	if connections[player] then
		connections[player]:Disconnect()
		connections[player] = nil
	end
end))


for _, player in pairs(Players:GetPlayers()) do
	createLeaderstats(player)
end

spawn(function()
	while true do
		wait(Config.AUTO_SAVE_INTERVAL * 2)
		for player, _ in pairs(PlayerData) do
			if player.Parent then
				savePlayerData(player)
			end
		end
	end
end)

game:BindToClose(function()
	debugPrint("Server shutting down - saving all leaderstats...")
	for player, _ in pairs(PlayerData) do
		savePlayerData(player)
	end
	cleanupConnections()
	wait(3)
	debugPrint("All leaderstats saved!")
end)

_G.LeaderstatsManager = {
	GetPlayerCurrency = getPlayerCurrency,
	SpendCurrency = spendPooBucks,
	GiveCurrency = givePooBucks,
	GetPlayerData = function(player)
		syncWithShopSystem(player)
		return PlayerData[player]
	end,
	UpdateLeaderstats = updateLeaderstats,
	SyncWithShopSystem = syncWithShopSystem,
	GetRebirthMultiplier = getRebirthMultiplier,
	GetRebirthCost = getRebirthCost,
	CanRebirth = canRebirth,
	PerformRebirth = performRebirth,
	GetPlayerProductionMultiplier = getPlayerProductionMultiplier
}

debugPrint("LeaderstatsManager initialized with new gamepass effects!")

>>> game.StarterGui.BoostsGui.BoostsScript (LocalScript) — 357 lines
-- BoostsGui LocalScript (in StarterGui.BoostsGui) - SIMPLE LOCK SYSTEM NO DIALOG
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local mouse = player:GetMouse()
local boostsGui = script.Parent
local playerGui = player:WaitForChild("PlayerGui")

-- DEBUG SYSTEM
local DEBUG = true
local function debugPrint(message)
	if DEBUG then
		print("[BOOSTS GUI DEBUG]: " .. message)
	end
end

-- Wait for ShopConfig
local ShopConfig
spawn(function()
	ShopConfig = require(ReplicatedStorage:WaitForChild("ShopConfig"))
	debugPrint("ShopConfig loaded")
end)

-- GUI References
local background = boostsGui:WaitForChild("Background")
local hoverFrame = boostsGui:WaitForChild("HoverFrame")
local descriptionLabel = hoverFrame:WaitForChild("Description")
local timeLeftLabel = hoverFrame:WaitForChild("TimeLeft")

-- Boost Templates
local boostTemplate1 = background:WaitForChild("BoostTemplate1")
local boostTemplate2 = background:WaitForChild("BoostTemplate2")
local boostTemplate3 = background:WaitForChild("BoostTemplate3")
local boostTemplate4 = background:WaitForChild("BoostTemplate4")

local boostTemplates = {boostTemplate1, boostTemplate2, boostTemplate3, boostTemplate4}

-- Setup template properties
for i, template in pairs(boostTemplates) do
	template.Visible = false
	template.Active = true
	template.Image = ""
	template.ScaleType = Enum.ScaleType.Fit
	template.ImageColor3 = Color3.new(1, 1, 1)
	template.BackgroundTransparency = 1
	template.BorderSizePixel = 2
	template.BorderColor3 = Color3.new(1, 1, 1)
	debugPrint("Setup boost template " .. i .. ": " .. template.Name)
end

-- Wait for RemoteEvents
local BoostActivatedEvent = ReplicatedStorage:WaitForChild("BoostActivatedEvent")
local GetActiveBoostsRemote = ReplicatedStorage:WaitForChild("GetActiveBoostsRemote")
local BoostUpdatedEvent = ReplicatedStorage:WaitForChild("BoostUpdatedEvent")

-- Active boosts storage
local activeBoosts = {}
local hoverConnections = {}
local updateConnections = {}

-- Initialize
hoverFrame.Visible = false

debugPrint("BoostsGui initialized with simple lock system")

-- Function to count active boost types
local function countActiveBoostTypes()
	local count = 0
	for _ in pairs(activeBoosts) do
		count = count + 1
	end
	return count
end

-- HOVER EFFECTS AND ANIMATION FUNCTIONS
local function createHoverTween(button, isEntering)
	local targetScale = isEntering and 0.9 or 1.0
	local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)

	return TweenService:Create(button, tweenInfo, {
		Size = UDim2.new(targetScale, 0, targetScale, 0)
	})
end

local function updateHoverFramePosition()
	if hoverFrame.Visible then
		local mouseX = mouse.X
		local mouseY = mouse.Y
		local offsetX = 10
		local offsetY = -50

		local screenSize = workspace.CurrentCamera.ViewportSize
		local frameSize = hoverFrame.AbsoluteSize

		if mouseX + frameSize.X + offsetX > screenSize.X then
			offsetX = -frameSize.X - 10
		end
		if mouseY + offsetY < 0 then
			offsetY = 10
		end
  -  Edit
  12:31:15.412  		hoverFrame.Position = UDim2.new(0, mouseX + offsetX, 0, mouseY + offsetY)
	end
end

-- BOOST MANAGEMENT FUNCTIONS
local function formatTime(seconds)
	local minutes = math.floor(seconds / 60)
	local remainingSeconds = seconds % 60
	return string.format("%d:%02d", minutes, remainingSeconds)
end

local function findAvailableTemplate()
	for _, template in pairs(boostTemplates) do
		if not template.Visible then
			debugPrint("Found available template: " .. template.Name)
			return template
		end
	end
	debugPrint("ERROR: No available boost templates!")
	return nil
end

local function setupBoostTemplate(template, boostKey, boostData, timeLeft)
	debugPrint("Setting up boost template for: " .. boostKey)

	if not ShopConfig then
		debugPrint("ERROR: ShopConfig not loaded yet!")
		return
	end

	local config = ShopConfig.Boosts[boostKey]
	if not config then
		debugPrint("ERROR: Boost config not found for " .. boostKey)
		return
	end

	-- Set boost image
	if config.Image and config.Image ~= "" then
		template.Image = config.Image
		debugPrint("Set boost image: " .. config.Image)
	else
		debugPrint("WARNING: No image configured for boost " .. boostKey)
		template.BackgroundTransparency = 0.5
		template.BackgroundColor3 = Color3.new(1, 0, 0)
	end

	-- Store boost data
	template:SetAttribute("BoostKey", boostKey)
	template:SetAttribute("TimeLeft", timeLeft)

	-- Make visible
	template.Visible = true
	debugPrint("Template " .. template.Name .. " is now visible with boost " .. boostKey)

	-- Clear existing connections
	if hoverConnections[template] then
		for _, connection in pairs(hoverConnections[template]) do
			connection:Disconnect()
		end
	end
	hoverConnections[template] = {}

	-- Setup hover effects
	table.insert(hoverConnections[template], template.MouseEnter:Connect(function()
		debugPrint("Mouse entered boost template: " .. boostKey)

		if config then
			descriptionLabel.Text = config.Description or "Boost Effect"
			timeLeftLabel.Text = formatTime(template:GetAttribute("TimeLeft") or 0)
			hoverFrame.Visible = true
		end

		local hoverTween = createHoverTween(template, true)
		hoverTween:Play()
	end))

	table.insert(hoverConnections[template], template.MouseLeave:Connect(function()
		debugPrint("Mouse left boost template: " .. boostKey)
		hoverFrame.Visible = false

		local hoverTween = createHoverTween(template, false)
		hoverTween:Play()
	end))

	-- Setup click for mobile
	table.insert(hoverConnections[template], template.MouseButton1Click:Connect(function()
		debugPrint("Clicked boost template: " .. boostKey)

		if config then
			descriptionLabel.Text = config.Description or "Boost Effect"
			timeLeftLabel.Text = formatTime(template:GetAttribute("TimeLeft") or 0)

			local mouseX = mouse.X
			local mouseY = mouse.Y
			hoverFrame.Position = UDim2.new(0, mouseX + 10, 0, mouseY - 50)
			hoverFrame.Visible = true

			spawn(function()
				wait(3)
				if hoverFrame.Visible then
					hoverFrame.Visible = false
				end
			end)
		end
	end))

	-- Start time update for this template
	if updateConnections[template] then
		updateConnections[template]:Disconnect()
	end

	updateConnections[template] = RunService.Heartbeat:Connect(function(deltaTime)
		local currentTime = template:GetAttribute("TimeLeft") or 0
		if currentTime <= 0 then
			debugPrint("Boost expired: " .. boostKey)
			template.Visible = false
			template.BackgroundTransparency = 1
			template.BackgroundColor3 = Color3.new(1, 1, 1)
			if hoverFrame.Visible then
				hoverFrame.Visible = false
			end
			updateConnections[template]:Disconnect()
			updateConnections[template] = nil
			activeBoosts[boostKey] = nil
		else
			template:SetAttribute("TimeLeft", currentTime - deltaTime)

			if hoverFrame.Visible and template:GetAttribute("BoostKey") == boostKey then
				timeLeftLabel.Text = formatTime(currentTime)
			end
		end
	end)

	debugPrint("Boost template setup complete for: " .. boostKey)
end

local function addOrStackBoost(boostKey, duration)
	debugPrint("Adding/stacking boost: " .. boostKey .. " for " .. duration .. " seconds")

	if not ShopConfig then
		debugPrint("ERROR: ShopConfig not loaded, waiting...")
		wait(1)
		if not ShopConfig then
			debugPrint("ERROR: ShopConfig still not loaded!")
			return
		end
	end

	local config = ShopConfig.Boosts[boostKey]
	if not config then
		debugPrint("ERROR: Boost config not found for " .. boostKey)
		return
	end

	-- Check if boost already exists (stacking)
	if activeBoosts[boostKey] then
		debugPrint("Stacking boost: " .. boostKey)
		local existingTemplate = activeBoosts[boostKey].template
		local currentTime = existingTemplate:GetAttribute("TimeLeft") or 0
		local newTime = currentTime + duration

		existingTemplate:SetAttribute("TimeLeft", newTime)
		activeBoosts[boostKey].timeLeft = newTime
	else
		debugPrint("Creating new boost: " .. boostKey)
		local template = findAvailableTemplate()
		if not template then
			debugPrint("ERROR: No available boost templates!")
			return
		end

		activeBoosts[boostKey] = {
			template = template,
			timeLeft = duration,
			config = config
		}

		setupBoostTemplate(template, boostKey, config, duration)
		debugPrint("Created new boost " .. boostKey .. " - Duration: " .. formatTime(duration))
	end
end

-- EVENT HANDLERS
BoostActivatedEvent.OnClientEvent:Connect(function(boostKey, duration)
	debugPrint("Boost activated event received: " .. boostKey .. " for " .. duration .. " seconds")
	addOrStackBoost(boostKey, duration)
end)

BoostUpdatedEvent.OnClientEvent:Connect(function(boostKey, newTimeLeft)
	debugPrint("Boost updated event received: " .. boostKey .. " - New time: " .. newTimeLeft)

	if activeBoosts[boostKey] and activeBoosts[boostKey].template then
		activeBoosts[boostKey].template:SetAttribute("TimeLeft", newTimeLeft)
		activeBoosts[boostKey].timeLeft = newTimeLeft
	end
end)

-- MOUSE MOVEMENT FOR HOVER FRAME
RunService.Heartbeat:Connect(updateHoverFramePosition)
  -  Edit
  12:31:15.412  -- INITIALIZATION - Load existing boosts
spawn(function()
	wait(3)

	debugPrint("Loading existing active boosts...")
	local success, boosts = pcall(function()
		return GetActiveBoostsRemote:InvokeServer()
	end)

	if success and boosts then
		debugPrint("Loaded " .. #boosts .. " active boosts")
		for _, boostData in pairs(boosts) do
			if boostData.timeLeft > 0 then
				debugPrint("Loading boost: " .. boostData.boostKey .. " with " .. boostData.timeLeft .. " seconds")
				addOrStackBoost(boostData.boostKey, boostData.timeLeft)
			end
		end
	else
		debugPrint("Failed to load active boosts or no boosts active")
	end
end)

-- GLOBAL FUNCTION FOR SHOP SYSTEM TO CHECK BOOST LIMIT
_G.BoostGuiData = {
	CountActiveBoosts = countActiveBoostTypes,
	MaxBoosts = 4,
	IsAtLimit = function()
		return countActiveBoostTypes() >= 4
	end,
	HasBoost = function(boostKey)
		return activeBoosts[boostKey] ~= nil
	end
}

-- CLEANUP
Players.PlayerRemoving:Connect(function(removingPlayer)
	if removingPlayer == player then
		for _, connections in pairs(hoverConnections) do
			for _, connection in pairs(connections) do
				connection:Disconnect()
			end
		end

		for _, connection in pairs(updateConnections) do
			if connection then
				connection:Disconnect()
			end
		end
	end
end)

debugPrint("BoostsGui script loaded with simple lock system!")

>>> game.StarterGui.CurrencyGui.Background.PooBucks.CurrencyUpdaterScript (LocalScript) — 121 lines
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local player = Players.LocalPlayer

local label = script.Parent
local currentDisplayValue = 0

-- Store original size to prevent scaling issues
local originalSize = label.Size

-- Keep track of current scale tweens
local currentScaleTweens = {}

local function formatNumber(num)
	if num >= 1e9 then
		return string.format("%.1fB", num / 1e9)
	elseif num >= 1e6 then
		return string.format("%.1fM", num / 1e6)
	elseif num >= 1e3 then
		return string.format("%.1fk", num / 1e3)
	else
		return tostring(math.floor(num))
	end
end

local function smoothCountTo(targetValue)
	local startValue = currentDisplayValue
	local difference = targetValue - startValue

	-- Don't animate if the difference is too small or if it's the initial load
	if math.abs(difference) <= 1 or startValue == 0 then
		currentDisplayValue = targetValue
		label.Text = formatNumber(targetValue) .. "$"
		return
	end

	-- Cancel any existing scale tweens
	for _, tween in pairs(currentScaleTweens) do
		tween:Cancel()
	end
	currentScaleTweens = {}

	-- Reset to original size before scaling
	label.Size = originalSize

	-- Create scaling effect when value changes (always relative to original size)
	local scaleInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
	local scaleUpTween = TweenService:Create(label, scaleInfo, {
		Size = UDim2.new(originalSize.X.Scale * 1.1, 0, originalSize.Y.Scale * 1.1, 0)
	})
	local scaleDownTween = TweenService:Create(label, scaleInfo, {
		Size = originalSize
	})

	-- Store current tweens
	currentScaleTweens[1] = scaleUpTween
	currentScaleTweens[2] = scaleDownTween

	-- Brief color flash for positive changes
	if difference > 0 then
		local colorInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
		local colorTween = TweenService:Create(label, colorInfo, {TextColor3 = Color3.fromRGB(208, 201, 0)})
		local colorBackTween = TweenService:Create(label, colorInfo, {TextColor3 = Color3.fromRGB(255, 255, 255)})

		colorTween:Play()
		colorTween.Completed:Connect(function()
			colorBackTween:Play()
		end)
	end

	-- Play scale animation
	scaleUpTween:Play()
	scaleUpTween.Completed:Connect(function()
		scaleDownTween:Play()
		scaleDownTween.Completed:Connect(function()
			-- Ensure we're back to original size
			label.Size = originalSize
		end)
	end)

	-- Smooth counting animation
	local duration = math.min(1, math.max(0.3, math.log(math.abs(difference)) * 0.1))
	local steps = math.min(60, math.max(10, math.abs(difference)))
	local stepTime = duration / steps

	local connection
	local currentStep = 0

	connection = game:GetService("RunService").Heartbeat:Connect(function()
		currentStep = currentStep + 1
		local progress = currentStep / steps

		-- Use easing for smooth animation
		local easedProgress = 1 - math.pow(1 - progress, 3) -- Ease out cubic

		currentDisplayValue = startValue + (difference * easedProgress)
		label.Text = formatNumber(currentDisplayValue) .. "$"

		if currentStep >= steps then
			currentDisplayValue = targetValue
			label.Text = formatNumber(targetValue) .. "$"
			connection:Disconnect()
		end
	end)
end

local function updateLabel()
	local leaderstats = player:WaitForChild("leaderstats")
	local pooBucks = leaderstats:WaitForChild("PooBucks")

	-- Set initial value
	currentDisplayValue = pooBucks.Value
	label.Text = formatNumber(pooBucks.Value) .. "$"

	-- Update smoothly every time the value changes
	pooBucks:GetPropertyChangedSignal("Value"):Connect(function()
		smoothCountTo(pooBucks.Value)
	end)
end

updateLabel()

>>> game.StarterGui.CurrencyGui.TimesPoopedBG.TimesPooped.CurrencyUpdaterScript (LocalScript) — 120 lines
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local player = Players.LocalPlayer

local label = script.Parent
local currentDisplayValue = 0

-- Store original size to prevent scaling issues
local originalSize = label.Size

-- Keep track of current scale tweens
local currentScaleTweens = {}

local function formatNumber(num)
	if num >= 1e9 then
		return string.format("%.1fB", num / 1e9)
	elseif num >= 1e6 then
		return string.format("%.1fM", num / 1e6)
	elseif num >= 1e3 then
		return string.format("%.1fk", num / 1e3)
	else
		return tostring(math.floor(num))
	end  -  Edit
  12:31:15.413  end

local function smoothCountTo(targetValue)
	local startValue = currentDisplayValue
	local difference = targetValue - startValue

	-- Don't animate if the difference is too small or if it's the initial load
	if math.abs(difference) <= 1 or startValue == 0 then
		currentDisplayValue = targetValue
		label.Text = formatNumber(targetValue)
		return
	end

	-- Cancel any existing scale tweens
	for _, tween in pairs(currentScaleTweens) do
		tween:Cancel()
	end
	currentScaleTweens = {}

	-- Reset to original size before scaling
	label.Size = originalSize

	-- Create scaling effect when value changes (always relative to original size)
	local scaleInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
	local scaleUpTween = TweenService:Create(label, scaleInfo, {
		Size = UDim2.new(originalSize.X.Scale * 1.1, 0, originalSize.Y.Scale * 1.1, 0)
	})
	local scaleDownTween = TweenService:Create(label, scaleInfo, {
		Size = originalSize
	})

	-- Store current tweens
	currentScaleTweens[1] = scaleUpTween
	currentScaleTweens[2] = scaleDownTween

	-- Brief color flash for positive changes
	if difference > 0 then
		local colorInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
		local colorTween = TweenService:Create(label, colorInfo, {TextColor3 = Color3.fromRGB(77, 44, 6)}) -- Gold color
		local colorBackTween = TweenService:Create(label, colorInfo, {TextColor3 = Color3.fromRGB(255, 255, 255)})
		colorTween:Play()
		colorTween.Completed:Connect(function()
			colorBackTween:Play()
		end)
	end

	-- Play scale animation
	scaleUpTween:Play()
	scaleUpTween.Completed:Connect(function()
		scaleDownTween:Play()
		scaleDownTween.Completed:Connect(function()
			-- Ensure we're back to original size
			label.Size = originalSize
		end)
	end)

	-- Smooth counting animation
	local duration = math.min(1, math.max(0.3, math.log(math.abs(difference)) * 0.1))
	local steps = math.min(60, math.max(10, math.abs(difference)))
	local stepTime = duration / steps

	local connection
	local currentStep = 0

	connection = game:GetService("RunService").Heartbeat:Connect(function()
		currentStep = currentStep + 1
		local progress = currentStep / steps

		-- Use easing for smooth animation
		local easedProgress = 1 - math.pow(1 - progress, 3) -- Ease out cubic

		currentDisplayValue = startValue + (difference * easedProgress)
		label.Text = formatNumber(currentDisplayValue)

		if currentStep >= steps then
			currentDisplayValue = targetValue
			label.Text = formatNumber(targetValue)
			connection:Disconnect()
		end
	end)
end

local function updateLabel()
	local leaderstats = player:WaitForChild("leaderstats")
	local pooped = leaderstats:WaitForChild("Poops")

	-- Set initial value
	currentDisplayValue = pooped.Value
	label.Text = formatNumber(pooped.Value)

	-- Update smoothly every time the value changes
	pooped:GetPropertyChangedSignal("Value"):Connect(function()
		smoothCountTo(pooped.Value)
	end)
end

updateLabel()

>>> game.StarterGui.InviteGui.Icon.IconButton.GuiEffect (LocalScript) — 66 lines
local Gui = script.Parent

local OriginalSize = Gui.Size
local HoverScaleFactor = 0.9  -- Scale factor when hovered
local ClickScaleFactor = 1.1  -- Scale factor when clicked
local TweenTime = 0.1

local TweenService = game:GetService("TweenService")
local IsClicked = false  -- Track if the GUI is clicked

local Gui = script.Parent

local OriginalSize = Gui.Size
local HoverScaleFactor = 0.9  -- Scale factor when hovered
local ClickScaleFactor = 1.1  -- Scale factor when clicked
local TweenTime = 0.1

local TweenService = game:GetService("TweenService")
local IsClicked = false  -- Track if the GUI is clicked

local function ScaleHover()
	if not IsClicked then  -- Only scale down if not clicked
		local NewSize = UDim2.new(
			OriginalSize.X.Scale * HoverScaleFactor, 
			OriginalSize.X.Offset * HoverScaleFactor, 
			OriginalSize.Y.Scale * HoverScaleFactor, 
			OriginalSize.Y.Offset * HoverScaleFactor
		)
		TweenService:Create(Gui, TweenInfo.new(TweenTime), {Size = NewSize}):Play()
	end
end

local function ScaleDownHover()
	if not IsClicked then  -- Only reset size if not clicked
		TweenService:Create(Gui, TweenInfo.new(TweenTime), {Size = OriginalSize}):Play()
	end
end

local function ScaleClick()
	IsClicked = true  -- Mark as clicked
	local NewSize = UDim2.new(
		OriginalSize.X.Scale * ClickScaleFactor, 
		OriginalSize.X.Offset * ClickScaleFactor, 
		OriginalSize.Y.Scale * ClickScaleFactor, 
		OriginalSize.Y.Offset * ClickScaleFactor
	)
	TweenService:Create(Gui, TweenInfo.new(TweenTime), {Size = NewSize}):Play()

	task.wait(TweenTime)  -- Wait for the scaling up tween to complete

	-- Return to the original size after the click animation
	TweenService:Create(Gui, TweenInfo.new(TweenTime), {Size = OriginalSize}):Play()
	task.wait(TweenTime)  -- Wait for the reset tween to complete

	IsClicked = false  -- Reset click state

	-- Check if the mouse is still hovering, and if so, apply the hover scale
	if Gui:IsMouseOver() then
		ScaleHover()
	end
end

Gui.MouseEnter:Connect(ScaleHover)
Gui.MouseLeave:Connect(ScaleDownHover)
Gui.MouseButton1Click:Connect(ScaleClick)


>>> game.StarterGui.InviteGui.Icon.IconButton.InviteScript (LocalScript) — 16 lines
local player = game.Players.LocalPlayer
local SocialService = game:GetService("SocialService")

function onButtonPressed()
	local success, resoult = pcall (
		function()
			return SocialService:CanSendGameInviteAsync(player)
		end
	)

	if resoult == true then
		SocialService:PromptGameInvite(player)
	end
end

script.Parent.MouseButton1Click:Connect(onButtonPressed)

>>> game.StarterGui.LoadingScreen.LoadingScript (LocalScript) — 470 lines
-- LoadingScreenManager (LocalScript) - FIXED FUNCTION ORDER
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local loadingScreen = script.Parent -- Your existing LoadingScreen ScreenGui

-- ═══════════════════════════════════════════════════════════════
-- 🎯 LOADING CONFIGURATION (MOVED TO TOP)
-- ═══════════════════════════════════════════════════════════════
local LoadingConfig = {
	MaxLoadTime = 25,
	TipChangeInterval = 3,  -  Edit
  12:31:15.413  	CheckInterval = 0.3,
	FadeOutDuration = 1.5,
	TextTransitionDuration = 0.4,
	EnableDebug = true,

	Tips = {
		"Press P to poop and earn PooBucks!",
		"Visit the shop to buy better poops and upgrades!",
		"You can gift gamepasses and boosts to other players!",
		"Rebirth to get permanent multipliers!",
		"Unlock new zones by pooping more!",
		"Boosts stack and their durations add up!",
		"Higher tier poops give more PooBucks per poop!",
		"Gamepasses stack: 2x + 4x = 6x earnings!",
		"Upgrades replace each other, not stack!",
		"Join our group for free rewards!",
		"Almost ready to start pooping!",
		"Loading all poop physics and systems...",
		"Setting up your pooping adventure!"
	}
}

-- FIXED: Debug function defined FIRST
local function debugPrint(message)
	if LoadingConfig.EnableDebug then
		print("[LOADING]: " .. message)
	end
end

-- ═══════════════════════════════════════════════════════════════
-- 🔧 GUI MANAGEMENT SYSTEM
-- ═══════════════════════════════════════════════════════════════

local playerGui = player:WaitForChild("PlayerGui")
local disabledGUIs = {} -- Store which GUIs were disabled

-- Function to disable all other GUIs
local function disableAllGUIs()
	debugPrint("🔒 Disabling all other GUIs...")

	for _, gui in pairs(playerGui:GetChildren()) do
		if gui:IsA("ScreenGui") and gui ~= loadingScreen and gui.Enabled then
			disabledGUIs[gui] = true
			gui.Enabled = false
			debugPrint("  🔒 Disabled: " .. gui.Name)
		end
	end

	debugPrint("✅ Disabled " .. #disabledGUIs .. " GUIs")
end

-- Function to re-enable all GUIs
local function enableAllGUIs()
	debugPrint("🔓 Re-enabling all GUIs...")

	local enabledCount = 0
	for gui, _ in pairs(disabledGUIs) do
		if gui and gui.Parent then -- Make sure GUI still exists
			gui.Enabled = true
			enabledCount = enabledCount + 1
			debugPrint("  🔓 Enabled: " .. gui.Name)
		end
	end

	-- Clear the table
	disabledGUIs = {}

	debugPrint("✅ Re-enabled " .. enabledCount .. " GUIs")
end

-- ═══════════════════════════════════════════════════════════════
-- 🔧 FIX YOUR EXISTING GUI ELEMENTS
-- ═══════════════════════════════════════════════════════════════

debugPrint("🔧 Fixing your existing LoadingScreen...")

-- Fix the main ScreenGui settings
loadingScreen.Enabled = true
loadingScreen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
loadingScreen.DisplayOrder = 100
loadingScreen.IgnoreGuiInset = true -- This covers the entire screen including top bar

-- DISABLE ALL OTHER GUIS IMMEDIATELY
disableAllGUIs()

-- Get your existing elements
local background = loadingScreen:WaitForChild("Background")
local cosmeticLogo = background:WaitForChild("CosmeticLogo")
local barFramePercentage = background:WaitForChild("BarFramePercentage")
local tipsLabel = background:WaitForChild("TipsLabel")
local percentageLabel = background:WaitForChild("PercentageLabel")
local cosmeticTitleLabel = background:WaitForChild("CosmeticTitleLabel")

-- 🛠️ FIX BACKGROUND TO COVER ENTIRE SCREEN
background.Size = UDim2.new(1, 0, 1, 0) -- Full screen
background.Position = UDim2.new(0, 0, 0, 0) -- Top-left corner
background.BackgroundTransparency = 0 -- Make sure it's visible
background.ZIndex = 1

-- 🛠️ FIX ALL TEXT ELEMENTS
cosmeticTitleLabel.Visible = true

tipsLabel.Visible = true
tipsLabel.Text = "Loading your poop adventure..."

percentageLabel.Visible = true
percentageLabel.Text = "0%"

-- 🛠️ FIX THE LOADING BAR
barFramePercentage.Visible = true

-- Create the actual green bar inside your BarFramePercentage
local actualBar = Instance.new("Frame")
actualBar.Name = "ActualBar"
actualBar.Size = UDim2.new(0, 0, 1, 0) -- Start at 0 width
actualBar.Position = UDim2.new(0, 0, 0, 0)
actualBar.BackgroundColor3 = Color3.fromRGB(142, 255, 111) 
actualBar.BorderSizePixel = 0
actualBar.ZIndex = 4
actualBar.Parent = barFramePercentage

-- 🛠️ FIX THE LOGO
cosmeticLogo.Visible = true

debugPrint("✅ Fixed all your GUI elements!")

-- Loading state
local startTime = tick()
local currentTipIndex = 1
local isLoading = true
local actualProgress = 0
local systemsLoaded = {}

debugPrint("🎬 Using your existing LoadingScreen!")

-- Function to update progress using YOUR bar
local function updateProgress(newProgress)
	actualProgress = math.min(newProgress, 100)

	-- Update your percentage label
	percentageLabel.Text = math.floor(actualProgress) .. "%"

	-- Animate YOUR loading bar
	local targetSize = UDim2.new(actualProgress / 100, 0, 1, 0)
	local tween = TweenService:Create(actualBar, 
		TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
		{Size = targetSize}
	)
	tween:Play()

	debugPrint("Progress updated: " .. math.floor(actualProgress) .. "%")
end

-- Function to update YOUR tips label with smooth transition
local function updateTip()
	if not isLoading then return end

	local newTip = LoadingConfig.Tips[currentTipIndex]

	-- Fade out your tips label
	local fadeOut = TweenService:Create(tipsLabel, 
		TweenInfo.new(LoadingConfig.TextTransitionDuration / 2), 
		{TextTransparency = 1}
	)

	fadeOut:Play()
	fadeOut.Completed:Connect(function()
		tipsLabel.Text = newTip

		-- Fade in your tips label
		local fadeIn = TweenService:Create(tipsLabel, 
			TweenInfo.new(LoadingConfig.TextTransitionDuration / 2), 
			{TextTransparency = 0}
		)
		fadeIn:Play()
	end)

	currentTipIndex = currentTipIndex + 1
	if currentTipIndex > #LoadingConfig.Tips then
		currentTipIndex = 1
	end
end

-- System checking function
local function checkSystems()
	local progress = 5 -- Base progress
	local systemsChecked = 0
	local systemsPassed = 0

	-- Check ShopConfig
	systemsChecked = systemsChecked + 1
	local shopConfig = ReplicatedStorage:FindFirstChild("ShopConfig")
	if shopConfig and not systemsLoaded.ShopConfig then
		local success = pcall(function() 
			local config = require(shopConfig)
			return config.Poops ~= nil
		end)
		if success then
			systemsLoaded.ShopConfig = true
			systemsPassed = systemsPassed + 1  -  Edit
  12:31:15.414  			debugPrint("✅ ShopConfig loaded")
		end
	elseif systemsLoaded.ShopConfig then
		systemsPassed = systemsPassed + 1
	end

	-- Check RemoteEvents
	systemsChecked = systemsChecked + 1
	local requiredEvents = {"PoopSpawnedEvent", "PoopGainPopupEvent", "GetPlayerDataRemote"}
	local eventsFound = 0
	for _, eventName in pairs(requiredEvents) do
		if ReplicatedStorage:FindFirstChild(eventName) then
			eventsFound = eventsFound + 1
		end
	end
	if eventsFound >= 3 and not systemsLoaded.RemoteEvents then
		systemsLoaded.RemoteEvents = true
		systemsPassed = systemsPassed + 1
		debugPrint("✅ RemoteEvents found (" .. eventsFound .. "/3)")
	elseif systemsLoaded.RemoteEvents then
		systemsPassed = systemsPassed + 1
	end

	-- Check Leaderstats
	systemsChecked = systemsChecked + 1
	local leaderstats = player:FindFirstChild("leaderstats")
	if leaderstats and not systemsLoaded.Leaderstats then
		local pooBucks = leaderstats:FindFirstChild("PooBucks")
		local poops = leaderstats:FindFirstChild("Poops")
		if pooBucks and poops then
			systemsLoaded.Leaderstats = true
			systemsPassed = systemsPassed + 1
			debugPrint("✅ Leaderstats ready")
		end
	elseif systemsLoaded.Leaderstats then
		systemsPassed = systemsPassed + 1
	end

	-- Check Character
	systemsChecked = systemsChecked + 1
	local character = player.Character
	if character and not systemsLoaded.Character then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid and humanoid.Health > 0 then
			systemsLoaded.Character = true
			systemsPassed = systemsPassed + 1
			debugPrint("✅ Character ready")
		end
	elseif systemsLoaded.Character then
		systemsPassed = systemsPassed + 1
	end

	-- Check GUI Systems
	systemsChecked = systemsChecked + 1
	local playerGui = player:FindFirstChild("PlayerGui")
	if playerGui and not systemsLoaded.GUISystem then
		local currencyGui = playerGui:FindFirstChild("CurrencyGui")
		if currencyGui then
			systemsLoaded.GUISystem = true
			systemsPassed = systemsPassed + 1
			debugPrint("✅ GUI systems ready")
		end
	elseif systemsLoaded.GUISystem then
		systemsPassed = systemsPassed + 1
	end

	-- Calculate progress
	local systemProgress = (systemsPassed / systemsChecked) * 95
	progress = progress + systemProgress

	updateProgress(progress)

	local elapsedTime = tick() - startTime
	local allSystemsLoaded = systemsPassed >= systemsChecked
	local timeoutReached = elapsedTime >= LoadingConfig.MaxLoadTime

	debugPrint("Systems: " .. systemsPassed .. "/" .. systemsChecked .. " loaded")

	return allSystemsLoaded or timeoutReached
end

-- Function to finish loading using YOUR elements
-- Function to finish loading using YOUR elements with SMOOTH FADE
local function finishLoading()
	if not isLoading then return end
	isLoading = false

	debugPrint("🎉 Finishing loading sequence...")

	updateProgress(100)
	tipsLabel.Text = "🎉 Ready to start pooping!"

	wait(1.5)

	debugPrint("Fading out your LoadingScreen with smooth transitions...")

	-- ═══════════════════════════════════════════════════════════════
	-- 🌟 SMOOTH CASCADING FADE-OUT SEQUENCE
	-- ═══════════════════════════════════════════════════════════════

	local fadeInfo = TweenInfo.new(
		LoadingConfig.FadeOutDuration, 
		Enum.EasingStyle.Quart,  -- Smoother easing
		Enum.EasingDirection.Out
	)

	local quickFade = TweenInfo.new(
		LoadingConfig.FadeOutDuration * 0.8, 
		Enum.EasingStyle.Quart, 
		Enum.EasingDirection.Out
	)

	-- Step 1: Fade out text elements first (cascading effect)
	local textTweens = {}

	-- Fade percentage and tips together
	table.insert(textTweens, TweenService:Create(percentageLabel, quickFade, {TextTransparency = 1}))
	table.insert(textTweens, TweenService:Create(tipsLabel, quickFade, {TextTransparency = 1}))

	-- Start text fade
	for _, tween in pairs(textTweens) do
		tween:Play()
	end

	-- Step 2: Fade loading bar after slight delay
	spawn(function()
		wait(0.2) -- Small delay for cascade effect

		local barTweens = {}
		table.insert(barTweens, TweenService:Create(barFramePercentage, quickFade, {BackgroundTransparency = 1}))
		table.insert(barTweens, TweenService:Create(actualBar, quickFade, {BackgroundTransparency = 1}))

		-- Fade bar borders/strokes if they exist
		for _, descendant in pairs(barFramePercentage:GetDescendants()) do
			if descendant:IsA("UIStroke") then
				table.insert(barTweens, TweenService:Create(descendant, quickFade, {Transparency = 1}))
			end
		end

		for _, tween in pairs(barTweens) do
			tween:Play()
		end
	end)

	-- Step 3: Fade logo and title after another delay
	spawn(function()
		wait(0.4)

		local logoTweens = {}
		table.insert(logoTweens, TweenService:Create(cosmeticLogo, fadeInfo, {ImageTransparency = 1}))
		table.insert(logoTweens, TweenService:Create(cosmeticTitleLabel, fadeInfo, {TextTransparency = 1}))

		for _, tween in pairs(logoTweens) do
			tween:Play()
		end
	end)

	-- Step 4: Fade background LAST to maintain backdrop
	spawn(function()
		wait(0.6) -- Longer delay so background fades last

		-- Create final background fade
		local backgroundFade = TweenService:Create(background, 
			TweenInfo.new(
				LoadingConfig.FadeOutDuration * 1.2, -- Slightly longer for smooth finish
				Enum.EasingStyle.Quart,
				Enum.EasingDirection.Out
			), 
			{BackgroundTransparency = 1}
		)

		backgroundFade:Play()

		-- Handle any remaining UIStrokes on background
		for _, descendant in pairs(background:GetDescendants()) do
			if descendant:IsA("UIStroke") and descendant.Parent ~= barFramePercentage then
				TweenService:Create(descendant, fadeInfo, {Transparency = 1}):Play()
			end
		end
	end)

	-- ═══════════════════════════════════════════════════════════════
	-- 🎯 FINAL CLEANUP WITH PERFECT TIMING
	-- ═══════════════════════════════════════════════════════════════

	spawn(function()
		-- Wait for all fades to complete
		wait(LoadingConfig.FadeOutDuration * 1.5 + 0.8) -- Account for delays + fade time

		-- Double-check all transparencies are set to 1 (failsafe)
		background.BackgroundTransparency = 1
		cosmeticTitleLabel.TextTransparency = 1
		tipsLabel.TextTransparency = 1
		percentageLabel.TextTransparency = 1
		barFramePercentage.BackgroundTransparency = 1
		actualBar.BackgroundTransparency = 1
		cosmeticLogo.ImageTransparency = 1

		-- Final disable
		loadingScreen.Enabled = false  -  Edit
  12:31:15.414  
		-- 🔓 RE-ENABLE ALL GUIS WHEN LOADING IS COMPLETE
		enableAllGUIs()

		debugPrint("✅ Your LoadingScreen faded out FLAWLESSLY!")
		debugPrint("🎮 All GUIs re-enabled - Game ready!")
	end)
end

-- Start tip rotation on YOUR tips label
spawn(function()
	updateTip() -- Show first tip
	while isLoading do
		wait(LoadingConfig.TipChangeInterval)
		updateTip()
	end
end)

-- Main loading loop
spawn(function()
	wait(0.1)
	updateProgress(0)

	while isLoading do
		if checkSystems() then
			finishLoading()
			break
		end
		wait(LoadingConfig.CheckInterval)
	end
end)

-- Safety timeout with GUI re-enabling
spawn(function()
	wait(LoadingConfig.MaxLoadTime + 2)
	if isLoading then
		debugPrint("⏰ Safety timeout triggered")
		finishLoading() -- This will also re-enable GUIs
	end
end)

-- Handle player leaving (cleanup)
Players.PlayerRemoving:Connect(function(leavingPlayer)
	if leavingPlayer == player then
		-- Re-enable GUIs if player is leaving during loading
		enableAllGUIs()
	end
end)

-- Initial setup
updateProgress(5)
tipsLabel.Text = "🚀 Initializing your poop adventure..."

debugPrint("🎮 Your LoadingScreen is now working perfectly!")
debugPrint("🔒 All other GUIs disabled during loading")

>>> game.StarterGui.NotificationGui.NotificationSystem (LocalScript) — 374 lines
-- NotificationSystem (LocalScript in StarterGui.NotificationGui.NotificationSystem) - FIXED TELEPORT
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Get ShopConfig
local ShopConfig = require(ReplicatedStorage:WaitForChild("ShopConfig"))

-- Debug system
local function debugPrint(message)
	if ShopConfig.Debug.Enabled and ShopConfig.Debug.ShowNotificationDebug then
		print("[NOTIFICATION]: " .. message)
	end
end

-- Wait for NotificationGui
local notificationGui = playerGui:WaitForChild("NotificationGui")
local nextPurchaseNotificationBackground = notificationGui:WaitForChild("NextPurchaseNotificationBackground")
local recievedGiftNotificationBackground = notificationGui:WaitForChild("RecievedGiftNotificationBackground")

-- Gift notification elements
local giftNotificationTitle = recievedGiftNotificationBackground:WaitForChild("NotificationTitle")
local giftNotificationDescription = recievedGiftNotificationBackground:WaitForChild("NotificationDescription")
local giftExitButton = recievedGiftNotificationBackground:WaitForChild("ExitButton")

-- Purchase notification elements
local purchaseNotificationTitle = nextPurchaseNotificationBackground:WaitForChild("NotificationTitle")
local purchaseNotificationDescription = nextPurchaseNotificationBackground:WaitForChild("NotificationDescription")
local purchaseExitButton = nextPurchaseNotificationBackground:WaitForChild("ExitButton")
local teleportToShopButton = nextPurchaseNotificationBackground:WaitForChild("TeleportToShopButton")

-- Wait for RemoteEvents
local GiftNotificationEvent = ReplicatedStorage:WaitForChild("GiftNotificationEvent")
local GetPlayerDataRemote = ReplicatedStorage:WaitForChild("GetPlayerDataRemote")

-- MEMORY MANAGEMENT
local connections = {}

local function cleanupConnections()
	for _, connection in pairs(connections) do
		if connection then
			connection:Disconnect()
		end
	end
	connections = {}
end

local shownNotifications = {}

-- State management
local isGiftNotificationShowing = false
local isPurchaseNotificationShowing = false
local purchaseCheckInterval = nil

-- Store original positions
local originalGiftPosition = recievedGiftNotificationBackground.Position
local originalPurchasePosition = nextPurchaseNotificationBackground.Position

-- Calculate off-screen positions for smoother animations
local offScreenGiftPosition = UDim2.new(
	originalGiftPosition.X.Scale,
	originalGiftPosition.X.Offset,
	-0.3,
	originalGiftPosition.Y.Offset
)

local offScreenPurchasePosition = UDim2.new(
	originalPurchasePosition.X.Scale,
	originalPurchasePosition.X.Offset,
	-0.3,
	originalPurchasePosition.Y.Offset
)

-- Initialize notification states
recievedGiftNotificationBackground.Visible = false
nextPurchaseNotificationBackground.Visible = false

debugPrint("NotificationSystem initialized")

-- Create sounds
local notificationSound = Instance.new("Sound")
notificationSound.SoundId = ShopConfig.Sounds.NotificationShow
notificationSound.Volume = ShopConfig.Sounds.Volumes.Notification
notificationSound.Parent = workspace

local giftSound = Instance.new("Sound")
giftSound.SoundId = ShopConfig.Sounds.GiftReceived
giftSound.Volume = ShopConfig.Sounds.Volumes.Notification
giftSound.Parent = workspace

-- Enhanced slide-down animation with smoother easing
local function showGiftNotification(gifterName, itemName)
	if isGiftNotificationShowing then return end

	isGiftNotificationShowing = true
	debugPrint("Showing gift notification from " .. gifterName .. " for " .. itemName)

	-- Update text
	giftNotificationTitle.Text = "You received a gift!"
	giftNotificationDescription.Text = gifterName .. " has gifted you " .. itemName .. ". Thank them by sending them another gift!"

	-- Setup initial position
	recievedGiftNotificationBackground.Position = offScreenGiftPosition
	recievedGiftNotificationBackground.Visible = true

	-- Play sound
	giftSound:Play()

	-- Smooth slide-down animation
	local tweenInfo = TweenInfo.new(
		0.6,
		Enum.EasingStyle.Quint,
		Enum.EasingDirection.Out
	)

	local slideTween = TweenService:Create(recievedGiftNotificationBackground, tweenInfo, {
		Position = originalGiftPosition
	})

	slideTween:Play()

	-- Auto close if enabled
	if ShopConfig.Notifications.GiftNotification.AutoClose then
		spawn(function()
			wait(ShopConfig.Notifications.GiftNotification.Duration)
			hideGiftNotification()
		end)
	end
end

-- Enhanced fade-up animation
function hideGiftNotification()
	if not isGiftNotificationShowing then return end

	isGiftNotificationShowing = false
	debugPrint("Hiding gift notification")

	local tweenInfo = TweenInfo.new(
		0.4,  -  Edit
  12:31:15.415  		Enum.EasingStyle.Quint,
		Enum.EasingDirection.In
	)

	local fadeTween = TweenService:Create(recievedGiftNotificationBackground, tweenInfo, {
		Position = offScreenGiftPosition
	})

	fadeTween:Play()
	fadeTween.Completed:Connect(function()
		recievedGiftNotificationBackground.Visible = false
		recievedGiftNotificationBackground.Position = originalGiftPosition
	end)
end

-- Enhanced purchase notification with smoother animations
local function showPurchaseNotification(itemName, itemKey)
	if shownNotifications[itemKey] then
		return
	end

	if isPurchaseNotificationShowing then
		hidePurchaseNotification()
		wait(0.5)
	end

	isPurchaseNotificationShowing = true
	debugPrint("Showing purchase notification for " .. itemName)

	shownNotifications[itemKey] = true

	-- Update text
	purchaseNotificationTitle.Text = itemName
	purchaseNotificationDescription.Text = "You have enough money to buy the next poop upgrade which is " .. itemName .. "!"

	-- Setup initial position
	nextPurchaseNotificationBackground.Position = offScreenPurchasePosition
	nextPurchaseNotificationBackground.Visible = true

	-- Play sound
	notificationSound:Play()

	-- Smooth slide-down animation
	local tweenInfo = TweenInfo.new(
		0.6,
		Enum.EasingStyle.Quint,
		Enum.EasingDirection.Out
	)

	local slideTween = TweenService:Create(nextPurchaseNotificationBackground, tweenInfo, {
		Position = originalPurchasePosition
	})

	slideTween:Play()
end

-- Enhanced fade-up for purchase notifications
function hidePurchaseNotification()
	if not isPurchaseNotificationShowing then return end

	isPurchaseNotificationShowing = false
	debugPrint("Hiding purchase notification")

	local tweenInfo = TweenInfo.new(
		0.4,
		Enum.EasingStyle.Quint,
		Enum.EasingDirection.In
	)

	local fadeTween = TweenService:Create(nextPurchaseNotificationBackground, tweenInfo, {
		Position = offScreenPurchasePosition
	})

	fadeTween:Play()
	fadeTween.Completed:Connect(function()
		nextPurchaseNotificationBackground.Visible = false
		nextPurchaseNotificationBackground.Position = originalPurchasePosition
	end)
end

-- Function to get next affordable poop
local function getNextAffordablePoop(playerPooBucks, ownedPoops)
	local poopOrder = {
		"Poop", "StinkyPoop", "BurntPoop", "WaterPoop", "ShockedPoop",
		"HypnosisPoop", "HolyPoop", "BloodyPoop", "DiamondPoop", 
		"VoidPoop", "GalePoop", "BlackHolePoop"
	}

	for _, poopKey in ipairs(poopOrder) do
		local poopConfig = ShopConfig.Poops[poopKey]
		if poopConfig and not table.find(ownedPoops, poopKey) then
			if playerPooBucks >= poopConfig.Price then
				return poopKey, poopConfig
			end
		end
	end

	return nil, nil
end

-- Function to check for purchase notifications
local function checkPurchaseNotifications()
	local success, playerData = pcall(function()
		return GetPlayerDataRemote:InvokeServer()
	end)

	if success and playerData then
		local nextPoopKey, nextPoopConfig = getNextAffordablePoop(playerData.PooBucks, playerData.OwnedPoops or {})

		if nextPoopKey and nextPoopConfig and not shownNotifications[nextPoopKey] then
			showPurchaseNotification(nextPoopConfig.Name, nextPoopKey)
		end
	end
end

-- Start purchase notification checking
local function startPurchaseNotificationChecking()
	if purchaseCheckInterval then return end

	purchaseCheckInterval = spawn(function()
		while true do
			wait(ShopConfig.Notifications.PurchaseNotification.CheckInterval)
			if not isPurchaseNotificationShowing then
				checkPurchaseNotifications()
			end
		end
	end)
end

-- FIXED: Teleport to shop function
local function teleportToShop()
	hidePurchaseNotification()

	debugPrint("Attempting to teleport to shop...")

	-- Method 1: Look for Shop trigger part
	local shopTrigger = workspace:FindFirstChild("Shop")
	if shopTrigger then
		shopTrigger = shopTrigger:FindFirstChild("Trigger")
		if shopTrigger and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			player.Character.HumanoidRootPart.CFrame = shopTrigger.CFrame * CFrame.new(0, 5, 0)
			debugPrint("Teleported player to Shop trigger")
			return
		end
	end

	-- Method 2: Look for ShopTPPart
	local shopTPPart = workspace:FindFirstChild("ShopTPPart")
	if shopTPPart and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
		player.Character.HumanoidRootPart.CFrame = shopTPPart.CFrame * CFrame.new(0, 5, 0)
		debugPrint("Teleported player to ShopTPPart")
		return
	end

	-- Method 3: Look for any part with "Shop" in the name
	for _, obj in pairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") and string.find(obj.Name:lower(), "shop") then
			if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
				player.Character.HumanoidRootPart.CFrame = obj.CFrame * CFrame.new(0, 5, 0)
				debugPrint("Teleported player to shop part: " .. obj.Name)
				return
			end
		end
	end

	-- Method 4: Fallback to opening shop GUI directly
	debugPrint("No shop teleport location found, opening shop GUI instead")
	local RemoteEvent_OpenShop = ReplicatedStorage:FindFirstChild("RemoteEvent_OpenShop")
	if RemoteEvent_OpenShop then
		RemoteEvent_OpenShop:FireServer()
	else
		-- Final fallback: direct GUI opening
		local shopGui = playerGui:FindFirstChild("ShopGui")
		if shopGui then
			local shopScript = shopGui:FindFirstChild("ShopScript")
			if shopScript and shopScript:IsA("LocalScript") then
				-- Try to call a global function if it exists
				if _G.openShop then
					_G.openShop()
				else
					print("Shop GUI found but cannot open automatically. Please press the shop button or go near the shop.")
				end
			end
		end
	end
end

-- Event handlers
table.insert(connections, GiftNotificationEvent.OnClientEvent:Connect(function(gifterName, itemName)
	showGiftNotification(gifterName, itemName)
end))

-- Button connections
table.insert(connections, giftExitButton.MouseButton1Click:Connect(function()
	hideGiftNotification()
end))

table.insert(connections, purchaseExitButton.MouseButton1Click:Connect(function()
	hidePurchaseNotification()
end))  -  Edit
  12:31:15.416  
-- Enhanced teleport button functionality
table.insert(connections, teleportToShopButton.MouseButton1Click:Connect(teleportToShop))

-- Check for offline gifts when player joins
spawn(function()
	wait(3) -- Wait for other systems to load

	local success, result = pcall(function()
		return game:GetService("ReplicatedStorage"):WaitForChild("CheckOfflineGifts"):InvokeServer()
	end)

	if success and result then
		for _, giftData in pairs(result) do
			showGiftNotification(giftData.gifterName, giftData.itemName)
			wait(2) -- Space out multiple notifications
		end
	end
end)

-- Start systems
startPurchaseNotificationChecking()

-- Cleanup on player leaving
table.insert(connections, Players.PlayerRemoving:Connect(function(removingPlayer)
	if removingPlayer == player then
		cleanupConnections()
	end
end))

debugPrint("NotificationSystem setup complete!")

>>> game.StarterGui.PoopButtonGui.CanvasBackground.Button.PoopButtonGuiAnimation (LocalScript) — 156 lines
-- GUI Effects Script
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- CONFIGURABLE CONSTANTS
local SLIDE_OUT_DURATION = 0.3
local SLIDE_IN_DURATION = 0.2
local POP_DURATION = 0.1
local SLIDE_DISTANCE = 30
local SHRINK_SCALE = 0.58
local GROW_SCALE = 1.20
local HOVER_SOUND_ID = "rbxassetid://17208339919"
local CLICK_SOUND_ID = "rbxassetid://17670953919"
local HOVER_VOLUME = 1
local CLICK_VOLUME = 1

-- Wait for GUI elements
local poopButtonGui = playerGui:WaitForChild("PoopButtonGui")
local canvasBackground = poopButtonGui:WaitForChild("CanvasBackground")
local poopButton = script.Parent

-- Get slide frames
local slideFrame1 = script.Parent.Parent:WaitForChild("SlideFrame1")
local slideFrame2 = script.Parent.Parent:WaitForChild("SlideFrame2")
local slideFrame3 = script.Parent.Parent:WaitForChild("SlideFrame3")
local slideFrame4 = script.Parent.Parent:WaitForChild("SlideFrame4")

-- Store original positions and frames
local slideFrames = {slideFrame1, slideFrame2, slideFrame3, slideFrame4}
local originalPositions = {}
for i, frame in pairs(slideFrames) do
	originalPositions[i] = frame.Position
end

-- Store original canvas size
local originalCanvasSize = canvasBackground.Size

-- Create sounds with error handling
local hoverSound = Instance.new("Sound")
local clickSound = Instance.new("Sound")

local function setupSound(sound, soundId, volume, parent)
	local success, _ = pcall(function()
		sound.SoundId = soundId
		sound.Volume = volume
		sound.Parent = parent
	end)
	if not success then
		warn("Failed to setup sound: " .. soundId)
	end
	return sound
end

setupSound(hoverSound, HOVER_SOUND_ID, HOVER_VOLUME, poopButton)
setupSound(clickSound, CLICK_SOUND_ID, CLICK_VOLUME, poopButton)

-- Tween settings
local slideOutInfo = TweenInfo.new(SLIDE_OUT_DURATION, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
local slideInInfo = TweenInfo.new(SLIDE_IN_DURATION, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
local popInfo = TweenInfo.new(POP_DURATION, Enum.EasingStyle.Back, Enum.EasingDirection.Out)

-- Function to slide frames out
local function slideFramesOut()
	for i, frame in pairs(slideFrames) do
		local newPosition = UDim2.new(
			originalPositions[i].X.Scale,
			originalPositions[i].X.Offset,
			originalPositions[i].Y.Scale,
			originalPositions[i].Y.Offset - SLIDE_DISTANCE
		)
		local success, tween = pcall(function()
			return TweenService:Create(frame, slideOutInfo, {Position = newPosition})
		end)
		if success then
			tween:Play()
		end
	end
end

-- Function to slide frames back to original position
local function slideFramesIn()
	for i, frame in pairs(slideFrames) do
		local success, tween = pcall(function()
			return TweenService:Create(frame, slideInInfo, {Position = originalPositions[i]})
		end)
		if success then
			tween:Play()
		end
	end
end

-- Function for button pop effect
local function buttonPop()
	local success, shrinkTween = pcall(function()
		return TweenService:Create(canvasBackground, popInfo, {
			Size = UDim2.new(originalCanvasSize.X.Scale * SHRINK_SCALE, 0, originalCanvasSize.Y.Scale * SHRINK_SCALE, 0)
		})
	end)

	if not success then return end

	shrinkTween:Play()
	shrinkTween.Completed:Connect(function()
		local growSuccess, growTween = pcall(function()
			return TweenService:Create(canvasBackground, popInfo, {
				Size = UDim2.new(originalCanvasSize.X.Scale * GROW_SCALE, 0, originalCanvasSize.Y.Scale * GROW_SCALE, 0)
			})
		end)

		if not growSuccess then return end

		growTween:Play()
		growTween.Completed:Connect(function()
			local returnSuccess, returnTween = pcall(function()
				return TweenService:Create(canvasBackground, popInfo, {Size = originalCanvasSize})
			end)
			if returnSuccess then
				returnTween:Play()
			end
		end)
	end)
end

-- Function to safely play sound
local function playSound(sound)
	local success, _ = pcall(function()
		sound:Play()
	end)
	if not success then
		warn("Failed to play sound")
	end
end

-- Connect hover events
poopButton.MouseEnter:Connect(function()
	playSound(hoverSound)
	slideFramesOut()
end)

poopButton.MouseLeave:Connect(function()
	slideFramesIn()
end)

-- Connect button click for effects only
poopButton.MouseButton1Click:Connect(function()
	playSound(clickSound)
	buttonPop()

	-- Signal to poop script that button was clicked
	if _G.spawnPoop then
		_G.spawnPoop()
	end
end)

>>> game.StarterGui.PopupScreenGui.PopupManager (LocalScript) — 431 lines
-- PopupManager (LocalScript in StarterGui.PopupScreenGui) - FIXED WITH ROBUST INITIALIZATION
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local SoundService = game:GetService("SoundService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")  -  Edit
  12:31:15.416  
-- ═══════════════════════════════════════════════════════════════
-- 🔧 POPUP CONFIGURATION
-- ═══════════════════════════════════════════════════════════════
local PopupConfig = {
	-- Spawn Settings
	SpawnFrameSize = {400, 300},
	SpawnFramePosition = {0.5, -200, 0.3, 0},

	-- Animation Timing
	EntranceTime = 0.2,
	PauseTime = 0.3,
	FlightTime = 0.7,

	-- Rotation Effects
	PooBucksRotation = {Start = -25, Middle = 5, End = 0},
	PoopsRotation = {Start = 30, Middle = -8, End = 0},

	-- Size Effects
	SpawnSize = {150, 50},
	EntranceSize = {180, 60},
	FlightEndSize = {40, 20},

	-- Sound Effects
	Sounds = {
		PooBucks = "rbxassetid://8646410774",
		Poops = "rbxassetid://17083832840",
		Volume = 0.55
	},

	-- Timing
	CurrencyAnimationTime = 0.3,
	SoundDelay = 0,

	-- ZIndex
	PopupZIndex = 100,

	-- Debug & Retry Settings
	EnableDebug = true,
	EnableTestPopups = false, -- DISABLED for production
	TestDelay = 0.1,
	MaxRetries = 10, -- NEW: Maximum connection retries
	RetryDelay = 1 -- NEW: Delay between retries
}

-- Get ShopConfig with error handling
local ShopConfig
local function loadShopConfig()
	local success, result = pcall(function()
		return require(ReplicatedStorage:WaitForChild("ShopConfig", 10))
	end)

	if success then
		ShopConfig = result
		return true
	else
		warn("Failed to load ShopConfig: " .. tostring(result))
		return false
	end
end

-- Try to load ShopConfig
if not loadShopConfig() then
	-- Retry loading ShopConfig
	spawn(function()
		for i = 1, 5 do
			wait(2)
			if loadShopConfig() then
				break
			end
		end
	end)
end

-- Debug system with fallback
local function debugPrint(message)
	if PopupConfig.EnableDebug then
		if ShopConfig and ShopConfig.Debug and ShopConfig.Debug.Enabled and ShopConfig.Debug.ShowClientDebug then
			print("[POPUP]: " .. message)
		else
			print("[POPUP]: " .. message) -- Fallback when ShopConfig isn't loaded
		end
	end
end

debugPrint("PopupManager starting initialization...")

-- Get the popup GUI
local popupScreenGui = script.Parent
popupScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

-- Create PopupSpawnFrame
local popupSpawnFrame = popupScreenGui:FindFirstChild("PopupSpawnFrame")
if not popupSpawnFrame then
	popupSpawnFrame = Instance.new("Frame")
	popupSpawnFrame.Name = "PopupSpawnFrame"
	popupSpawnFrame.Size = UDim2.new(0, PopupConfig.SpawnFrameSize[1], 0, PopupConfig.SpawnFrameSize[2])
	popupSpawnFrame.Position = UDim2.new(
		PopupConfig.SpawnFramePosition[1], PopupConfig.SpawnFramePosition[2],
		PopupConfig.SpawnFramePosition[3], PopupConfig.SpawnFramePosition[4]
	)
	popupSpawnFrame.BackgroundTransparency = 1
	popupSpawnFrame.Visible = true
	popupSpawnFrame.ZIndex = PopupConfig.PopupZIndex
	popupSpawnFrame.Parent = popupScreenGui
end

-- Get templates with error handling
local pooBucksTemplate = popupScreenGui:WaitForChild("PooBucksBackgroundTemplate", 10)
local poopsTemplate = popupScreenGui:WaitForChild("PoopsBackgroundTemplate", 10)

if not pooBucksTemplate or not poopsTemplate then
	warn("POPUP ERROR: Templates not found!")
	return
end

-- Get targets with error handling
local currencyGui = playerGui:WaitForChild("CurrencyGui", 30)
local pooBucksTarget, poopsTarget

if currencyGui then
	local background = currencyGui:WaitForChild("Background", 10)
	local timesPoopedBG = currencyGui:WaitForChild("TimesPoopedBG", 10)

	if background then
		pooBucksTarget = background:WaitForChild("Image", 10)
	end

	if timesPoopedBG then
		poopsTarget = timesPoopedBG:WaitForChild("Image", 10)
	end
end

if not pooBucksTarget or not poopsTarget then
	warn("POPUP ERROR: Currency targets not found!")
	return
end

debugPrint("Found all required GUI elements")

-- FIXED: Robust RemoteEvent connection with retries
local poopGainPopupEvent = nil
local isConnected = false
local connectionAttempts = 0

local function attemptConnection()
	connectionAttempts = connectionAttempts + 1
	debugPrint("Connection attempt #" .. connectionAttempts)

	local success, event = pcall(function()
		return ReplicatedStorage:WaitForChild("PoopGainPopupEvent", 5)
	end)

	if success and event then
		poopGainPopupEvent = event

		-- Connect to the event
		local connectionSuccess, connectionError = pcall(function()
			poopGainPopupEvent.OnClientEvent:Connect(function(amount)
				debugPrint("PoopGainPopupEvent received! Amount: " .. tostring(amount))
				createPooBucksPopup(amount)
			end)
		end)

		if connectionSuccess then
			isConnected = true
			debugPrint("✅ Successfully connected to PoopGainPopupEvent on attempt #" .. connectionAttempts)
			return true
		else
			debugPrint("❌ Failed to connect to event: " .. tostring(connectionError))
			return false
		end
	else
		debugPrint("❌ RemoteEvent not found on attempt #" .. connectionAttempts)
		return false
	end
end

-- Try connecting immediately
if not attemptConnection() then
	-- Retry connection with delays
	spawn(function()
		while not isConnected and connectionAttempts < PopupConfig.MaxRetries do
			wait(PopupConfig.RetryDelay)
			debugPrint("Retrying connection... (Attempt " .. (connectionAttempts + 1) .. "/" .. PopupConfig.MaxRetries .. ")")

			if attemptConnection() then
				break
			end
		end

		if not isConnected then
			warn("❌ POPUP SYSTEM FAILED: Could not connect to PoopGainPopupEvent after " .. PopupConfig.MaxRetries .. " attempts")
			warn("❌ Check that your server scripts are loading properly!")
		end
	end)
end

-- Sound creation function
local function createSound(soundId, volume)  -  Edit
  12:31:15.416  	local sound = Instance.new("Sound")
	sound.SoundId = soundId
	sound.Volume = volume or PopupConfig.Sounds.Volume
	sound.Parent = SoundService
	return sound
end

-- Function to play sound effect
local function playPopupSound(soundType)
	local soundId = PopupConfig.Sounds[soundType]
	if soundId and soundId ~= "" then
		local sound = createSound(soundId, PopupConfig.Sounds.Volume)
		sound:Play()
		sound.Ended:Connect(function()
			sound:Destroy()
		end)
	end
end

-- Function to get random spawn position
local function getRandomSpawnPosition()
	local frameSize = popupSpawnFrame.AbsoluteSize
	local randomX = math.random(0, frameSize.X - PopupConfig.SpawnSize[1])
	local randomY = math.random(0, frameSize.Y - PopupConfig.SpawnSize[2])
	return UDim2.new(0, randomX, 0, randomY)
end

-- Function to get target position
local function getTargetPosition(targetGui)
	if not targetGui then return UDim2.new(0.5, 0, 0.5, 0) end

	local targetAbsPos = targetGui.AbsolutePosition
	local targetAbsSize = targetGui.AbsoluteSize
	local frameAbsPos = popupSpawnFrame.AbsolutePosition

	local targetCenterX = targetAbsPos.X + targetAbsSize.X / 2
	local targetCenterY = targetAbsPos.Y + targetAbsSize.Y / 2

	local relativeX = targetCenterX - frameAbsPos.X - PopupConfig.FlightEndSize[1] / 2
	local relativeY = targetCenterY - frameAbsPos.Y - PopupConfig.FlightEndSize[2] / 2

	return UDim2.new(0, relativeX, 0, relativeY)
end

-- Create PooBucks popup function
function createPooBucksPopup(amount)
	if not amount or amount <= 0 then 
		debugPrint("Invalid PooBucks amount: " .. tostring(amount))
		return 
	end

	debugPrint("Creating PooBucks popup for amount: " .. amount)

	local popup = pooBucksTemplate:Clone()
	popup.Name = "PooBucksPopup_" .. tick()
	popup.Visible = true
	popup.GroupTransparency = 0
	popup.Rotation = PopupConfig.PooBucksRotation.Start
	popup.Size = UDim2.new(0, PopupConfig.SpawnSize[1], 0, PopupConfig.SpawnSize[2])
	popup.ZIndex = PopupConfig.PopupZIndex + 1
	popup.Parent = popupSpawnFrame

	local amountLabel = popup:FindFirstChild("PooBucksGained")
	if amountLabel then
		amountLabel.Text = "+$" .. tostring(amount)
		amountLabel.ZIndex = PopupConfig.PopupZIndex + 2
	end

	local popupImage = popup:FindFirstChild("PopupImage")
	if popupImage then
		popupImage.ZIndex = PopupConfig.PopupZIndex + 2
	end

	popup.Position = getRandomSpawnPosition()
	local targetPosition = getTargetPosition(pooBucksTarget)

	local entranceTween = TweenService:Create(popup, TweenInfo.new(PopupConfig.EntranceTime, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Size = UDim2.new(0, PopupConfig.EntranceSize[1], 0, PopupConfig.EntranceSize[2]),
		Position = UDim2.new(popup.Position.X.Scale, popup.Position.X.Offset, popup.Position.Y.Scale, popup.Position.Y.Offset - 20),
		Rotation = PopupConfig.PooBucksRotation.Middle
	})

	local flyTween = TweenService:Create(popup, TweenInfo.new(PopupConfig.FlightTime, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Position = targetPosition,
		Size = UDim2.new(0, PopupConfig.FlightEndSize[1], 0, PopupConfig.FlightEndSize[2]),
		GroupTransparency = 1,
		Rotation = PopupConfig.PooBucksRotation.End
	})

	entranceTween:Play()
	entranceTween.Completed:Connect(function()
		wait(PopupConfig.PauseTime)
		spawn(function()
			wait(PopupConfig.SoundDelay)
			playPopupSound("PooBucks")
		end)
		flyTween:Play()
	end)

	flyTween.Completed:Connect(function()
		popup:Destroy()
	end)
end

-- Create Poops popup function
local function createPoopsPopup(amount)
	amount = amount or 1
	debugPrint("Creating Poops popup for amount: " .. amount)

	local popup = poopsTemplate:Clone()
	popup.Name = "PoopsPopup_" .. tick()
	popup.Visible = true
	popup.GroupTransparency = 0
	popup.Rotation = PopupConfig.PoopsRotation.Start
	popup.Size = UDim2.new(0, PopupConfig.SpawnSize[1], 0, PopupConfig.SpawnSize[2])
	popup.ZIndex = PopupConfig.PopupZIndex + 1
	popup.Parent = popupSpawnFrame

	local amountLabel = popup:FindFirstChild("PoopsGained")
	if amountLabel then
		amountLabel.Text = "+" .. tostring(amount)
		amountLabel.ZIndex = PopupConfig.PopupZIndex + 2
	end

	local popupImage = popup:FindFirstChild("PopupImage")
	if popupImage then
		popupImage.ZIndex = PopupConfig.PopupZIndex + 2
	end

	popup.Position = getRandomSpawnPosition()
	local targetPosition = getTargetPosition(poopsTarget)

	local entranceTween = TweenService:Create(popup, TweenInfo.new(PopupConfig.EntranceTime, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Size = UDim2.new(0, PopupConfig.EntranceSize[1], 0, PopupConfig.EntranceSize[2]),
		Position = UDim2.new(popup.Position.X.Scale, popup.Position.X.Offset, popup.Position.Y.Scale, popup.Position.Y.Offset - 20),
		Rotation = PopupConfig.PoopsRotation.Middle
	})

	local flyTween = TweenService:Create(popup, TweenInfo.new(PopupConfig.FlightTime, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Position = targetPosition,
		Size = UDim2.new(0, PopupConfig.FlightEndSize[1], 0, PopupConfig.FlightEndSize[2]),
		GroupTransparency = 1,
		Rotation = PopupConfig.PoopsRotation.End
	})

	entranceTween:Play()
	entranceTween.Completed:Connect(function()
		wait(PopupConfig.PauseTime)
		spawn(function()
			wait(PopupConfig.SoundDelay)
			playPopupSound("Poops")
		end)
		flyTween:Play()
	end)

	flyTween.Completed:Connect(function()
		popup:Destroy()
	end)
end

-- Enhanced poop detection with error handling
local function setupPoopDetection()
	local success, leaderstats = pcall(function()
		return player:WaitForChild("leaderstats", 30)
	end)

	if not success or not leaderstats then
		warn("Failed to find leaderstats!")
		return
	end

	local poopsValue = leaderstats:WaitForChild("Poops", 10)
	if not poopsValue then
		warn("Failed to find Poops value in leaderstats!")
		return
	end

	local lastPoopsCount = poopsValue.Value
	debugPrint("Initial poop count: " .. lastPoopsCount)

	poopsValue.Changed:Connect(function(newValue)
		debugPrint("Poops changed from " .. lastPoopsCount .. " to " .. newValue)
		local difference = newValue - lastPoopsCount
		if difference > 0 then
			createPoopsPopup(difference)
		end
		lastPoopsCount = newValue
	end)

	debugPrint("✅ Poop detection setup successfully")
end

-- Setup poop detection
setupPoopDetection()

-- Set template properties
pooBucksTemplate.Visible = false
pooBucksTemplate.GroupTransparency = 0
pooBucksTemplate.Rotation = 0
  -  Edit
  12:31:15.418  poopsTemplate.Visible = false  
poopsTemplate.GroupTransparency = 0
poopsTemplate.Rotation = 0

popupScreenGui.Enabled = true

debugPrint("✅ PopupManager initialization complete!")

-- Connection status monitoring
spawn(function()
	wait(15) -- Wait for everything to settle
	if not isConnected then
		warn("⚠️ POPUP SYSTEM WARNING: Not connected to PoopGainPopupEvent after 15 seconds!")
		warn("⚠️ This means your server scripts may not be creating the RemoteEvent properly.")
		debugPrint("Debugging info:")
		debugPrint("- Connection attempts: " .. connectionAttempts)
		debugPrint("- ShopConfig loaded: " .. tostring(ShopConfig ~= nil))
		debugPrint("- ReplicatedStorage children: " .. table.concat(ReplicatedStorage:GetChildren(), ", "))
	else
		debugPrint("✅ Popup system fully operational!")
	end
end)

>>> game.StarterGui.RebirthGui.RebirthClient (LocalScript) — 635 lines
-- RebirthClient (LocalScript in StarterGui.RebirthGui.RebirthClient) - FIXED BUTTON SCALING
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera
local playerGui = player:WaitForChild("PlayerGui")
local rebirthGui = script.Parent

-- Get ShopConfig
local ShopConfig = require(ReplicatedStorage:WaitForChild("ShopConfig"))

-- Debug system
local function debugPrint(message)
	if ShopConfig.Debug.Enabled and ShopConfig.Debug.ShowRebirthDebug then
		print("[REBIRTH CLIENT]: " .. message)
	end
end

-- GUI References
local screenButtonsGui = playerGui:WaitForChild("ScreenButtonsGui")
local buttonBackground = screenButtonsGui:WaitForChild("Background")
local rebirthButtonMain = buttonBackground:WaitForChild("RebirthButtonOpen/Close")
local rebirthBackground = rebirthGui:WaitForChild("Rebirthbackground")
local rebirthTitle = rebirthBackground:WaitForChild("RebirthTitle")
local exitButton = rebirthBackground:WaitForChild("ExitButton")
local rebirthDescription = rebirthBackground:WaitForChild("RebirthDescription")
local multiplierChange = rebirthBackground:WaitForChild("MultiplierChange")
local bar = rebirthBackground:WaitForChild("Bar")
local rebirthCost = rebirthBackground:WaitForChild("RebirthCost")
local rebirthBarPercentage = rebirthBackground:WaitForChild("RebirthbBarPercentage")
local cosmeticImageLabel = rebirthBackground:WaitForChild("CosmeticImageLabel")
local multiplierTextLabel = rebirthBackground:WaitForChild("DisplayerLabel")
local rebirthButton = rebirthBackground:WaitForChild("RebirthButton")

-- CREATE PROGRESS BAR OURSELVES
local barFramePercentage = Instance.new("Frame")
barFramePercentage.Name = "BarFramePercentage"
barFramePercentage.Size = UDim2.new(0, 0, 1, 0) -- Start at 0 width
barFramePercentage.Position = UDim2.new(0, 0, 0, 0)
barFramePercentage.BackgroundColor3 = Color3.fromRGB(46, 125, 50) -- Green
barFramePercentage.BorderSizePixel = 0
barFramePercentage.Parent = bar

-- Add gradient to the bar for a nicer look
local gradient = Instance.new("UIGradient")
gradient.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0, Color3.fromRGB(85, 255, 127)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(46, 125, 50))
}
gradient.Rotation = 90
gradient.Parent = barFramePercentage

-- Add corner rounding to match the parent
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 4)
corner.Parent = barFramePercentage

debugPrint("Created custom progress bar")

-- GUI References
local screenButtonsGui
local buttonBackground

-- Add a timeout mechanism
spawn(function()
	local startTime = tick()
	while not screenButtonsGui do
		screenButtonsGui = playerGui:FindFirstChild("ScreenButtonsGui")
		if screenButtonsGui then break end
		if tick() - startTime > 10 then
			warn("[RebirthClient] Could not find ScreenButtonsGui after 10 seconds")
			return
		end
		wait(0.1)
	end

	if screenButtonsGui then
		buttonBackground = screenButtonsGui:WaitForChild("Background", 5)
		if not buttonBackground then
			warn("[RebirthClient] Could not find Background after 5 seconds")
		end
	end
end)

-- Wait for RemoteEvents
local RebirthRequest = ReplicatedStorage:WaitForChild("RebirthRequest")
local GetRebirthInfo = ReplicatedStorage:WaitForChild("GetRebirthInfo")

-- State
local isRebirthFrameOpen = false
local updateConnection = nil
local isAnimating = false
local rebirthDebounce = false
local openCloseDebounce = false

-- Store original properties
local originalRebirthSize = rebirthBackground.Size
local originalRebirthPosition = rebirthBackground.Position
local originalFOV = camera.FieldOfView
local originalGUIs = {}
local originalBlurSize = 0
local blur = nil

-- MEMORY MANAGEMENT
local connections = {}
local function cleanupConnections()
	for _, connection in pairs(connections) do
		if connection then
			connection:Disconnect()
		end
	end
	connections = {}
end

-- Initialize state
rebirthBackground.Visible = false
multiplierTextLabel.Text = "1x"

debugPrint("RebirthClient initialized")

-- Create or get blur effect
local function setupBlur()
	blur = Lighting:FindFirstChild("Blur")
	if not blur then
		blur = Instance.new("BlurEffect")
		blur.Name = "Blur"
		blur.Size = 0
		blur.Parent = Lighting
	end
	originalBlurSize = blur.Size
end

setupBlur()

-- Create sounds
local rebirthSuccessSound = Instance.new("Sound")
rebirthSuccessSound.SoundId = ShopConfig.Sounds.RebirthSuccess
rebirthSuccessSound.Volume = ShopConfig.Sounds.Volumes.Rebirth
rebirthSuccessSound.Parent = workspace

local rebirthFailSound = Instance.new("Sound")
rebirthFailSound.SoundId = ShopConfig.Sounds.RebirthFail
rebirthFailSound.Volume = ShopConfig.Sounds.Volumes.Rebirth
rebirthFailSound.Parent = workspace

-- ═══════════════════════════════════════════════════════════════
-- 🔧 FIXED BUTTON EFFECTS SYSTEM - NO MORE SHRINKING TO 0!
-- ═══════════════════════════════════════════════════════════════

local buttonEffects = {} -- Track button effects

local function createButtonEffects(button)
	-- Skip if button already has effects or doesn't exist
	if not button or buttonEffects[button] then return end

	-- Store ABSOLUTE original properties (not relative)
	local originalSize = button.Size
	local originalPosition = button.Position
	local originalColor = button.BackgroundColor3
	local originalRotation = button.Rotation

	local isHovering = false
	local currentTween = nil
	local clickTween = nil

	debugPrint("Setting up button effects for: " .. button.Name)
	debugPrint("Original size: " .. tostring(originalSize))

	-- Cancel any existing tween
	local function cancelCurrentTweens()
		if currentTween then
			currentTween:Cancel()  -  Edit
  12:31:15.418  			currentTween = nil
		end
		if clickTween then
			clickTween:Cancel()
			clickTween = nil
		end
	end

	-- Safe hover scale (limit to reasonable values)
	local function getHoverScale()
		local config = ShopConfig.Tweens and ShopConfig.Tweens.ButtonHover
		if config and config.ScaleMultiplier then
			-- Clamp between 1.01 and 1.15 for safety
			return math.max(1.01, math.min(config.ScaleMultiplier, 1.15))
		end
		return 1.05 -- Safe default
	end

	-- Safe click scale (limit to reasonable values)
	local function getClickScale()
		local config = ShopConfig.Tweens and ShopConfig.Tweens.ButtonClick
		if config and config.ScaleMultiplier then
			-- Clamp between 0.90 and 0.98 for safety
			return math.max(0.90, math.min(config.ScaleMultiplier, 0.98))
		end
		return 0.95 -- Safe default
	end

	-- Calculate scaled size safely
	local function getScaledSize(scale)
		return UDim2.new(
			originalSize.X.Scale * scale,
			originalSize.X.Offset * scale,
			originalSize.Y.Scale * scale,
			originalSize.Y.Offset * scale
		)
	end

	-- Mouse Enter (Hover)
	local mouseEnterConnection = button.MouseEnter:Connect(function()
		if isHovering then return end
		isHovering = true

		cancelCurrentTweens()

		local scale = getHoverScale()
		local targetSize = getScaledSize(scale)
		local targetColor = originalColor:lerp(Color3.new(1, 1, 1), 0.1)

		debugPrint("Hover enter - Scale: " .. scale .. ", Target size: " .. tostring(targetSize))

		local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		currentTween = TweenService:Create(button, tweenInfo, {
			Size = targetSize,
			BackgroundColor3 = targetColor
		})
		currentTween:Play()
	end)

	-- Mouse Leave (Stop Hover)
	local mouseLeaveConnection = button.MouseLeave:Connect(function()
		if not isHovering then return end
		isHovering = false

		cancelCurrentTweens()

		debugPrint("Hover leave - Restoring to: " .. tostring(originalSize))

		local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		currentTween = TweenService:Create(button, tweenInfo, {
			Size = originalSize,
			BackgroundColor3 = originalColor,
			Rotation = originalRotation
		})
		currentTween:Play()
	end)

	-- Mouse Button Down (Click Press)
	local mouseDownConnection = button.MouseButton1Down:Connect(function()
		cancelCurrentTweens()

		local scale = getClickScale()
		local targetSize = getScaledSize(scale)

		debugPrint("Click down - Scale: " .. scale .. ", Target size: " .. tostring(targetSize))

		local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		clickTween = TweenService:Create(button, tweenInfo, {
			Size = targetSize,
			Rotation = originalRotation + math.random(-2, 2)
		})
		clickTween:Play()
	end)

	-- Mouse Button Up (Click Release)
	local mouseUpConnection = button.MouseButton1Up:Connect(function()
		cancelCurrentTweens()

		-- Determine target based on hover state
		local targetSize = originalSize
		local targetColor = originalColor

		if isHovering then
			local scale = getHoverScale()
			targetSize = getScaledSize(scale)
			targetColor = originalColor:lerp(Color3.new(1, 1, 1), 0.1)
		end

		debugPrint("Click up - Restoring to: " .. tostring(targetSize))

		local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
		currentTween = TweenService:Create(button, tweenInfo, {
			Size = targetSize,
			BackgroundColor3 = targetColor,
			Rotation = originalRotation
		})
		currentTween:Play()
	end)

	-- Store effect data for cleanup
	buttonEffects[button] = {
		mouseEnter = mouseEnterConnection,
		mouseLeave = mouseLeaveConnection,
		mouseDown = mouseDownConnection,
		mouseUp = mouseUpConnection,
		cleanup = function()
			cancelCurrentTweens()
			mouseEnterConnection:Disconnect()
			mouseLeaveConnection:Disconnect()
			mouseDownConnection:Disconnect()
			mouseUpConnection:Disconnect()
			buttonEffects[button] = nil
		end
	}

	-- Store connections for global cleanup
	table.insert(connections, mouseEnterConnection)
	table.insert(connections, mouseLeaveConnection)
	table.insert(connections, mouseDownConnection)
	table.insert(connections, mouseUpConnection)
end

-- Function to format large numbers
local function formatNumber(num)
	if num >= 1e12 then
		return string.format("%.1fT", num / 1e12)
	elseif num >= 1e9 then
		return string.format("%.1fB", num / 1e9)
	elseif num >= 1e6 then
		return string.format("%.1fM", num / 1e6)
	elseif num >= 1e3 then
		return string.format("%.1fK", num / 1e3)
	else
		return tostring(math.floor(num))
	end
end

-- Function to update rebirth info
local function updateRebirthInfo()
	if not isRebirthFrameOpen then return nil end

	local success, rebirthInfo = pcall(function()
		return GetRebirthInfo:InvokeServer()
	end)

	if success and rebirthInfo then
		-- Update multiplier display
		multiplierTextLabel.Text = string.format("%.1fx", rebirthInfo.currentMultiplier)

		-- Update rebirth frame
		rebirthCost.Text = "Price: " .. formatNumber(rebirthInfo.rebirthCost)
		multiplierChange.Text = string.format("%.1fx  ->  %.1fx", rebirthInfo.currentMultiplier, rebirthInfo.nextMultiplier)

		-- Update progress bar percentage text
		local percentage = math.min(100, rebirthInfo.percentage)
		rebirthBarPercentage.Text = string.format("%.0f%%", percentage)

		-- Animate bar with exact width calculation
		local barPercentage = percentage / 100
		local targetSize = UDim2.new(barPercentage, 0, 1, 0)

		local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		local barTween = TweenService:Create(barFramePercentage, tweenInfo, {Size = targetSize})
		barTween:Play()

		-- Update button state
		if rebirthButton:IsA("TextButton") then
			if rebirthInfo.canRebirth then
				rebirthButton.Text = "REBIRTH"
				rebirthButton.BackgroundColor3 = Color3.fromRGB(46, 125, 50) -- Green
			else
				rebirthButton.Text = "CAN'T REBIRTH"
				rebirthButton.BackgroundColor3 = Color3.fromRGB(158, 158, 158) -- Gray
			end
		elseif rebirthButton:IsA("ImageButton") then
			if rebirthInfo.canRebirth then
				rebirthButton.BackgroundColor3 = Color3.fromRGB(46, 125, 50) -- Green
			else
				rebirthButton.BackgroundColor3 = Color3.fromRGB(158, 158, 158) -- Gray
			end  -  Edit
  12:31:15.418  		end

		return rebirthInfo
	else
		debugPrint("Failed to get rebirth info")
		return nil
	end
end

-- Shop-like effects for rebirth frame
local function openRebirthFrame()
	if isRebirthFrameOpen or isAnimating or openCloseDebounce then return end
	openCloseDebounce = true
	isAnimating = true
	isRebirthFrameOpen = true

	debugPrint("Opening rebirth frame")

	-- Store original GUI states and disable them
	originalGUIs = {}
	for _, gui in pairs(playerGui:GetChildren()) do
		if gui:IsA("ScreenGui") and gui ~= rebirthGui and gui.Enabled then
			originalGUIs[gui] = true
			gui.Enabled = false
		end
	end

	-- Setup initial state
	rebirthBackground.Size = UDim2.new(0, 0, 0, 0)
	rebirthBackground.Position = UDim2.new(0.5, 0, 0.5, 0)
	rebirthBackground.Visible = true

	-- Open animation with shop-like effects
	local openConfig = ShopConfig.Tweens.RebirthOpen
	local tweenInfo = TweenInfo.new(openConfig.Duration, openConfig.EasingStyle, openConfig.EasingDirection)

	local rebirthTween = TweenService:Create(rebirthBackground, tweenInfo, {
		Size = originalRebirthSize,
		Position = originalRebirthPosition
	})

	-- FOV and blur effects
	local fovTween = TweenService:Create(camera, tweenInfo, {
		FieldOfView = ShopConfig.Tweens.ShopOpen.FOV
	})

	local blurTween = TweenService:Create(blur, tweenInfo, {
		Size = ShopConfig.Tweens.ShopOpen.BlurSize
	})

	rebirthTween:Play()
	fovTween:Play()
	blurTween:Play()

	rebirthTween.Completed:Connect(function()
		isAnimating = false
		spawn(function()
			wait(0.5)
			openCloseDebounce = false
		end)
	end)

	-- Start updating rebirth info
	updateRebirthInfo()
	updateConnection = RunService.Heartbeat:Connect(function()
		updateRebirthInfo()
	end)
end

local function closeRebirthFrame()
	if not isRebirthFrameOpen or isAnimating or openCloseDebounce then return end
	openCloseDebounce = true
	isAnimating = true
	isRebirthFrameOpen = false

	debugPrint("Closing rebirth frame")

	-- Stop updating
	if updateConnection then
		updateConnection:Disconnect()
		updateConnection = nil
	end

	-- Close animation with shop-like effects
	local closeConfig = ShopConfig.Tweens.RebirthClose
	local tweenInfo = TweenInfo.new(closeConfig.Duration, closeConfig.EasingStyle, closeConfig.EasingDirection)

	local rebirthTween = TweenService:Create(rebirthBackground, tweenInfo, {
		Size = UDim2.new(0, 0, 0, 0),
		Position = UDim2.new(0.5, 0, 0.5, 0)
	})

	-- Restore FOV and blur
	local fovTween = TweenService:Create(camera, tweenInfo, {
		FieldOfView = originalFOV
	})

	local blurTween = TweenService:Create(blur, tweenInfo, {
		Size = originalBlurSize
	})

	rebirthTween:Play()
	fovTween:Play()
	blurTween:Play()

	rebirthTween.Completed:Connect(function()
		rebirthBackground.Visible = false

		-- Restore original GUIs
		for gui, _ in pairs(originalGUIs) do
			if gui and gui.Parent then
				gui.Enabled = true
			end
		end
		originalGUIs = {}

		rebirthBackground.Size = originalRebirthSize
		rebirthBackground.Position = originalRebirthPosition
		isAnimating = false

		spawn(function()
			wait(0.5)
			openCloseDebounce = false
		end)
	end)
end

-- Function to perform rebirth with debounce
local function performRebirth()
	if rebirthDebounce then
		debugPrint("Rebirth on cooldown")
		return
	end

	local rebirthInfo = updateRebirthInfo()
	if not rebirthInfo or not rebirthInfo.canRebirth then
		rebirthFailSound:Play()
		debugPrint("Cannot rebirth: " .. (rebirthInfo and rebirthInfo.reason or "Unknown reason"))
		return
	end

	rebirthDebounce = true
	debugPrint("Attempting rebirth...")

	-- Update button to show it's processing
	if rebirthButton:IsA("TextButton") then
		rebirthButton.Text = "PROCESSING..."
		rebirthButton.BackgroundColor3 = Color3.fromRGB(255, 193, 7) -- Yellow
	else
		rebirthButton.BackgroundColor3 = Color3.fromRGB(255, 193, 7)
	end

	local success, result = pcall(function()
		return RebirthRequest:InvokeServer()
	end)

	if success and result then
		rebirthSuccessSound:Play()
		debugPrint("Rebirth successful!")

		if rebirthButton:IsA("TextButton") then
			rebirthButton.Text = "SUCCESS!"
			rebirthButton.BackgroundColor3 = Color3.fromRGB(76, 175, 80)
		else
			rebirthButton.BackgroundColor3 = Color3.fromRGB(76, 175, 80)
		end

		spawn(function()
			wait(2)
			rebirthDebounce = false
			updateRebirthInfo()
		end)
	else
		rebirthFailSound:Play()
		debugPrint("Rebirth failed: " .. tostring(result))

		if rebirthButton:IsA("TextButton") then
			rebirthButton.Text = "FAILED!"
			rebirthButton.BackgroundColor3 = Color3.fromRGB(244, 67, 54)
		else
			rebirthButton.BackgroundColor3 = Color3.fromRGB(244, 67, 54)
		end

		spawn(function()
			wait(2)
			rebirthDebounce = false
			updateRebirthInfo()
		end)
	end
end

-- Setup button effects for rebirth GUI buttons ONLY
createButtonEffects(exitButton)
createButtonEffects(rebirthButton)

-- Setup button effects for main screen buttons
spawn(function()
	-- Wait for buttonBackground to be available
	while not buttonBackground do
		wait(0.1)  -  Edit
  12:31:15.418  	end

	-- Add safety check and effects
	if buttonBackground then
		local mainButtons = buttonBackground:GetChildren()
		for _, button in pairs(mainButtons) do
			if button:IsA("ImageButton") or button:IsA("TextButton") then
				createButtonEffects(button)
			end
		end
		debugPrint("Set up effects for " .. #mainButtons .. " main screen buttons")
	else
		warn("[RebirthClient] ButtonBackground not found when setting up button effects")
	end
end)

-- Button connections
table.insert(connections, rebirthButtonMain.MouseButton1Click:Connect(function()
	if isRebirthFrameOpen then
		closeRebirthFrame()
	else
		openRebirthFrame()
	end
end))

table.insert(connections, exitButton.MouseButton1Click:Connect(function()
	closeRebirthFrame()
end))

table.insert(connections, rebirthButton.MouseButton1Click:Connect(performRebirth))

-- Initial multiplier update
spawn(function()
	wait(2) -- Wait for leaderstats to load
	updateRebirthInfo()

	-- Update multiplier display every few seconds
	while true do
		wait(3)
		if not isRebirthFrameOpen then
			updateRebirthInfo()
		end
	end
end)

-- Cleanup on player leaving
table.insert(connections, Players.PlayerRemoving:Connect(function(removingPlayer)
	if removingPlayer == player then
		cleanupConnections()
		-- Cleanup button effects
		for button, effect in pairs(buttonEffects) do
			if effect.cleanup then
				effect.cleanup()
			end
		end
	end
end))

debugPrint("RebirthClient setup complete!")

>>> game.StarterGui.SettingsGui.SettingsBackground.Background.FeedbackClient (LocalScript) — 61 lines
--// Variables and Serivces

local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local UI = script.Parent
local SFX = script.Parent.SFX
local FeedbackFrame = UI:WaitForChild("FeedbackFrame")
local FeedbackBox = FeedbackFrame:WaitForChild("FeedbackBox")
local SubmitButton = FeedbackFrame:WaitForChild("FeedbackButton")
local CloseButton = FeedbackFrame:WaitForChild("CancelButton")
local OpenButton = UI:WaitForChild("ToggleButton")
local ErrorText = FeedbackFrame:WaitForChild("ErrorText")

--// Code

SubmitButton.Activated:Connect(function()
	local CheckText = CheckForErrors(FeedbackBox.Text)
	if not CheckText then return end

	script.Parent.FeedbackServer.FeedbackEvent:FireServer(CheckText)
end)

function CheckForErrors(Text)
	local Results = script.Parent.FeedbackServer.CheckTextEvent:InvokeServer(Text)

	if Results.Value == true then
		if #Text ~= 0 then
			return Results.FilteredText
		else
			Error("Feedback is Empty") 
			return false
		end
	else
		Error("Text has been filtered or failed") 
		return false
	end
end

function Error(Text)
	SFX.ErrorSFX:Play()
	ErrorText.Text = Text
	ErrorText.Visible = true
	task.wait(1)
	ErrorText.Visible = false
end

script.Parent.FeedbackServer.ErrorMessage.OnClientEvent:Connect(Error)

script.Parent.FeedbackServer.FeedbackEvent.OnClientEvent:Connect(function(Value)
	if not Value then return end
	FeedbackFrame.Visible = false
end)

CloseButton.Activated:Connect(function()
	FeedbackFrame.Visible = false
end)

OpenButton.Activated:Connect(function()
	FeedbackFrame.Visible = not FeedbackFrame.Visible
end)

>>> game.StarterGui.SettingsGui.SettingsBackground.Background.FeedbackFrame.CancelButton.Hover (LocalScript) — 32 lines
--// Services and Variables

local TweenService = game:GetService("TweenService")
local SFX = script.Parent.Parent.Parent.SFX
local Button = script.Parent
local OriginalSize = Button.Size

local hoverSize = UDim2.new(OriginalSize.X.Scale * 1.1, OriginalSize.X.Offset, OriginalSize.Y.Scale * 1.1, OriginalSize.Y.Offset)
local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

local hoverTween = TweenService:Create(Button, tweenInfo, { Size = hoverSize })
local leaveTween = TweenService:Create(Button, tweenInfo, { Size = OriginalSize })

--// Functions

function OnHover()
	hoverTween:Play()
	SFX.ButtonHoverFX:Play()
end

function OnLeave()
	leaveTween:Play()
end

function OnClick()
	SFX.ButtonClickFX:Play()
end

Button.MouseEnter:Connect(OnHover)
Button.MouseLeave:Connect(OnLeave)
Button.MouseButton1Click:Connect(OnClick)


>>> game.StarterGui.SettingsGui.SettingsBackground.Background.FeedbackFrame.FeedbackButton.Hover (LocalScript) — 32 lines
--// Services and Variables

local TweenService = game:GetService("TweenService")
local SFX = script.Parent.Parent.Parent.SFX
local Button = script.Parent
local OriginalSize = Button.Size

local hoverSize = UDim2.new(OriginalSize.X.Scale * 1.1, OriginalSize.X.Offset, OriginalSize.Y.Scale * 1.1, OriginalSize.Y.Offset)
local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

local hoverTween = TweenService:Create(Button, tweenInfo, { Size = hoverSize })
local leaveTween = TweenService:Create(Button, tweenInfo, { Size = OriginalSize })

--// Functions

function OnHover()
	hoverTween:Play()
	SFX.ButtonHoverFX:Play()
end

function OnLeave()
	leaveTween:Play()
end

function OnClick()
	SFX.ButtonClickFX:Play()
end

Button.MouseEnter:Connect(OnHover)
Button.MouseLeave:Connect(OnLeave)
Button.MouseButton1Click:Connect(OnClick)


>>> game.StarterGui.SettingsGui.SettingsBackground.Background.FeedbackServer (Script) — 90 lines
--// Services
local HttpService = game:GetService("HttpService")
local TextService = game:GetService("TextService")
local DataStoreService = game:GetService("DataStoreService")
local CooldownStore = DataStoreService:GetDataStore("FeedbackCooldown")

--// Webhook & Events
local WebhookURL = "https://discord.com/api/webhooks/1403018188966334566/I0Z_h1zXwDLTEVYg8NJQltZJekoUOgQ6FhWELmjLMddBPJPdNBqE4DUrlUz69Rv9PRsW"  -  Edit
  12:31:15.419  local FeedbackEvent = script:WaitForChild("FeedbackEvent")
local CheckTextEvent = script:WaitForChild("CheckTextEvent")

--// Constants
local COOLDOWN_SECONDS = 560

--// Functions
function PostToDiscord(Player, Message)
	local now = os.time()
	local userId = Player.UserId

	local success, lastTime = pcall(function()
		return CooldownStore:GetAsync("Cooldown_" .. userId)
	end)

	if success and lastTime then
		local timeSince = now - lastTime
		if timeSince < COOLDOWN_SECONDS then
			local remaining = COOLDOWN_SECONDS - timeSince
			if remaining < 3600 then
				local mins = math.ceil(remaining / 60)
				script.ErrorMessage:FireClient(Player, "Cooldown: " .. mins .. " minute(s)")
			else
				local hours = math.floor(remaining / 3600)
				local mins = math.floor((remaining % 3600) / 60)
				script.ErrorMessage:FireClient(Player, "Cooldown: " .. hours .. " hour(s) and " .. mins .. " minute(s)")
			end
			return
		end
	end
	
	local Data = {
		["embeds"] = {{
			["title"] = "📬 Feedback Received",
			["description"] = Message,
			["color"] = 0xFFFFFF,
			["footer"] = {
				["text"] = "Submitted by " .. Player.Name
			},
			["timestamp"] = DateTime.now():ToIsoDate()
		}}
	}

	local jsonData = HttpService:JSONEncode(Data)
	local postSuccess, postError = pcall(function()
		HttpService:PostAsync(WebhookURL, jsonData)
	end)

	if not postSuccess then
		warn("Discord webhook failed: " .. tostring(postError))
	else
		script.FeedbackEvent:FireClient(Player, true)
	end

	pcall(function()
		CooldownStore:SetAsync("Cooldown_" .. userId, now)
	end)
end

FeedbackEvent.OnServerEvent:Connect(PostToDiscord)

--// Filtering
CheckTextEvent.OnServerInvoke = function(player, text)
	local filteredText = ""
	local success, errorMessage = pcall(function()
		local filterResult = TextService:FilterStringAsync(text, player.UserId)
		filteredText = filterResult:GetNonChatStringForBroadcastAsync()
	end)

	if success then
		return {
			Value = true,
			FilteredText = filteredText
		}
	else
		return {
			Value = false,
			Error = errorMessage
		}
	end
end


>>> game.StarterGui.SettingsGui.SettingsBackground.Background.ToggleButton.GuiEffect (LocalScript) — 66 lines
local Gui = script.Parent

local OriginalSize = Gui.Size
local HoverScaleFactor = 0.9  -- Scale factor when hovered
local ClickScaleFactor = 1.1  -- Scale factor when clicked
local TweenTime = 0.1

local TweenService = game:GetService("TweenService")
local IsClicked = false  -- Track if the GUI is clicked

local Gui = script.Parent

local OriginalSize = Gui.Size
local HoverScaleFactor = 0.9  -- Scale factor when hovered
local ClickScaleFactor = 1.1  -- Scale factor when clicked
local TweenTime = 0.1

local TweenService = game:GetService("TweenService")
local IsClicked = false  -- Track if the GUI is clicked

local function ScaleHover()
	if not IsClicked then  -- Only scale down if not clicked
		local NewSize = UDim2.new(
			OriginalSize.X.Scale * HoverScaleFactor, 
			OriginalSize.X.Offset * HoverScaleFactor, 
			OriginalSize.Y.Scale * HoverScaleFactor, 
			OriginalSize.Y.Offset * HoverScaleFactor
		)
		TweenService:Create(Gui, TweenInfo.new(TweenTime), {Size = NewSize}):Play()
	end
end

local function ScaleDownHover()
	if not IsClicked then  -- Only reset size if not clicked
		TweenService:Create(Gui, TweenInfo.new(TweenTime), {Size = OriginalSize}):Play()
	end
end

local function ScaleClick()
	IsClicked = true  -- Mark as clicked
	local NewSize = UDim2.new(
		OriginalSize.X.Scale * ClickScaleFactor, 
		OriginalSize.X.Offset * ClickScaleFactor, 
		OriginalSize.Y.Scale * ClickScaleFactor, 
		OriginalSize.Y.Offset * ClickScaleFactor
	)
	TweenService:Create(Gui, TweenInfo.new(TweenTime), {Size = NewSize}):Play()

	task.wait(TweenTime)  -- Wait for the scaling up tween to complete

	-- Return to the original size after the click animation
	TweenService:Create(Gui, TweenInfo.new(TweenTime), {Size = OriginalSize}):Play()
	task.wait(TweenTime)  -- Wait for the reset tween to complete

	IsClicked = false  -- Reset click state

	-- Check if the mouse is still hovering, and if so, apply the hover scale
	if Gui:IsMouseOver() then
		ScaleHover()
	end
end

Gui.MouseEnter:Connect(ScaleHover)
Gui.MouseLeave:Connect(ScaleDownHover)
Gui.MouseButton1Click:Connect(ScaleClick)


>>> game.StarterGui.ShopGui.ShopFrame.CanvasBackground.PoopsScrollingFrame.Background.BlackHolePoopButton.ViewportFrame.BlackHolePoop.AutoPrimaryScript (Script) — 23 lines
-- Replace 'YourModelName' with the actual name of your model
local model = script.Parent

-- Create the new part
local mainPart = Instance.new("Part")
mainPart.Name = "Main"
mainPart.Size = Vector3.new(1, 1, 1)
mainPart.Transparency = 1  -- Makes it invisible
mainPart.CanCollide = false  -- Makes it non-collidable
mainPart.Anchored = true  -- Anchored so it doesn't fall

-- Parent to workspace temporarily
mainPart.Parent = workspace

-- Get the model's center position
local modelCFrame = model:GetModelCFrame()
mainPart.CFrame = modelCFrame

-- Parent the part into the model
mainPart.Parent = model

-- Set the model's PrimaryPart to this new part
model.PrimaryPart = mainPart

>>> game.StarterGui.ShopGui.ShopFrame.CanvasBackground.PoopsScrollingFrame.Background.BlackHolePoopButton.ViewportFrame.BlackHolePoop.SpinScript (Script) — 18 lines
local RunService = game:GetService("RunService")

-- Replace 'YourModelName' with your model's name
local model = script.Parent

local rotationSpeed = 0.5 -- Rotations per second
local connection

connection = RunService.Heartbeat:Connect(function(deltaTime)
	local currentCFrame = model:GetPivot()
	local rotationAmount = math.rad(360 * rotationSpeed * deltaTime)
	local newCFrame = currentCFrame * CFrame.Angles(0, rotationAmount, 0)

	model:PivotTo(newCFrame)
end)

-- To stop the rotation, run: connection:Disconnect()
print("Model is now rotating continuously. Run 'connection:Disconnect()' to stop.")

>>> game.StarterGui.ShopGui.ShopFrame.CanvasBackground.PoopsScrollingFrame.Background.BloodyPoopButton.ViewportFrame.BloodyPoop.AutoPrimaryScript (Script) — 23 lines
-- Replace 'YourModelName' with the actual name of your model
local model = script.Parent
  -  Edit
  12:31:15.421  -- Create the new part
local mainPart = Instance.new("Part")
mainPart.Name = "Main"
mainPart.Size = Vector3.new(1, 1, 1)
mainPart.Transparency = 1  -- Makes it invisible
mainPart.CanCollide = false  -- Makes it non-collidable
mainPart.Anchored = true  -- Anchored so it doesn't fall

-- Parent to workspace temporarily
mainPart.Parent = workspace

-- Get the model's center position
local modelCFrame = model:GetModelCFrame()
mainPart.CFrame = modelCFrame

-- Parent the part into the model
mainPart.Parent = model

-- Set the model's PrimaryPart to this new part
model.PrimaryPart = mainPart

>>> game.StarterGui.ShopGui.ShopFrame.CanvasBackground.PoopsScrollingFrame.Background.BloodyPoopButton.ViewportFrame.BloodyPoop.SpinScript (Script) — 18 lines
local RunService = game:GetService("RunService")

-- Replace 'YourModelName' with your model's name
local model = script.Parent

local rotationSpeed = 0.5 -- Rotations per second
local connection

connection = RunService.Heartbeat:Connect(function(deltaTime)
	local currentCFrame = model:GetPivot()
	local rotationAmount = math.rad(360 * rotationSpeed * deltaTime)
	local newCFrame = currentCFrame * CFrame.Angles(0, rotationAmount, 0)

	model:PivotTo(newCFrame)
end)

-- To stop the rotation, run: connection:Disconnect()
print("Model is now rotating continuously. Run 'connection:Disconnect()' to stop.")

>>> game.StarterGui.ShopGui.ShopScript (LocalScript) — 955 lines
-- ShopScript (LocalScript in StarterGui.ShopGUI) - UPDATED WITH BOOST LOCK CHECKING
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local SoundService = game:GetService("SoundService")
local Lighting = game:GetService("Lighting")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera
local shopGUI = script.Parent
local ShopConfig = require(ReplicatedStorage:WaitForChild("ShopConfig"))

-- Debug system
local function debugPrint(message)
	if ShopConfig.Debug.Enabled and ShopConfig.Debug.ShowShopDebug then
		print("[SHOP CLIENT]: " .. message)
	end
end

-- Store original states
local originalFOV = camera.FieldOfView
local originalGUIs = {}
local originalBlurSize = 0
local blur = nil

-- Animation state management
local isAnimating = false
local isShopOpen = false

-- Button original states storage
local buttonOriginalStates = {}

-- Create or get blur effect
local function setupBlur()
	blur = Lighting:FindFirstChild("Blur")
	if not blur then
		blur = Instance.new("BlurEffect")
		blur.Name = "Blur"
		blur.Size = 0
		blur.Parent = Lighting
	end
	originalBlurSize = blur.Size
end

-- Sound setup
local sounds = {}
for soundName, soundId in pairs(ShopConfig.Sounds) do
	if type(soundId) == "string" and soundId ~= "" then
		local sound = Instance.new("Sound")
		sound.SoundId = soundId
		sound.Volume = ShopConfig.Sounds.Volumes.UI or 0.5
		sound.Parent = workspace
		sounds[soundName] = sound
	end
end

-- Wait for RemoteEvents
local RemoteEvent_OpenShop = ReplicatedStorage:WaitForChild("RemoteEvent_OpenShop")
local PurchaseRequest = ReplicatedStorage:WaitForChild("PurchaseRequest")
local EquipPoopClientEvent = ReplicatedStorage:WaitForChild("EquipPoopClientEvent")
local GetPlayerDataRemote = ReplicatedStorage:WaitForChild("GetPlayerDataRemote")
local PurchaseResultEvent = ReplicatedStorage:WaitForChild("PurchaseResultEvent")
local RemoteEvent_CloseShop = ReplicatedStorage:WaitForChild("RemoteEvent_CloseShop")
local GiftPurchaseRequest = ReplicatedStorage:WaitForChild("GiftPurchaseRequest")
local ValidateUsernameRemote = ReplicatedStorage:WaitForChild("ValidateUsernameRemote")

-- GUI References
local shopFrame = shopGUI:WaitForChild("ShopFrame")
local canvasBackground = shopFrame:WaitForChild("CanvasBackground")
local buttonsBackground = canvasBackground:WaitForChild("ButtonsBackground")
local infoBackground = canvasBackground:WaitForChild("InfoBackground")

-- Tab buttons
local poopsButton = buttonsBackground:WaitForChild("PoopsButton")
local upgradesButton = buttonsBackground:WaitForChild("UpgradesButton")
local gamepassesButton = buttonsBackground:WaitForChild("GamepassesButton")

-- Scrolling frames
local poopsScrollingFrame = canvasBackground:WaitForChild("PoopsScrollingFrame")
local upgradesScrollingFrame = canvasBackground:WaitForChild("UpgradesScrollingFrame")
local gamepassesScrollingFrame = canvasBackground:WaitForChild("GamepassesScrollingFrame")

-- Info panel elements
local poopViewportFrame = infoBackground:WaitForChild("PoopViewportFrame")
local poopImageLabel = infoBackground:WaitForChild("PoopImageLabel")
local nameLabel = infoBackground:WaitForChild("NameLabel")
local descriptionLabel = infoBackground:WaitForChild("DescriptionLabel")
local gainLabel = infoBackground:WaitForChild("GainLabel")
local buyButton = infoBackground:WaitForChild("BuyButton")

-- Gift system elements
local gamepassBuyAndGiftButtons = infoBackground:WaitForChild("GamepassBuyAndGiftButtons")
local giftAPlayerButton = gamepassBuyAndGiftButtons:WaitForChild("GiftAPlayerButton")
local buyGamepassButton = gamepassBuyAndGiftButtons:WaitForChild("BuyGamepassButton")
local giftFrame = canvasBackground:WaitForChild("GiftFrame")
local gamepassTitleTextLabel = giftFrame:WaitForChild("GamepassTitleTextLabel")
local gamepassDescription = giftFrame:WaitForChild("GamepassDescription")
local typePlayerUsernameTextbox = giftFrame:WaitForChild("TypePlayerUsernameTextbox")
local giftAPlayerButtonInFrame = giftFrame:WaitForChild("GiftAPlayerButton")
local exitGiftFrameButton = giftFrame:WaitForChild("ExitGiftFrameButton")

-- Exit button
local exitButton = shopFrame:WaitForChild("ExitButton")

-- State
local currentTab = "Poops"
local selectedItem = nil
local selectedCategory = nil
local playerData = {}
local isGiftFrameOpen = false

debugPrint("ShopScript initialized")

-- Store original properties
local originalShopSize = shopFrame.Size
local originalShopPosition = shopFrame.Position
local originalGiftFrameSize = giftFrame.Size
local originalGiftFramePosition = giftFrame.Position

-- Initialize GUI state
shopGUI.Enabled = false
setupBlur()
giftFrame.Visible = false
gamepassBuyAndGiftButtons.Visible = false

-- NEW: Function to check if boost is locked due to limit
local function isBoostLocked(itemKey)
	if _G.BoostGuiData then
		-- If player already has this boost, not locked
		if _G.BoostGuiData.HasBoost(itemKey) then
			return false
		end
		-- If at limit and doesn't have this boost, locked
		return _G.BoostGuiData.IsAtLimit()
	end
	return false
end

-- FIXED: Button effects that prevent color whitening
local function storeButtonOriginalState(button)
	if not buttonOriginalStates[button] then
		buttonOriginalStates[button] = {
			Size = button.Size,
			BackgroundColor3 = button.BackgroundColor3,
			Rotation = button.Rotation,
			isHovering = false
		}
	end
end

local function setupButtonEffects(button)
	storeButtonOriginalState(button)
	local originalState = buttonOriginalStates[button]

	-- Hover effects
	button.MouseEnter:Connect(function()
		if originalState.isHovering then return end
		originalState.isHovering = true  -  Edit
  12:31:15.421  
		playSound("ButtonHover")

		local hoverConfig = ShopConfig.Tweens.ButtonHover
		local tweenInfo = TweenInfo.new(
			hoverConfig.Duration,
			hoverConfig.EasingStyle,
			hoverConfig.EasingDirection
		)

		local targetColor = originalState.BackgroundColor3:lerp(Color3.new(1, 1, 1), hoverConfig.ColorLerp)

		local tween = TweenService:Create(button, tweenInfo, {
			Size = UDim2.new(
				originalState.Size.X.Scale * hoverConfig.ScaleMultiplier, 
				0, 
				originalState.Size.Y.Scale * hoverConfig.ScaleMultiplier, 
				0
			),
			BackgroundColor3 = targetColor
		})
		tween:Play()
	end)

	button.MouseLeave:Connect(function()
		if not originalState.isHovering then return end
		originalState.isHovering = false

		local hoverConfig = ShopConfig.Tweens.ButtonHover
		local tweenInfo = TweenInfo.new(
			hoverConfig.Duration,
			hoverConfig.EasingStyle,
			hoverConfig.EasingDirection
		)

		local tween = TweenService:Create(button, tweenInfo, {
			Size = originalState.Size,
			BackgroundColor3 = originalState.BackgroundColor3,
			Rotation = originalState.Rotation
		})
		tween:Play()
	end)

	-- Click effects
	button.MouseButton1Down:Connect(function()
		playSound("ButtonClick")

		local clickConfig = ShopConfig.Tweens.ButtonClick
		local tweenInfo = TweenInfo.new(
			clickConfig.Duration,
			clickConfig.EasingStyle,
			clickConfig.EasingDirection
		)

		local tween = TweenService:Create(button, tweenInfo, {
			Size = UDim2.new(
				originalState.Size.X.Scale * clickConfig.ScaleMultiplier, 
				0, 
				originalState.Size.Y.Scale * clickConfig.ScaleMultiplier, 
				0
			),
			Rotation = originalState.Rotation + math.random(-clickConfig.RotationRange, clickConfig.RotationRange)
		})
		tween:Play()
	end)

	button.MouseButton1Up:Connect(function()
		local hoverConfig = ShopConfig.Tweens.ButtonHover
		local tweenInfo = TweenInfo.new(
			hoverConfig.Duration,
			Enum.EasingStyle.Back,
			Enum.EasingDirection.Out
		)

		local targetSize = originalState.isHovering and 
			UDim2.new(
				originalState.Size.X.Scale * hoverConfig.ScaleMultiplier, 
				0, 
				originalState.Size.Y.Scale * hoverConfig.ScaleMultiplier, 
				0
			) or originalState.Size

		local tween = TweenService:Create(button, tweenInfo, {
			Size = targetSize,
			Rotation = originalState.Rotation
		})
		tween:Play()
	end)
end

-- Animation functions
local function openShopAnimation()
	if isAnimating or isShopOpen then return end

	isAnimating = true
	isShopOpen = true

	originalGUIs = {}
	for _, gui in pairs(player.PlayerGui:GetChildren()) do
		if gui:IsA("ScreenGui") and gui ~= shopGUI and gui.Enabled then
			originalGUIs[gui] = true
			gui.Enabled = false
		end
	end

	shopFrame.Size = UDim2.new(0, 0, 0, 0)
	shopFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
	shopGUI.Enabled = true

	playSound("ShopOpen")

	local openConfig = ShopConfig.Tweens.ShopOpen
	local tweenInfo = TweenInfo.new(openConfig.Duration, openConfig.EasingStyle, openConfig.EasingDirection)

	local shopTween = TweenService:Create(shopFrame, tweenInfo, {
		Size = originalShopSize,
		Position = originalShopPosition
	})

	local fovTween = TweenService:Create(camera, tweenInfo, {
		FieldOfView = openConfig.FOV
	})

	local blurTween = TweenService:Create(blur, tweenInfo, {
		Size = openConfig.BlurSize
	})

	shopTween:Play()
	fovTween:Play()
	blurTween:Play()

	shopTween.Completed:Connect(function()
		isAnimating = false
	end)
end

local function closeShopAnimation()
	if isAnimating or not isShopOpen then return end

	isAnimating = true
	isShopOpen = false

	playSound("ShopClose")

	local closeConfig = ShopConfig.Tweens.ShopClose
	local tweenInfo = TweenInfo.new(closeConfig.Duration, closeConfig.EasingStyle, closeConfig.EasingDirection)

	local shopTween = TweenService:Create(shopFrame, tweenInfo, {
		Size = UDim2.new(0, 0, 0, 0),
		Position = UDim2.new(0.5, 0, 0.5, 0)
	})

	local fovTween = TweenService:Create(camera, tweenInfo, {
		FieldOfView = originalFOV
	})

	local blurTween = TweenService:Create(blur, tweenInfo, {
		Size = originalBlurSize
	})

	shopTween:Play()
	fovTween:Play()
	blurTween:Play()

	shopTween.Completed:Connect(function()
		shopGUI.Enabled = false

		for gui, _ in pairs(originalGUIs) do
			if gui and gui.Parent then
				gui.Enabled = true
			end
		end
		originalGUIs = {}

		shopFrame.Size = originalShopSize
		shopFrame.Position = originalShopPosition
		isAnimating = false
	end)
end

-- Gift frame animations
local function openGiftFrame()
	if isGiftFrameOpen then return end

	isGiftFrameOpen = true
	giftFrame.Size = UDim2.new(0, 0, 0, 0)
	giftFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
	giftFrame.Visible = true

	local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
	local openTween = TweenService:Create(giftFrame, tweenInfo, {
		Size = originalGiftFrameSize,
		Position = originalGiftFramePosition
	})

	openTween:Play()
	typePlayerUsernameTextbox.Text = ""
end

local function closeGiftFrame()  -  Edit
  12:31:15.421  	if not isGiftFrameOpen then return end

	isGiftFrameOpen = false

	local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In)
	local closeTween = TweenService:Create(giftFrame, tweenInfo, {
		Size = UDim2.new(0, 0, 0, 0),
		Position = UDim2.new(0.5, 0, 0.5, 0)
	})

	closeTween:Play()
	closeTween.Completed:Connect(function()
		giftFrame.Visible = false
		giftFrame.Size = originalGiftFrameSize
		giftFrame.Position = originalGiftFramePosition
	end)
end

-- Sound functions
function playSound(soundName)
	if sounds[soundName] then
		sounds[soundName]:Play()
	end
end

-- Function to get fresh player data
local function updatePlayerData()
	local success, data = pcall(function()
		return GetPlayerDataRemote:InvokeServer()
	end)

	if success and data then
		playerData = data
		_G.ClientShopData = data
		debugPrint("Updated client shop data globally")
		return true
	else
		return false
	end
end

local function switchTab(tabName)
	playSound("TabSwitch")

	for buttonName, frameName in pairs(ShopConfig.Tabs) do
		canvasBackground[frameName].Visible = false
	end

	local targetFrame = ShopConfig.Tabs[tabName .. "Button"]
	if targetFrame then
		canvasBackground[targetFrame].Visible = true
		currentTab = tabName
	end

	if isGiftFrameOpen then
		closeGiftFrame()
	end
end

local function updatePreview(category, itemKey)
	if category == "Poops" then
		poopViewportFrame.Visible = true
		poopImageLabel.Visible = false

		for _, child in pairs(poopViewportFrame:GetChildren()) do
			if child:IsA("Model") then
				child:Destroy()
			end
		end

		local config = ShopConfig.Poops[itemKey]
		if config and config.ModelName then
			local poopFolder = ReplicatedStorage:FindFirstChild("PoopFolder")
			if poopFolder then
				local originalModel = poopFolder:FindFirstChild(config.ModelName)
				if originalModel then
					local modelClone = originalModel:Clone()
					modelClone.Parent = poopViewportFrame

					if modelClone.PrimaryPart then
						modelClone.PrimaryPart.Position = ShopConfig.Preview.ModelOffset
						modelClone.PrimaryPart.Orientation = ShopConfig.Preview.ModelRotation
					end
				end
			end
		end
	else
		poopViewportFrame.Visible = false
		poopImageLabel.Visible = true

		local config = nil
		if category == "Upgrades" then
			config = ShopConfig.Upgrades[itemKey]
		elseif category == "Gamepasses" then
			config = ShopConfig.Gamepasses[itemKey]
		elseif category == "Boosts" then
			config = ShopConfig.Boosts[itemKey]
		end

		if config and config.Image then
			poopImageLabel.Image = config.Image
		end
	end
end

-- UPDATED: Info panel with boost locking
local function updateInfoPanel(category, itemKey)
	local config = nil

	if category == "Poops" then
		config = ShopConfig.Poops[itemKey]
	elseif category == "Upgrades" then
		config = ShopConfig.Upgrades[itemKey]
	elseif category == "Gamepasses" then
		config = ShopConfig.Gamepasses[itemKey]
	elseif category == "Boosts" then
		config = ShopConfig.Boosts[itemKey]
	end

	if not config then return end

	nameLabel.Text = config.Name or "Unknown"

	local priceText = ""
	if category == "Gamepasses" or category == "Boosts" then
		priceText = "Price: " .. (config.Price or 0) .. " Robux"
	else
		priceText = "Price: " .. (config.Price or 0) .. " PooBucks"
	end
	descriptionLabel.Text = priceText

	-- Check tier requirements and build requirement text
	local requirementText = ""
	local meetsRequirements = true

	if config.RequiredTier and config.RequiredTier > 0 then
		local requiredItem = config.RequiredUpgrade or config.RequiredGamepass
		if requiredItem then
			local requiredConfig = nil
			local isOwned = false

			if category == "Upgrades" then
				requiredConfig = ShopConfig.Upgrades[requiredItem]
				isOwned = playerData.OwnedUpgrades and table.find(playerData.OwnedUpgrades, requiredItem)
			elseif category == "Gamepasses" then
				requiredConfig = ShopConfig.Gamepasses[requiredItem]
				isOwned = playerData.OwnedGamepasses and table.find(playerData.OwnedGamepasses, requiredItem)
			end

			if requiredConfig then
				if not isOwned then
					requirementText = "\n❌ Requires: " .. requiredConfig.Name
					meetsRequirements = false
				else
					requirementText = "\n✅ Requirement met"
				end
			end
		end
	end

	-- Add stacking information for gamepasses
	local stackingText = ""
	if category == "Gamepasses" and config.Stacking then
		local currentMultiplier = 0
		if playerData.OwnedGamepasses then
			for _, gamepassKey in pairs(playerData.OwnedGamepasses) do
				local gamepassConfig = ShopConfig.Gamepasses[gamepassKey]
				if gamepassConfig and gamepassConfig.Effect == "CurrencyMultiplier" then
					currentMultiplier = currentMultiplier + gamepassConfig.Value
				end
			end
		end

		local newMultiplier = currentMultiplier + config.Value
		if currentMultiplier > 0 then
			stackingText = "\n🔢 Current: " .. currentMultiplier .. "x → New: " .. newMultiplier .. "x"
		else
			stackingText = "\n🔢 Will give: " .. config.Value .. "x earnings"
		end
	end

	-- Add replacement information for upgrades
	local replacementText = ""
	if category == "Upgrades" then
		local hasConflicting = false
		if playerData.OwnedUpgrades then
			for _, upgradeKey in pairs(playerData.OwnedUpgrades) do
				local upgradeConfig = ShopConfig.Upgrades[upgradeKey]
				if upgradeConfig and upgradeConfig.Effect == config.Effect and upgradeKey ~= itemKey then
					replacementText = "\n🔄 Replaces: " .. upgradeConfig.Name
					hasConflicting = true
					break
				end
			end
		end
		if not hasConflicting and config.Value then
			replacementText = "\n Multiplier: " .. config.Value .. " poops"
		end
	end
  -  Edit
  12:31:15.421  	if category == "Poops" then
		gainLabel.Text = "+" .. (config.Gain or 0) .. " PooBucks per poop"
	else
		gainLabel.Text = (config.Description or "") .. requirementText .. stackingText .. replacementText
	end

	-- Handle button visibility and states
	if category == "Gamepasses" or category == "Boosts" then
		buyButton.Visible = false
		gamepassBuyAndGiftButtons.Visible = true

		if category == "Gamepasses" then
			local ownsGamepass = playerData.OwnedGamepasses and table.find(playerData.OwnedGamepasses, itemKey)
			if ownsGamepass then
				buyGamepassButton.Text = "You already own this!"
				buyGamepassButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
			elseif not meetsRequirements then
				buyGamepassButton.Text = "Locked"
				buyGamepassButton.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
			else
				buyGamepassButton.Text = "Buy"
				buyGamepassButton.BackgroundColor3 = Color3.fromRGB(255, 152, 0)
			end
		else -- Boosts
			-- NEW: CHECK FOR BOOST LIMIT
			if isBoostLocked(itemKey) then
				buyGamepassButton.Text = "LOCKED"
				buyGamepassButton.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
			else
				buyGamepassButton.Text = "Buy"
				buyGamepassButton.BackgroundColor3 = Color3.fromRGB(255, 152, 0)
			end
		end
	else
		buyButton.Visible = true
		gamepassBuyAndGiftButtons.Visible = false

		local isOwned = false
		local isEquipped = false

		if category == "Poops" then
			isOwned = playerData.OwnedPoops and table.find(playerData.OwnedPoops, itemKey)
			isEquipped = playerData.EquippedPoop == itemKey

			if isEquipped then
				buyButton.Text = "EQUIPPED"
				buyButton.BackgroundColor3 = Color3.fromRGB(46, 125, 50)
			elseif isOwned then
				buyButton.Text = "EQUIP"
				buyButton.BackgroundColor3 = Color3.fromRGB(25, 118, 210)
			else
				buyButton.Text = "BUY"
				buyButton.BackgroundColor3 = Color3.fromRGB(255, 152, 0)
			end
		else -- Upgrades
			isOwned = playerData.OwnedUpgrades and table.find(playerData.OwnedUpgrades, itemKey)
			if isOwned then
				buyButton.Text = "OWNED"
				buyButton.BackgroundColor3 = Color3.fromRGB(46, 125, 50)
			elseif not meetsRequirements then
				buyButton.Text = "LOCKED"
				buyButton.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
			else
				buyButton.Text = "BUY"
				buyButton.BackgroundColor3 = Color3.fromRGB(255, 152, 0)
			end
		end
	end

	selectedItem = itemKey
	selectedCategory = category
	updatePreview(category, itemKey)
end

-- Setup boost buttons
local function setupBoostButtons()
	local boostsBackground = gamepassesScrollingFrame:FindFirstChild("BoostsBackground")
	if not boostsBackground then return end

	for itemKey, config in pairs(ShopConfig.Boosts) do
		local button = boostsBackground:FindFirstChild(config.ButtonName or (itemKey .. "Button"))
		if button then
			setupButtonEffects(button)
			button.MouseButton1Click:Connect(function()
				updateInfoPanel("Boosts", itemKey)
			end)
		end
	end
end

local function setupItemButtons()
	local correctPoopOrder = {
		{key = "Poop", buttonName = "PoopButton"},
		{key = "StinkyPoop", buttonName = "StinkyPoopButton"},
		{key = "BurntPoop", buttonName = "BurntPoopButton"},
		{key = "WaterPoop", buttonName = "WaterPoopButton"},
		{key = "ShockedPoop", buttonName = "ShockedPoopButton"},
		{key = "HypnosisPoop", buttonName = "HypnosisPoopButton"},
		{key = "HolyPoop", buttonName = "HolyPoopButton"},
		{key = "BloodyPoop", buttonName = "BloodyPoopButton"},
		{key = "DiamondPoop", buttonName = "DiamondPoopButton"},
		{key = "VoidPoop", buttonName = "VoidPoopButton"},
		{key = "GalePoop", buttonName = "GalePoopButton"},
		{key = "BlackHolePoop", buttonName = "BlackHolePoopButton"},
		{key = "MistPoop", buttonName = "MistPoopButton"},
		{key = "SuperPoop", buttonName = "SuperPoopButton"},
		{key = "SmokyPoop", buttonName = "SmokyPoopButton"},
		{key = "WindPoop", buttonName = "WindPoopButton"},
		{key = "WhirlpoolPoop", buttonName = "WhirlpoolPoopButton"},
		{key = "StaticPoop", buttonName = "StaticPoopButton"},
		{key = "StarPoop", buttonName = "StarPoopButton"},
		{key = "GalaxyPoop", buttonName = "GalaxyPoopButton"},
		{key = "HollowPurplePoop", buttonName = "HollowPurplePoopButton"},
		{key = "ExplosionPoop", buttonName = "ExplosionPoopButton"},
		{key = "FlamingPoop", buttonName = "FlamingPoopButton"},
		{key = "EndlessPoop", buttonName = "EndlessPoopButton"},
	}

	for index, poopData in ipairs(correctPoopOrder) do
		local itemKey = poopData.key
		local buttonName = poopData.buttonName

		local button = poopsScrollingFrame.Background:FindFirstChild(buttonName)

		if button and ShopConfig.Poops[itemKey] then
			if not button:GetAttribute("SetupComplete") then
				button:SetAttribute("SetupComplete", true)
				setupButtonEffects(button)

				button.MouseButton1Click:Connect(function()
					updateInfoPanel("Poops", itemKey)
				end)

				button.LayoutOrder = index
			end
		end
	end

	local layout = poopsScrollingFrame.Background:FindFirstChild("UIListLayout")
	if layout then
		layout.SortOrder = Enum.SortOrder.LayoutOrder
	end

	-- Setup Upgrade buttons
	for itemKey, config in pairs(ShopConfig.Upgrades) do
		if itemKey == "2PoopsUpgrade" then
			local button = upgradesScrollingFrame.Background:FindFirstChild(itemKey .. "Button")
			if button then
				setupButtonEffects(button)
				button.MouseButton1Click:Connect(function()
					updateInfoPanel("Upgrades", itemKey)
				end)
			end
		end
	end

	local additionalUpgrades = {
		"2PoopsUpgrade",
		"3PoopsUpgrade",
		"4PoopsUpgrade",
		"5PoopsUpgrade",
		"6PoopsUpgrade",
		"7PoopsUpgrade",
		"8PoopsUpgrade",
		"9PoopsUpgrade",
		"10PoopsUpgrade",
	}

	for _, upgradeKey in pairs(additionalUpgrades) do
		local button = upgradesScrollingFrame.Background:FindFirstChild(upgradeKey .. "Button")
		if button then
			setupButtonEffects(button)
			button.MouseButton1Click:Connect(function()
				updateInfoPanel("Upgrades", upgradeKey)
			end)
		end
	end

	-- Setup Gamepass buttons
	for itemKey, config in pairs(ShopConfig.Gamepasses) do
		local button = gamepassesScrollingFrame.GamepassesBackground:FindFirstChild(itemKey .. "Button")
		if button then
			setupButtonEffects(button)
			button.MouseButton1Click:Connect(function()
				updateInfoPanel("Gamepasses", itemKey)
			end)
		end
	end

	setupBoostButtons()
end

-- Username validation
local function validateUsername(username)
	if not username or username == "" then
		return false, "Please enter a username"
	end

	if #username < 3 or #username > 20 then
		return false, "Username must be 3-20 characters"  -  Edit
  12:31:15.422  	end

	local success, result = pcall(function()
		return ValidateUsernameRemote:InvokeServer(username)
	end)

	if success then
		return result.valid, result.message
	else
		return false, "Failed to validate username"
	end
end

-- Handle gift purchase
local function handleGiftPurchase()
	local username = typePlayerUsernameTextbox.Text
	local isValid, message = validateUsername(username)

	if not isValid then
		typePlayerUsernameTextbox.Text = ""
		typePlayerUsernameTextbox.PlaceholderText = message
		playSound("PurchaseFail")
		return
	end

	GiftPurchaseRequest:FireServer(username, selectedCategory, selectedItem)
	closeGiftFrame()
end

local function handlePurchase()
	if not selectedItem or not selectedCategory then return end

	if selectedCategory == "Poops" then
		local isOwned = playerData.OwnedPoops and table.find(playerData.OwnedPoops, selectedItem)
		local isEquipped = playerData.EquippedPoop == selectedItem

		if isEquipped then
			playSound("AlreadyOwned")
			return
		elseif isOwned then
			PurchaseRequest:FireServer("Equip", selectedCategory, selectedItem)
		else
			PurchaseRequest:FireServer("Buy", selectedCategory, selectedItem)
		end
	else
		local isOwned = playerData.OwnedUpgrades and table.find(playerData.OwnedUpgrades, selectedItem)
		if isOwned then
			playSound("AlreadyOwned")
			return
		else
			PurchaseRequest:FireServer("Buy", selectedCategory, selectedItem)
		end
	end
end

-- UPDATED: Handle gamepass purchases with boost lock checking
local function handleGamepassPurchase()
	if selectedCategory == "Gamepasses" then
		local ownsGamepass = playerData.OwnedGamepasses and table.find(playerData.OwnedGamepasses, selectedItem)
		if ownsGamepass then
			playSound("AlreadyOwned")
			return
		end
	elseif selectedCategory == "Boosts" then
		-- Check if boost is locked
		if isBoostLocked(selectedItem) then
			playSound("PurchaseFail")
			return
		end
	end

	PurchaseRequest:FireServer("Buy", selectedCategory, selectedItem)
end

-- Event Connections
RemoteEvent_OpenShop.OnClientEvent:Connect(function()
	wait(0.1)
	openShopAnimation()
	updatePlayerData()
end)

RemoteEvent_CloseShop.OnClientEvent:Connect(function()
	closeShopAnimation()
end)

EquipPoopClientEvent.OnClientEvent:Connect(function(poopName)
	if _G.changePoopType then
		_G.changePoopType(poopName)
	end

	playerData.EquippedPoop = poopName

	if selectedCategory == "Poops" then
		updateInfoPanel(selectedCategory, selectedItem)
	end
end)

PurchaseResultEvent.OnClientEvent:Connect(function(success, message, category, itemKey)
	if success then
		playSound("PurchaseSuccess")
		updatePlayerData()

		if selectedCategory and selectedItem then
			updateInfoPanel(selectedCategory, selectedItem)
		end
	else
		playSound("PurchaseFail")
	end
end)

-- Tab button connections
poopsButton.MouseButton1Click:Connect(function()
	switchTab("Poops")
end)

upgradesButton.MouseButton1Click:Connect(function()
	switchTab("Upgrades")
end)

gamepassesButton.MouseButton1Click:Connect(function()
	switchTab("Gamepasses")
end)

-- Button connections
buyButton.MouseButton1Click:Connect(handlePurchase)
buyGamepassButton.MouseButton1Click:Connect(handleGamepassPurchase)
giftAPlayerButton.MouseButton1Click:Connect(function()
	if selectedItem and selectedCategory then
		local config = nil
		if selectedCategory == "Gamepasses" then
			config = ShopConfig.Gamepasses[selectedItem]
		elseif selectedCategory == "Boosts" then
			config = ShopConfig.Boosts[selectedItem]
		end

		if config then
			gamepassTitleTextLabel.Text = config.Name or "Unknown Item"
			gamepassDescription.Text = config.GiftDescription or config.Description or ""
		end
	end

	openGiftFrame()
end)

giftAPlayerButtonInFrame.MouseButton1Click:Connect(handleGiftPurchase)
exitGiftFrameButton.MouseButton1Click:Connect(function()
	closeGiftFrame()
end)
exitButton.MouseButton1Click:Connect(function()
	closeShopAnimation()
end)

-- Click outside gift frame to close
local UserInputService = game:GetService("UserInputService")

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if input.UserInputType == Enum.UserInputType.MouseButton1 and not gameProcessed then
		if isGiftFrameOpen then
			local mouse = player:GetMouse()
			local mouseX = mouse.X
			local mouseY = mouse.Y

			local framePos = giftFrame.AbsolutePosition
			local frameSize = giftFrame.AbsoluteSize

			local outsideX = mouseX < framePos.X or mouseX > framePos.X + frameSize.X
			local outsideY = mouseY < framePos.Y or mouseY > framePos.Y + frameSize.Y

			if outsideX or outsideY then
				closeGiftFrame()
			end
		end
	end
end)

-- Setup button effects
setupButtonEffects(poopsButton)
setupButtonEffects(upgradesButton)
setupButtonEffects(gamepassesButton)
setupButtonEffects(buyButton)
setupButtonEffects(exitButton)
setupButtonEffects(buyGamepassButton)
setupButtonEffects(giftAPlayerButton)
setupButtonEffects(giftAPlayerButtonInFrame)
setupButtonEffects(exitGiftFrameButton)

-- Initialize
setupItemButtons()
switchTab("Poops")

spawn(function()
	wait(1)
	updatePlayerData()
	updateInfoPanel("Poops", ShopConfig.DefaultPoop)
end)

debugPrint("ShopScript setup complete!")

>>> game.StarterGui.ZoneMultiplier.ZoneClient (LocalScript) — 360 lines
-- ZoneClient (LocalScript in StarterGui.ZoneMultiplier.ZoneClient) - UPDATED WITH VIP ZONE SUPPORT  -  Edit
  12:31:15.422  local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local SoundService = game:GetService("SoundService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Get ShopConfig
local ShopConfig = require(ReplicatedStorage:WaitForChild("ShopConfig"))

-- Debug system
local function debugPrint(message)
	if ShopConfig.Debug.Enabled and ShopConfig.Debug.ShowClientDebug then
		print("[ZONE CLIENT]: " .. message)
	end
end

-- Wait for RemoteEvents
local ZoneEnteredEvent = ReplicatedStorage:WaitForChild("ZoneEnteredEvent")
local ZoneExitedEvent = ReplicatedStorage:WaitForChild("ZoneExitedEvent")
local ZoneUnlockedEvent = ReplicatedStorage:WaitForChild("ZoneUnlockedEvent")
local VIPZoneAccessEvent = ReplicatedStorage:WaitForChild("VIPZoneAccessEvent")

-- Wait for GUI
local zoneMultiplierGui = script.Parent
if not zoneMultiplierGui then
	warn("ZoneMultiplier GUI not found!")
	return
end

local zoneMultiplierBackground = zoneMultiplierGui:WaitForChild("ZoneMultiplierBackground", 10)
if not zoneMultiplierBackground then
	warn("ZoneMultiplierBackground not found!")
	return
end

local zoneMultiplierTextLabel = zoneMultiplierBackground:WaitForChild("ZoneMultiplierTextLabel")
if not zoneMultiplierTextLabel then
	warn("ZoneMultiplierTextLabel not found!")
	return
end

-- VIP Zone notification (create if doesn't exist)
local vipZoneNotification = zoneMultiplierGui:FindFirstChild("VIPZoneNotification")
if not vipZoneNotification then
	-- Create VIP zone notification frame
	vipZoneNotification = Instance.new("Frame")
	vipZoneNotification.Name = "VIPZoneNotification"
	vipZoneNotification.Size = UDim2.new(0, 350, 0, 80)
	vipZoneNotification.Position = UDim2.new(0.5, -175, 0, 20)
	vipZoneNotification.BackgroundColor3 = Color3.fromRGB(255, 215, 0) -- Gold
	vipZoneNotification.BorderSizePixel = 0
	vipZoneNotification.Visible = false
	vipZoneNotification.Parent = zoneMultiplierGui

	-- Add corner rounding
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = vipZoneNotification

	-- Add gradient
	local gradient = Instance.new("UIGradient")
	gradient.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 215, 0))
	}
	gradient.Rotation = 90
	gradient.Parent = vipZoneNotification

	-- Add stroke
	local stroke = Instance.new("UIStroke")
	stroke.Thickness = 3
	stroke.Color = Color3.new(1, 1, 1)
	stroke.Parent = vipZoneNotification

	-- VIP notification text
	local vipNotificationLabel = Instance.new("TextLabel")
	vipNotificationLabel.Name = "VIPNotificationLabel"
	vipNotificationLabel.Size = UDim2.new(1, 0, 1, 0)
	vipNotificationLabel.Position = UDim2.new(0, 0, 0, 0)
	vipNotificationLabel.BackgroundTransparency = 1
	vipNotificationLabel.Text = "🌟 Welcome to the VIP Zone! 👑"
	vipNotificationLabel.TextColor3 = Color3.new(1, 1, 1)
	vipNotificationLabel.TextSize = 20
	vipNotificationLabel.Font = Enum.Font.GothamBold
	vipNotificationLabel.TextStrokeTransparency = 0
	vipNotificationLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
	vipNotificationLabel.Parent = vipZoneNotification

	debugPrint("Created VIP zone notification frame")
end

local vipNotificationLabel = vipZoneNotification:WaitForChild("VIPNotificationLabel")

-- MEMORY MANAGEMENT
local connections = {}

local function cleanupConnections()
	for _, connection in pairs(connections) do
		if connection then
			connection:Disconnect()
		end
	end
	connections = {}
end

-- Create sounds
local enterSound = Instance.new("Sound")
enterSound.SoundId = ShopConfig.Sounds.ZoneEnter
enterSound.Volume = ShopConfig.Sounds.Volumes.Zone
enterSound.Parent = workspace

local exitSound = Instance.new("Sound")
exitSound.SoundId = ShopConfig.Sounds.ZoneExit
exitSound.Volume = ShopConfig.Sounds.Volumes.Zone
exitSound.Parent = workspace

local restrictedSound = Instance.new("Sound")
restrictedSound.SoundId = ShopConfig.Sounds.ZoneRestricted
restrictedSound.Volume = ShopConfig.Sounds.Volumes.Zone
restrictedSound.Parent = workspace

local vipEnterSound = Instance.new("Sound")
vipEnterSound.SoundId = ShopConfig.Sounds.NotificationShow
vipEnterSound.Volume = ShopConfig.Sounds.Volumes.Notification
vipEnterSound.Parent = workspace

-- Store original positions
local originalPosition = UDim2.new(1, -130, 0, 10)
local offScreenPosition = UDim2.new(1, 50, 0, 10)
local vipOriginalPosition = UDim2.new(0.5, -175, 0, 20)
local vipOffScreenPosition = UDim2.new(0.5, -175, -100, 20)

-- Initialize GUI state
zoneMultiplierBackground.Visible = false
zoneMultiplierBackground.Position = offScreenPosition
zoneMultiplierTextLabel.Text = "1x"
vipZoneNotification.Visible = false
vipZoneNotification.Position = vipOffScreenPosition

-- Track current zone state
local currentZoneData = {
	isInZone = false,
	isVIPZone = false,
	zoneName = nil,
	multiplier = 1
}

debugPrint("ZoneClient initialized with VIP zone support")

-- Function to show zone multiplier with VIP styling
local function showZoneMultiplier(multiplier, isVIP)
	debugPrint("SHOWING MULTIPLIER: " .. multiplier .. "x" .. (isVIP and " (VIP)" or ""))

	-- Set multiplier text and color
	zoneMultiplierTextLabel.Text = multiplier .. "x"

	if isVIP then
		-- VIP zone styling - gold color
		zoneMultiplierTextLabel.TextColor3 = ShopConfig.VIPZone.MultiplierColor or Color3.fromRGB(255, 215, 0)
		zoneMultiplierBackground.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
	else
		-- Regular zone styling - white/green
		zoneMultiplierTextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		zoneMultiplierBackground.BackgroundColor3 = Color3.fromRGB(46, 125, 50)
	end

	zoneMultiplierBackground.Visible = true
	zoneMultiplierBackground.Position = offScreenPosition

	-- Smooth slide-in animation
	local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
	local tween = TweenService:Create(zoneMultiplierBackground, tweenInfo, {
		Position = originalPosition
	})
	tween:Play()

	debugPrint("Zone multiplier displayed: " .. multiplier .. "x" .. (isVIP and " (VIP)" or ""))
end

-- Function to hide zone multiplier
local function hideZoneMultiplier()
	debugPrint("HIDING MULTIPLIER")
	local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In)
	local tween = TweenService:Create(zoneMultiplierBackground, tweenInfo, {
		Position = offScreenPosition
	})

	tween:Play()
	tween.Completed:Connect(function()
		zoneMultiplierBackground.Visible = false
		zoneMultiplierBackground.Position = offScreenPosition
	end)

	debugPrint("Zone multiplier hidden")
end

-- Function to show VIP zone notification
local function showVIPZoneNotification(zoneName)  -  Edit
  12:31:15.423  	debugPrint("SHOWING VIP ZONE NOTIFICATION: " .. zoneName)

	vipNotificationLabel.Text = "🌟 Welcome to the " .. zoneName .. "! 👑"
	vipZoneNotification.Visible = true
	vipZoneNotification.Position = vipOffScreenPosition

	-- Play VIP entrance sound
	vipEnterSound:Play()

	-- Slide down animation
	local tweenInfo = TweenInfo.new(0.7, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
	local tween = TweenService:Create(vipZoneNotification, tweenInfo, {
		Position = vipOriginalPosition
	})
	tween:Play()

	-- Auto-hide after 4 seconds
	spawn(function()
		wait(4)
		hideVIPZoneNotification()
	end)

	debugPrint("VIP zone notification displayed")
end

-- Function to hide VIP zone notification
function hideVIPZoneNotification()
	debugPrint("HIDING VIP ZONE NOTIFICATION")

	local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.In)
	local tween = TweenService:Create(vipZoneNotification, tweenInfo, {
		Position = vipOffScreenPosition
	})

	tween:Play()
	tween.Completed:Connect(function()
		vipZoneNotification.Visible = false
		vipZoneNotification.Position = vipOffScreenPosition
	end)

	debugPrint("VIP zone notification hidden")
end

-- Event handlers
table.insert(connections, ZoneEnteredEvent.OnClientEvent:Connect(function(zoneKey, multiplierOrReason, success)
	debugPrint("ZONE ENTERED EVENT: " .. tostring(zoneKey) .. ", " .. tostring(multiplierOrReason) .. ", " .. tostring(success))

	if success then
		debugPrint("ZONE ENTERED SUCCESS: " .. zoneKey .. " with multiplier " .. multiplierOrReason)

		-- Check if this is a VIP zone
		local isVIP = false
		if ShopConfig.Zones and ShopConfig.Zones[zoneKey] then
			isVIP = ShopConfig.Zones[zoneKey].IsVIP or false
		end

		-- Update current zone state
		currentZoneData.isInZone = true
		currentZoneData.isVIPZone = isVIP
		currentZoneData.zoneName = zoneKey
		currentZoneData.multiplier = multiplierOrReason

		enterSound:Play()
		showZoneMultiplier(multiplierOrReason, isVIP)

		-- Show VIP notification if applicable
		if isVIP and ShopConfig.Zones and ShopConfig.Zones[zoneKey] then
			local zoneName = ShopConfig.Zones[zoneKey].Name or "VIP Zone"
			showVIPZoneNotification(zoneName)
		end
	else
		debugPrint("ZONE ENTERED FAILED: " .. tostring(multiplierOrReason))
		restrictedSound:Play()

		if multiplierOrReason then
			print(multiplierOrReason) -- Show error message
		end
	end
end))

table.insert(connections, ZoneExitedEvent.OnClientEvent:Connect(function()
	debugPrint("ZONE EXITED EVENT")

	-- Reset zone state
	currentZoneData.isInZone = false
	currentZoneData.isVIPZone = false
	currentZoneData.zoneName = nil
	currentZoneData.multiplier = 1

	exitSound:Play()
	hideZoneMultiplier()

	-- Hide VIP notification if showing
	if vipZoneNotification.Visible then
		hideVIPZoneNotification()
	end
end))

table.insert(connections, ZoneUnlockedEvent.OnClientEvent:Connect(function(zoneKey, zoneName, unlockMessage)
	debugPrint("ZONE UNLOCKED: " .. zoneName)

	print("🎉 " .. unlockMessage)

	local notificationSound = Instance.new("Sound")
	notificationSound.SoundId = ShopConfig.Sounds.NotificationShow
	notificationSound.Volume = ShopConfig.Sounds.Volumes.Notification
	notificationSound.Parent = workspace
	notificationSound:Play()

	notificationSound.Ended:Connect(function()
		notificationSound:Destroy()
	end)
end))

-- NEW: VIP Zone Access Event Handler
table.insert(connections, VIPZoneAccessEvent.OnClientEvent:Connect(function(eventType, data)
	debugPrint("VIP ZONE ACCESS EVENT: " .. eventType)

	if eventType == "entered" then
		debugPrint("Player entered VIP zone: " .. data.zoneName)
		-- VIP zone entry effects already handled in ZoneEnteredEvent

	elseif eventType == "exited" then
		debugPrint("Player exited VIP zone: " .. data.zoneName)
		-- Additional VIP zone exit effects can go here

	elseif eventType == "access_denied" then
		debugPrint("VIP zone access denied")
		restrictedSound:Play()

		-- Show access denied message
		print("❌ " .. (data.message or "VIP access required!"))

	elseif eventType == "access_lost" then
		debugPrint("VIP zone access lost")

		-- Show message that VIP access was lost
		print("⚠️ VIP access expired! You've been moved to the main area.")
	end
end))

-- Global functions for other scripts to access zone state
_G.ZoneClientData = {
	IsInZone = function() return currentZoneData.isInZone end,
	IsInVIPZone = function() return currentZoneData.isVIPZone end,
	GetCurrentZone = function() return currentZoneData.zoneName end,
	GetCurrentMultiplier = function() return currentZoneData.multiplier end,
	ShowVIPNotification = showVIPZoneNotification,
	HideVIPNotification = hideVIPZoneNotification
}

-- Cleanup on player leaving
table.insert(connections, Players.PlayerRemoving:Connect(function(removingPlayer)
	if removingPlayer == player then
		cleanupConnections()
	end
end))

debugPrint("ZoneClient setup complete with VIP zone support!")

>>> game.StarterGui.ZonesTeleportGui.ZonesTeleportClient (LocalScript) — 524 lines
-- ZonesTeleportClient (LocalScript in StarterGui.ZonesTeleportGui) - WITH FULL SCREEN FADE EFFECTS
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Get ShopConfig
local ShopConfig = require(ReplicatedStorage:WaitForChild("ShopConfig"))

-- Debug system
local function debugPrint(message)
	if ShopConfig.Debug.Enabled and ShopConfig.Debug.ShowClientDebug then
		print("[ZONES GUI]: " .. message)
	end
end

-- Wait for GUI elements
local zonesTeleportGui = script.Parent
local zonesTeleportBackground = zonesTeleportGui:WaitForChild("ZonesTeleportBackground")
local titleLabel = zonesTeleportBackground:WaitForChild("TitleLabel")
local exitButton = zonesTeleportBackground:WaitForChild("ExitButton")
local background = zonesTeleportBackground:WaitForChild("Background")

-- Get zone frames
local poopSkyIslandFrame = background:WaitForChild("PoopSkyIslandFrame")
local toiletSkyIslandFrame = background:WaitForChild("ToiletSkyIslandFrame")  
local greatPoopMountainFrame = background:WaitForChild("GreatPoopMountainFrame")

-- Get buttons
local poopButton = poopSkyIslandFrame:WaitForChild("Locked/TeleportButton")
local toiletButton = toiletSkyIslandFrame:WaitForChild("Locked/TeleportButton")
local mountainButton = greatPoopMountainFrame:WaitForChild("Locked/TeleportButton")

-- Wait for RemoteEvents
local GetPlayerDataRemote = ReplicatedStorage:WaitForChild("GetPlayerDataRemote")
  -  Edit
  12:31:15.424  -- Wait for screen buttons GUI
local screenButtonsGui = playerGui:WaitForChild("ScreenButtonsGui")
local screenBackground = screenButtonsGui:WaitForChild("Background")
local zonesButton = screenBackground:WaitForChild("ZonesButton")

-- State
local isZonesGuiOpen = false
local playerData = {}

-- Store original properties
local originalZonesSize = zonesTeleportBackground.Size
local originalZonesPosition = zonesTeleportBackground.Position

-- Button original states storage
local buttonOriginalStates = {}

-- Initialize GUI state
zonesTeleportGui.Enabled = false

-- CREATE FULL SCREEN FADE FRAME
local function createFadeFrame()
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "ZoneTeleportFadeGui"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	screenGui.IgnoreGuiInset = true -- Covers entire screen including topbar
	screenGui.Parent = playerGui

	local frame = Instance.new("Frame")
	frame.Name = "FadeFrame"
	frame.Size = UDim2.new(1, 0, 1, 0) -- Full screen
	frame.Position = UDim2.new(0, 0, 0, 0) -- Top-left corner
	frame.BackgroundColor3 = Color3.new(0, 0, 0) -- Black
	frame.BackgroundTransparency = 1 -- Start invisible
	frame.BorderSizePixel = 0
	frame.ZIndex = 10000 -- Very high z-index to be on top of everything
	frame.Parent = screenGui

	return frame
end

local fadeFrame = createFadeFrame()

-- Fade effects
local function fadeOut(duration, callback)
	local tween = TweenService:Create(fadeFrame, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0})
	tween:Play()
	if callback then
		tween.Completed:Connect(callback)
	end
end

local function fadeIn(duration, callback)
	local tween = TweenService:Create(fadeFrame, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 1})
	tween:Play()
	if callback then
		tween.Completed:Connect(callback)
	end
end

debugPrint("ZonesTeleportClient initialized with fade effects")

-- Button effects system
local function storeButtonOriginalState(button)
	if not buttonOriginalStates[button] then
		buttonOriginalStates[button] = {
			Size = button.Size,
			BackgroundColor3 = button.BackgroundColor3,
			Rotation = button.Rotation,
			isHovering = false
		}
	end
end

local function setupButtonEffects(button)
	storeButtonOriginalState(button)
	local originalState = buttonOriginalStates[button]

	-- Hover effects
	button.MouseEnter:Connect(function()
		if originalState.isHovering then return end
		originalState.isHovering = true

		-- Store the CURRENT color as original (in case it changed from locked/unlocked)
		originalState.BackgroundColor3 = button.BackgroundColor3

		local hoverConfig = ShopConfig.Tweens.ButtonHover
		local tweenInfo = TweenInfo.new(
			hoverConfig.Duration,
			hoverConfig.EasingStyle,
			hoverConfig.EasingDirection
		)

		-- Don't lerp towards white for colored buttons, just lighten them slightly
		local currentColor = button.BackgroundColor3
		local targetColor = Color3.new(
			math.min(1, currentColor.R + 0.1),
			math.min(1, currentColor.G + 0.1), 
			math.min(1, currentColor.B + 0.1)
		)

		local tween = TweenService:Create(button, tweenInfo, {
			Size = UDim2.new(
				originalState.Size.X.Scale * hoverConfig.ScaleMultiplier, 
				0, 
				originalState.Size.Y.Scale * hoverConfig.ScaleMultiplier, 
				0
			),
			BackgroundColor3 = targetColor
		})
		tween:Play()
	end)

	button.MouseLeave:Connect(function()
		if not originalState.isHovering then return end
		originalState.isHovering = false

		-- Update the original color again in case button state changed while hovering
		local currentButtonColor = nil
		if button:IsA("TextButton") then
			if button.Text == "TELEPORT" then
				currentButtonColor = Color3.fromRGB(25, 118, 210) -- Blue
			elseif button.Text == "LOCKED" then
				currentButtonColor = Color3.fromRGB(158, 158, 158) -- Gray
			else
				currentButtonColor = originalState.BackgroundColor3 -- Fallback
			end
		else
			-- For ImageButtons or other button types, just use the stored original color
			currentButtonColor = originalState.BackgroundColor3
		end

		local hoverConfig = ShopConfig.Tweens.ButtonHover
		local tweenInfo = TweenInfo.new(
			hoverConfig.Duration,
			hoverConfig.EasingStyle,
			hoverConfig.EasingDirection
		)

		local tween = TweenService:Create(button, tweenInfo, {
			Size = originalState.Size,
			BackgroundColor3 = currentButtonColor,
			Rotation = originalState.Rotation
		})
		tween:Play()

		-- Update stored original color
		originalState.BackgroundColor3 = currentButtonColor
	end)

	-- Click effects
	button.MouseButton1Down:Connect(function()
		local clickConfig = ShopConfig.Tweens.ButtonClick
		local tweenInfo = TweenInfo.new(
			clickConfig.Duration,
			clickConfig.EasingStyle,
			clickConfig.EasingDirection
		)

		local scaleMultiplier = math.max(0.98, clickConfig.ScaleMultiplier)
		local tween = TweenService:Create(button, tweenInfo, {
			Size = UDim2.new(
				originalState.Size.X.Scale * scaleMultiplier, 
				0, 
				originalState.Size.Y.Scale * scaleMultiplier, 
				0
			),
			Rotation = originalState.Rotation + math.random(-clickConfig.RotationRange, clickConfig.RotationRange)
		})
		tween:Play()
	end)

	button.MouseButton1Up:Connect(function()
		local hoverConfig = ShopConfig.Tweens.ButtonHover
		local tweenInfo = TweenInfo.new(
			hoverConfig.Duration,
			Enum.EasingStyle.Back,
			Enum.EasingDirection.Out
		)

		-- Determine target size based on hover state
		local targetSize = originalState.isHovering and 
			UDim2.new(
				originalState.Size.X.Scale * hoverConfig.ScaleMultiplier, 
				0, 
				originalState.Size.Y.Scale * hoverConfig.ScaleMultiplier, 
				0
			) or originalState.Size

		local tween = TweenService:Create(button, tweenInfo, {
			Size = targetSize,
			Rotation = originalState.Rotation
		})
		tween:Play()
	end)
end

-- Function to get player data
local function updatePlayerData()
	local success, data = pcall(function()  -  Edit
  12:31:15.424  		return GetPlayerDataRemote:InvokeServer()
	end)

	if success and data then
		playerData = data
		return true
	else
		debugPrint("Failed to get player data")
		return false
	end
end

-- Function to get player's poops pooped
local function getPlayerPoopsPooped()
	-- Try leaderstats first
	local leaderstats = player:FindFirstChild("leaderstats")
	if leaderstats then
		local poops = leaderstats:FindFirstChild("Poops")
		if poops then
			return poops.Value
		end
	end
	return 0
end

-- Function to update button states
local function updateZoneButtons()
	local poopsPooped = getPlayerPoopsPooped()

	-- Zone 1 - Poop Sky Island (350 poops required)
	if poopsPooped >= 350 then
		poopButton.Text = "TELEPORT"
		poopButton.BackgroundColor3 = Color3.fromRGB(25, 118, 210) -- Blue
		-- Update stored original state
		if buttonOriginalStates[poopButton] then
			buttonOriginalStates[poopButton].BackgroundColor3 = Color3.fromRGB(25, 118, 210)
		end
	else
		poopButton.Text = "LOCKED"  
		poopButton.BackgroundColor3 = Color3.fromRGB(158, 158, 158) -- Gray
		-- Update stored original state
		if buttonOriginalStates[poopButton] then
			buttonOriginalStates[poopButton].BackgroundColor3 = Color3.fromRGB(158, 158, 158)
		end
	end

	-- Zone 2 - Toilet Sky Island (750 poops required)
	if poopsPooped >= 750 then
		toiletButton.Text = "TELEPORT"
		toiletButton.BackgroundColor3 = Color3.fromRGB(25, 118, 210) -- Blue
		-- Update stored original state
		if buttonOriginalStates[toiletButton] then
			buttonOriginalStates[toiletButton].BackgroundColor3 = Color3.fromRGB(25, 118, 210)
		end
	else
		toiletButton.Text = "LOCKED"
		toiletButton.BackgroundColor3 = Color3.fromRGB(158, 158, 158) -- Gray
		-- Update stored original state
		if buttonOriginalStates[toiletButton] then
			buttonOriginalStates[toiletButton].BackgroundColor3 = Color3.fromRGB(158, 158, 158)
		end
	end

	-- Zone 3 - Great Poop Mountain (1500 poops required)
	if poopsPooped >= 1500 then
		mountainButton.Text = "TELEPORT"
		mountainButton.BackgroundColor3 = Color3.fromRGB(25, 118, 210) -- Blue
		-- Update stored original state
		if buttonOriginalStates[mountainButton] then
			buttonOriginalStates[mountainButton].BackgroundColor3 = Color3.fromRGB(25, 118, 210)
		end
	else
		mountainButton.Text = "LOCKED"
		mountainButton.BackgroundColor3 = Color3.fromRGB(158, 158, 158) -- Gray
		-- Update stored original state
		if buttonOriginalStates[mountainButton] then
			buttonOriginalStates[mountainButton].BackgroundColor3 = Color3.fromRGB(158, 158, 158)
		end
	end

	debugPrint("Updated zone buttons - Player has " .. poopsPooped .. " poops")
end

-- ENHANCED: Function to teleport to zone with fade effects
local function teleportToZone(zoneNumber)
	local poopsPooped = getPlayerPoopsPooped()
	local required = 0
	local portalArriveName = nil

	if zoneNumber == 1 then
		required = 350
		portalArriveName = "Zone1PortalArrive"
	elseif zoneNumber == 2 then
		required = 750
		portalArriveName = "Zone2PortalArrive"
	elseif zoneNumber == 3 then
		required = 1500
		portalArriveName = "Zone3PortalArrive"
	end

	if poopsPooped < required then
		-- Play locked sound
		local lockedSound = Instance.new("Sound")
		lockedSound.SoundId = ShopConfig.Sounds.ZoneRestricted
		lockedSound.Volume = ShopConfig.Sounds.Volumes.Zone
		lockedSound.Parent = workspace
		lockedSound:Play()
		lockedSound.Ended:Connect(function()
			lockedSound:Destroy()
		end)

		print("You need " .. required .. " poops to access this zone! (You have " .. poopsPooped .. ")")
		return
	end

	-- Start fade out effect
	fadeOut(0.3, function()
		-- Look for the PortalArrive in the sky island
		local portalsFolder = workspace:FindFirstChild("Portals")
		if not portalsFolder then
			warn("Portals folder not found in workspace!")
			fadeIn(0.3) -- Fade back in on error
			return
		end

		local portalArrive = portalsFolder:FindFirstChild(portalArriveName)
		if not portalArrive then
			warn("PortalArrive not found: " .. portalArriveName)
			fadeIn(0.3) -- Fade back in on error
			return
		end

		-- Find the teleport part in the PortalArrive
		local tpPart = nil
		for _, part in pairs(portalArrive:GetChildren()) do
			if part:IsA("BasePart") and (
				string.find(part.Name, "TPPart") or 
					part.Name == "Part"
				) then
				tpPart = part
				break
			end
		end

		-- If no specific TP part found, use PrimaryPart or any part
		if not tpPart then
			tpPart = portalArrive.PrimaryPart
			if not tpPart then
				for _, part in pairs(portalArrive:GetChildren()) do
					if part:IsA("BasePart") then
						tpPart = part
						break
					end
				end
			end
		end

		if not tpPart then
			warn("No teleport part found in PortalArrive: " .. portalArriveName)
			fadeIn(0.3) -- Fade back in on error
			return
		end

		-- Teleport the player to 10 studs in front of the PortalArrive
		if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			-- Play teleport sound
			local teleportSound = Instance.new("Sound")
			teleportSound.SoundId = ShopConfig.Sounds.ZoneEnter
			teleportSound.Volume = ShopConfig.Sounds.Volumes.Zone
			teleportSound.Parent = workspace
			teleportSound:Play()
			teleportSound.Ended:Connect(function()
				teleportSound:Destroy()
			end)

			-- Calculate position 10 studs in front of the portal
			local portalCFrame = tpPart.CFrame
			local forwardDirection = portalCFrame.LookVector
			local positionInFront = portalCFrame.Position - (forwardDirection * 10) -- 10 studs in front

			-- Add small vertical offset to ensure we're not inside anything
			local finalPosition = Vector3.new(positionInFront.X, positionInFront.Y + 3, positionInFront.Z)

			player.Character.HumanoidRootPart.CFrame = CFrame.new(finalPosition, portalCFrame.Position)
			closeZonesGui()
			debugPrint("Teleported to zone " .. zoneNumber .. " - 10 studs in front of " .. portalArriveName)

			-- Small delay then fade back in
			wait(0.2)
			fadeIn(0.5)
		else
			warn("Character or HumanoidRootPart not found")
			fadeIn(0.3) -- Fade back in on error
		end
	end)
end

-- Animation functions
local function openZonesGui()
	if isZonesGuiOpen then return end  -  Edit
  12:31:15.424  	isZonesGuiOpen = true

	-- Update button states
	updateZoneButtons()

	-- Setup initial state
	zonesTeleportBackground.Size = UDim2.new(0, 0, 0, 0)
	zonesTeleportBackground.Position = UDim2.new(0.5, 0, 0.5, 0)
	zonesTeleportGui.Enabled = true

	-- Animation
	local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
	local tween = TweenService:Create(zonesTeleportBackground, tweenInfo, {
		Size = originalZonesSize,
		Position = originalZonesPosition
	})

	tween:Play()
	debugPrint("Opened zones GUI")
end

function closeZonesGui()
	if not isZonesGuiOpen then return end
	isZonesGuiOpen = false

	local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In)
	local tween = TweenService:Create(zonesTeleportBackground, tweenInfo, {
		Size = UDim2.new(0, 0, 0, 0),
		Position = UDim2.new(0.5, 0, 0.5, 0)
	})

	tween:Play()
	tween.Completed:Connect(function()
		zonesTeleportGui.Enabled = false
		zonesTeleportBackground.Size = originalZonesSize
		zonesTeleportBackground.Position = originalZonesPosition
	end)

	debugPrint("Closed zones GUI")
end

-- Setup button effects for all buttons
setupButtonEffects(zonesButton)
setupButtonEffects(exitButton)
setupButtonEffects(poopButton)
setupButtonEffects(toiletButton)
setupButtonEffects(mountainButton)

-- Button connections
zonesButton.MouseButton1Click:Connect(function()
	if isZonesGuiOpen then
		closeZonesGui()
	else
		openZonesGui()
	end
end)

exitButton.MouseButton1Click:Connect(function()
	closeZonesGui()
end)

-- Zone teleport buttons with fade effects
poopButton.MouseButton1Click:Connect(function()
	teleportToZone(1)
end)

toiletButton.MouseButton1Click:Connect(function() 
	teleportToZone(2)
end)

mountainButton.MouseButton1Click:Connect(function()
	teleportToZone(3)
end)

-- Update buttons every few seconds
spawn(function()
	while true do
		wait(2)
		if isZonesGuiOpen then
			updateZoneButtons()
		end
	end
end)

debugPrint("ZonesTeleportClient setup complete with full-screen fade effects!")

>>> game.StarterPlayer.StarterPlayerScripts.LuckBonusClient (LocalScript) — 223 lines
-- LuckBonusClient (LocalScript in StarterPlayerScripts) - HANDLES LUCK BONUS VISUAL EFFECTS
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local SoundService = game:GetService("SoundService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Get ShopConfig
local ShopConfig = require(ReplicatedStorage:WaitForChild("ShopConfig"))

-- Debug system
local function debugPrint(message)
	if ShopConfig.Debug.Enabled and ShopConfig.Debug.ShowClientDebug then
		print("[LUCK CLIENT]: " .. message)
	end
end

-- Wait for RemoteEvent
local luckBonusTriggeredEvent = ReplicatedStorage:WaitForChild("LuckBonusTriggeredEvent")

-- Create sounds
local luckSound = Instance.new("Sound")
luckSound.SoundId = ShopConfig.Sounds.LuckTrigger
luckSound.Volume = ShopConfig.Sounds.Volumes.Luck
luckSound.Parent = workspace

local megaLuckSound = Instance.new("Sound")
megaLuckSound.SoundId = ShopConfig.Sounds.MegaLuckTrigger
megaLuckSound.Volume = ShopConfig.Sounds.Volumes.Luck
megaLuckSound.Parent = workspace

debugPrint("LuckBonusClient initialized")

-- Function to create floating luck popup
local function createLuckPopup(multiplier, bonusAmount)
	debugPrint("Creating luck popup: " .. multiplier .. "x multiplier, +" .. bonusAmount .. " bonus")

	-- Create ScreenGui for the popup
	local popupGui = Instance.new("ScreenGui")
	popupGui.Name = "LuckPopup"
	popupGui.ResetOnSpawn = false
	popupGui.Parent = playerGui

	-- Create main frame
	local popupFrame = Instance.new("Frame")
	popupFrame.Name = "PopupFrame"
	popupFrame.Size = UDim2.new(0, 300, 0, 80)
	popupFrame.Position = UDim2.new(0.5, -150, 0.3, -40)
	popupFrame.BackgroundTransparency = 1
	popupFrame.Parent = popupGui

	-- Create background with gradient
	local background = Instance.new("Frame")
	background.Name = "Background"
	background.Size = UDim2.new(1, 0, 1, 0)
	background.Position = UDim2.new(0, 0, 0, 0)
	background.BackgroundColor3 = multiplier >= 2.5 and Color3.fromRGB(255, 215, 0) or Color3.fromRGB(85, 255, 127) -- Gold for mega luck, green for regular
	background.BorderSizePixel = 0
	background.Parent = popupFrame

	-- Add corner rounding
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = background

	-- Add gradient
	local gradient = Instance.new("UIGradient")
	gradient.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
		ColorSequenceKeypoint.new(1, Color3.new(0.8, 0.8, 0.8))
	}
	gradient.Rotation = 90
	gradient.Parent = background

	-- Add stroke
	local stroke = Instance.new("UIStroke")
	stroke.Thickness = 3
	stroke.Color = multiplier >= 2.5 and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(46, 125, 50)
	stroke.Parent = background

	-- Create title label
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "TitleLabel"
	titleLabel.Size = UDim2.new(1, 0, 0.5, 0)
	titleLabel.Position = UDim2.new(0, 0, 0, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = multiplier >= 2.5 and "🍀 MEGA LUCK! 🍀" or "✨ LUCKY! ✨"
	titleLabel.TextColor3 = Color3.new(1, 1, 1)
	titleLabel.TextSize = 20
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.TextStrokeTransparency = 0
	titleLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
	titleLabel.Parent = popupFrame

	-- Create multiplier label
	local multiplierLabel = Instance.new("TextLabel")
	multiplierLabel.Name = "MultiplierLabel"
	multiplierLabel.Size = UDim2.new(1, 0, 0.5, 0)
	multiplierLabel.Position = UDim2.new(0, 0, 0.5, 0)
	multiplierLabel.BackgroundTransparency = 1
	multiplierLabel.Text = "+" .. bonusAmount .. " Extra PooBucks! (" .. multiplier .. "x)"
	multiplierLabel.TextColor3 = Color3.new(1, 1, 1)
	multiplierLabel.TextSize = 16
	multiplierLabel.Font = Enum.Font.Gotham
	multiplierLabel.TextStrokeTransparency = 0
	multiplierLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
	multiplierLabel.Parent = popupFrame

	-- Play appropriate sound
	if multiplier >= 2.5 then
		megaLuckSound:Play()  -  Edit
  12:31:15.426  	else
		luckSound:Play()
	end

	-- Initial animation - slide in from top
	popupFrame.Position = UDim2.new(0.5, -150, -0.1, -40)

	local slideInTween = TweenService:Create(popupFrame, 
		TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
		{Position = UDim2.new(0.5, -150, 0.3, -40)}
	)
	slideInTween:Play()

	-- Pulse animation
	local pulseScale = multiplier >= 2.5 and 1.1 or 1.05
	spawn(function()
		for i = 1, 3 do
			wait(0.2)
			local pulseTween = TweenService:Create(popupFrame,
				TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
				{Size = UDim2.new(0, 300 * pulseScale, 0, 80 * pulseScale)}
			)
			pulseTween:Play()

			wait(0.3)
			local shrinkTween = TweenService:Create(popupFrame,
				TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
				{Size = UDim2.new(0, 300, 0, 80)}
			)
			shrinkTween:Play()
		end
	end)

	-- Wait and then fade out
	spawn(function()
		wait(ShopConfig.LuckBonus.LuckPopupDuration or 2)

		-- Fade out animation
		local fadeOutTween = TweenService:Create(popupFrame,
			TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
			{
				Position = UDim2.new(0.5, -150, -0.1, -40),
				Size = UDim2.new(0, 250, 0, 60)
			}
		)

		local transparencyTween = TweenService:Create(background,
			TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
			{BackgroundTransparency = 1}
		)

		local textFadeTween1 = TweenService:Create(titleLabel,
			TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
			{TextTransparency = 1}
		)

		local textFadeTween2 = TweenService:Create(multiplierLabel,
			TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
			{TextTransparency = 1}
		)

		local strokeFadeTween = TweenService:Create(stroke,
			TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
			{Transparency = 1}
		)

		fadeOutTween:Play()
		transparencyTween:Play()
		textFadeTween1:Play()
		textFadeTween2:Play()
		strokeFadeTween:Play()

		fadeOutTween.Completed:Connect(function()
			popupGui:Destroy()
		end)
	end)

	debugPrint("Luck popup created and animated")
end

-- Handle luck bonus triggered events
luckBonusTriggeredEvent.OnClientEvent:Connect(function(multiplier, bonusAmount)
	debugPrint("Luck bonus triggered: " .. multiplier .. "x, +" .. bonusAmount .. " bonus")

	if ShopConfig.LuckBonus.ShowLuckPopups then
		createLuckPopup(multiplier, bonusAmount)
	end

	if ShopConfig.LuckBonus.PlayLuckSounds then
		if multiplier >= 2.5 then
			megaLuckSound:Play()
		else
			luckSound:Play()
		end
	end
end)

-- Cleanup on player leaving
Players.PlayerRemoving:Connect(function(removingPlayer)
	if removingPlayer == player then
		-- Clean up any remaining popups
		for _, gui in pairs(playerGui:GetChildren()) do
			if gui.Name == "LuckPopup" then
				gui:Destroy()
			end
		end
	end
end)

debugPrint("LuckBonusClient setup complete!")

>>> game.StarterPlayer.StarterPlayerScripts.MainGuiHandler (LocalScript) — 629 lines
-- MainGuiHandler (LocalScript in StarterPlayer.StarterPlayerScripts)
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SoundService = game:GetService("SoundService")
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Wait a bit for GUIs to load
wait(2)

-- Get ShopConfig
local ShopConfig = require(ReplicatedStorage:WaitForChild("ShopConfig"))

-- Debug system
local function debugPrint(message)
	print("[GUI HANDLER]: " .. message)
end

debugPrint("MainGuiHandler starting...")

-- Try to find ScreenButtonsGui with multiple attempts
local screenButtonsGui
local attempts = 0
repeat
	attempts = attempts + 1
	screenButtonsGui = playerGui:FindFirstChild("ScreenButtonsGui")
	if not screenButtonsGui then
		debugPrint("Attempt " .. attempts .. ": ScreenButtonsGui not found, waiting...")
		wait(1)
	end
until screenButtonsGui or attempts > 5

if not screenButtonsGui then
	warn("ScreenButtonsGui not found after " .. attempts .. " attempts!")
	return
end

debugPrint("Found ScreenButtonsGui!")

local background = screenButtonsGui:FindFirstChild("Background")
if not background then
	warn("Background not found in ScreenButtonsGui!")
	wait(2)
	background = screenButtonsGui:FindFirstChild("Background")
	if not background then
		warn("Background still not found after waiting!")
		return
	end
end

debugPrint("Found Background!")

-- Helper function to find actual clickable buttons
local function findClickableButton(parent)
	if parent:IsA("TextButton") or parent:IsA("ImageButton") then
		return parent
	end

	for _, child in pairs(parent:GetDescendants()) do
		if child:IsA("TextButton") or child:IsA("ImageButton") then
			return child
		end
	end

	return parent
end

-- Get button containers and find actual clickable elements
local shopButtonContainer = background:WaitForChild("ShopGuiOpen/Close", 10)
local settingsButtonContainer = background:WaitForChild("SettingButtonOpen/Close", 10)
local statsButtonContainer = background:WaitForChild("StatsButtonOpen/Close", 10)
local groupRewardsButtonContainer = background:WaitForChild("GroupRewardsIcon", 10)

-- Find actual clickable buttons
local shopButton = findClickableButton(shopButtonContainer)
local settingsButton = findClickableButton(settingsButtonContainer)
local statsButton = findClickableButton(statsButtonContainer)
local groupRewardsButton = findClickableButton(groupRewardsButtonContainer)

if not shopButton or not settingsButton or not statsButton or not groupRewardsButton then
	warn("One or more buttons not found!")
	return
end
  -  Edit
  12:31:15.426  -- Get all GUIs
local shopGui = playerGui:WaitForChild("ShopGui", 10)
local settingsGui = playerGui:WaitForChild("SettingsGui", 10)
local statsGui = playerGui:WaitForChild("StatsGui", 10)
local groupRewardsGui = playerGui:WaitForChild("GroupRewardsGui", 10)

-- Get RemoteEvents
local RemoteEvent_OpenShop = ReplicatedStorage:WaitForChild("RemoteEvent_OpenShop")

debugPrint("All GUIs and buttons loaded")

-- ======================
-- IMPROVED BUTTON EFFECTS SYSTEM
-- ======================
local activeHovers = {}

local function createHoverEffect(button, options)
	if not button or activeHovers[button] then return end

	options = options or {}
	local skipColorEffect = options.skipColorEffect or false

	local originalSize = button.Size
	local originalPosition = button.Position
	local originalTransparency = button.BackgroundTransparency

	local isHovering = false
	local currentTween = nil

	local function getCurrentBackgroundColor()
		return button.BackgroundColor3
	end

	local function onMouseEnter()
		if isHovering then return end
		isHovering = true

		if currentTween then
			currentTween:Cancel()
		end

		local hoverConfig = ShopConfig.Tweens and ShopConfig.Tweens.ButtonHover or {
			Duration = 0.2,
			EasingStyle = Enum.EasingStyle.Quad,
			EasingDirection = Enum.EasingDirection.Out,
			ScaleMultiplier = 1.1
		}

		local tweenInfo = TweenInfo.new(
			hoverConfig.Duration,
			hoverConfig.EasingStyle,
			hoverConfig.EasingDirection
		)

		local newSize = UDim2.new(
			originalSize.X.Scale * hoverConfig.ScaleMultiplier,
			originalSize.X.Offset * hoverConfig.ScaleMultiplier,
			originalSize.Y.Scale * hoverConfig.ScaleMultiplier,
			originalSize.Y.Offset * hoverConfig.ScaleMultiplier
		)

		local sizeChange = hoverConfig.ScaleMultiplier - 1
		local newPosition = UDim2.new(
			originalPosition.X.Scale - (originalSize.X.Scale * sizeChange / 2),
			originalPosition.X.Offset - (originalSize.X.Offset * sizeChange / 2),
			originalPosition.Y.Scale - (originalSize.Y.Scale * sizeChange / 2),
			originalPosition.Y.Offset - (originalSize.Y.Offset * sizeChange / 2)
		)

		local targetProperties = {
			Size = newSize,
			Position = newPosition
		}

		if not skipColorEffect and originalTransparency < 1 then
			local currentColor = getCurrentBackgroundColor()
			targetProperties.BackgroundColor3 = Color3.new(
				math.min(1, currentColor.R * 1.2),
				math.min(1, currentColor.G * 1.2),
				math.min(1, currentColor.B * 1.2)
			)
		end

		currentTween = TweenService:Create(button, tweenInfo, targetProperties)
		currentTween:Play()
	end

	local function onMouseLeave()
		if not isHovering then return end
		isHovering = false

		if currentTween then
			currentTween:Cancel()
		end

		local hoverConfig = ShopConfig.Tweens and ShopConfig.Tweens.ButtonHover or {
			Duration = 0.2,
			EasingStyle = Enum.EasingStyle.Quad,
			EasingDirection = Enum.EasingDirection.Out
		}

		local tweenInfo = TweenInfo.new(
			hoverConfig.Duration,
			hoverConfig.EasingStyle,
			hoverConfig.EasingDirection
		)

		local targetProperties = {
			Size = originalSize,
			Position = originalPosition
		}

		if not skipColorEffect then
			targetProperties.BackgroundColor3 = getCurrentBackgroundColor()
		end

		currentTween = TweenService:Create(button, tweenInfo, targetProperties)
		currentTween:Play()
	end

	local mouseEnterConnection = button.MouseEnter:Connect(onMouseEnter)
	local mouseLeaveConnection = button.MouseLeave:Connect(onMouseLeave)

	activeHovers[button] = {
		mouseEnter = mouseEnterConnection,
		mouseLeave = mouseLeaveConnection,
		cleanup = function()
			mouseEnterConnection:Disconnect()
			mouseLeaveConnection:Disconnect()
			if currentTween then
				currentTween:Cancel()
			end
			activeHovers[button] = nil
		end
	}
end

-- ======================
-- SHOP SYSTEM
-- ======================
shopButton.MouseButton1Click:Connect(function()
	debugPrint("Shop button clicked")
	RemoteEvent_OpenShop:FireServer()
end)

-- ======================
-- SETTINGS SYSTEM
-- ======================
local settingsBackground = settingsGui:WaitForChild("SettingsBackground")
local settingsExitButton = settingsBackground:WaitForChild("ExitButton")
local settingsFrame = settingsBackground:WaitForChild("Background")

local changeMusicBackground = settingsFrame:WaitForChild("ChangeMusicBackground")
local musicButton = findClickableButton(changeMusicBackground:WaitForChild("On/OffButton"))

local changeQualityBackground = settingsFrame:WaitForChild("ChangeQualityBackground")
local qualityButton = findClickableButton(changeQualityBackground:WaitForChild("Realistic/SoftButton"))

local disablePopupsBackground = settingsFrame:WaitForChild("DisablePopupsBackground")
local popupsButton = findClickableButton(disablePopupsBackground:WaitForChild("On/OffButton"))

settingsExitButton = findClickableButton(settingsExitButton)

-- Get dependencies
local mainTheme = SoundService:FindFirstChild("MainTheme")
if not mainTheme then
	warn("MainTheme sound not found in SoundService!")
	mainTheme = Instance.new("Sound")
	mainTheme.Name = "MainTheme"
	mainTheme.Parent = SoundService
	mainTheme.Looped = true
	mainTheme.Volume = 0.5
end

local popupScreenGui = playerGui:WaitForChild("PopupScreenGui")

-- Settings state
local isSettingsOpen = false
local isMusicOn = mainTheme.Playing
local isRealisticQuality = true
local arePopupsEnabled = popupScreenGui.Enabled

local originalSettingsSize = settingsBackground.Size
local originalSettingsPosition = settingsBackground.Position

-- Update button states
local function updateSettingsButtons()
	if musicButton then
		if isMusicOn then
			musicButton.Text = "ON"
			musicButton.BackgroundColor3 = Color3.fromRGB(46, 125, 50)
		else
			musicButton.Text = "OFF"
			musicButton.BackgroundColor3 = Color3.fromRGB(244, 67, 54)
		end
	end

	if qualityButton then
		if isRealisticQuality then
			qualityButton.Text = "REALISTIC"  -  Edit
  12:31:15.426  			qualityButton.BackgroundColor3 = Color3.fromRGB(33, 150, 243)
		else
			qualityButton.Text = "SOFT"
			qualityButton.BackgroundColor3 = Color3.fromRGB(156, 39, 176)
		end
	end

	if popupsButton then
		if arePopupsEnabled then
			popupsButton.Text = "ENABLED"
			popupsButton.BackgroundColor3 = Color3.fromRGB(46, 125, 50)
		else
			popupsButton.Text = "DISABLED"
			popupsButton.BackgroundColor3 = Color3.fromRGB(244, 67, 54)
		end
	end
end

local function openSettings()
	if isSettingsOpen then return end
	isSettingsOpen = true

	settingsGui.Enabled = true
	settingsBackground.Size = UDim2.new(0, 0, 0, 0)
	settingsBackground.Position = UDim2.new(0.5, 0, 0.5, 0)
	settingsBackground.Visible = true

	local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
	local tween = TweenService:Create(settingsBackground, tweenInfo, {
		Size = originalSettingsSize,
		Position = originalSettingsPosition
	})

	tween:Play()
	updateSettingsButtons()
end

local function closeSettings()
	if not isSettingsOpen then return end
	isSettingsOpen = false

	local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In)
	local tween = TweenService:Create(settingsBackground, tweenInfo, {
		Size = UDim2.new(0, 0, 0, 0),
		Position = UDim2.new(0.5, 0, 0.5, 0)
	})

	tween:Play()
	tween.Completed:Connect(function()
		settingsBackground.Visible = false
		settingsGui.Enabled = false
		settingsBackground.Size = originalSettingsSize
		settingsBackground.Position = originalSettingsPosition
	end)
end

-- Settings button connections
settingsButton.MouseButton1Click:Connect(function()
	debugPrint("Settings button clicked")
	if isSettingsOpen then
		closeSettings()
	else
		openSettings()
	end
end)

settingsExitButton.MouseButton1Click:Connect(function()
	closeSettings()
end)

musicButton.MouseButton1Click:Connect(function()
	isMusicOn = not isMusicOn
	if isMusicOn then
		mainTheme:Play()
	else
		mainTheme:Stop()
	end
	updateSettingsButtons()
end)

qualityButton.MouseButton1Click:Connect(function()
	isRealisticQuality = not isRealisticQuality

	if isRealisticQuality then
		Lighting.Brightness = 1
		Lighting.GlobalShadows = true
		Lighting.ShadowSoftness = 0.2
		local blur = Lighting:FindFirstChildOfClass("BlurEffect")
		if blur then blur.Size = 0 end
	else
		Lighting.Brightness = 2
		Lighting.GlobalShadows = false
		Lighting.ShadowSoftness = 1
		local blur = Lighting:FindFirstChildOfClass("BlurEffect")
		if blur then blur.Size = 0 end
	end

	updateSettingsButtons()
end)

popupsButton.MouseButton1Click:Connect(function()
	arePopupsEnabled = not arePopupsEnabled
	popupScreenGui.Enabled = arePopupsEnabled
	updateSettingsButtons()
end)

-- ======================
-- STATS SYSTEM
-- ======================
local statsBackground = statsGui:WaitForChild("StatsBackground")
local statsExitButton = findClickableButton(statsBackground:WaitForChild("ExitButton"))
local statsFrame = statsBackground:WaitForChild("Background")

local pooBucksBackground = statsFrame:WaitForChild("PooBucksStatsBackground")
local pooBucksLabel = pooBucksBackground:WaitForChild("PooBucksLabel")

local poopsBackground = statsFrame:WaitForChild("PoopsStatsBackground")
local poopsLabel = poopsBackground:WaitForChild("PoopsStatsLabel")

local rebirthsBackground = statsFrame:WaitForChild("RebirthsStatsBackground")
local rebirthsLabel = rebirthsBackground:WaitForChild("RebirthStatsLabel")

local leaderstats = player:WaitForChild("leaderstats")

local isStatsOpen = false
local statsUpdateConnection = nil
local originalStatsSize = statsBackground.Size
local originalStatsPosition = statsBackground.Position

local function formatNumber(num)
	if num >= 1e12 then
		return string.format("%.1fT", num / 1e12)
	elseif num >= 1e9 then
		return string.format("%.1fB", num / 1e9)
	elseif num >= 1e6 then
		return string.format("%.1fM", num / 1e6)
	elseif num >= 1e3 then
		return string.format("%.1fK", num / 1e3)
	else
		return tostring(math.floor(num))
	end
end

local function updateStats()
	local pooBucks = leaderstats:FindFirstChild("PooBucks")
	local poops = leaderstats:FindFirstChild("Poops")
	local rebirths = leaderstats:FindFirstChild("Rebirths")

	if pooBucks then pooBucksLabel.Text = formatNumber(pooBucks.Value) end
	if poops then poopsLabel.Text = formatNumber(poops.Value) end
	if rebirths then rebirthsLabel.Text = formatNumber(rebirths.Value) end
end

local function openStats()
	if isStatsOpen then return end
	isStatsOpen = true

	statsGui.Enabled = true
	statsBackground.Size = UDim2.new(0, 0, 0, 0)
	statsBackground.Position = UDim2.new(0.5, 0, 0.5, 0)
	statsBackground.Visible = true

	local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
	local tween = TweenService:Create(statsBackground, tweenInfo, {
		Size = originalStatsSize,
		Position = originalStatsPosition
	})

	tween:Play()
	updateStats()
	statsUpdateConnection = RunService.Heartbeat:Connect(updateStats)
end

local function closeStats()
	if not isStatsOpen then return end
	isStatsOpen = false

	if statsUpdateConnection then
		statsUpdateConnection:Disconnect()
		statsUpdateConnection = nil
	end

	local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In)
	local tween = TweenService:Create(statsBackground, tweenInfo, {
		Size = UDim2.new(0, 0, 0, 0),
		Position = UDim2.new(0.5, 0, 0.5, 0)
	})

	tween:Play()
	tween.Completed:Connect(function()
		statsBackground.Visible = false
		statsGui.Enabled = false
		statsBackground.Size = originalStatsSize
		statsBackground.Position = originalStatsPosition
	end)
end

statsButton.MouseButton1Click:Connect(function()
	debugPrint("Stats button clicked")
	if isStatsOpen then  -  Edit
  12:31:15.427  		closeStats()
	else
		openStats()
	end
end)

statsExitButton.MouseButton1Click:Connect(function()
	closeStats()
end)

-- ======================
-- GROUP REWARDS SYSTEM
-- ======================
local groupRewardsBackground = groupRewardsGui:WaitForChild("StatsBackground")
local groupExitButton = findClickableButton(groupRewardsBackground:WaitForChild("ExitButton"))
local verifyButton = findClickableButton(groupRewardsBackground:WaitForChild("VerifyButton"))

local isGroupRewardsOpen = false
local originalGroupSize = groupRewardsBackground.Size
local originalGroupPosition = groupRewardsBackground.Position

local function openGroupRewards()
	if isGroupRewardsOpen then return end
	isGroupRewardsOpen = true

	groupRewardsGui.Enabled = true
	groupRewardsBackground.Size = UDim2.new(0, 0, 0, 0)
	groupRewardsBackground.Position = UDim2.new(0.5, 0, 0.5, 0)
	groupRewardsBackground.Visible = true

	local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
	local tween = TweenService:Create(groupRewardsBackground, tweenInfo, {
		Size = originalGroupSize,
		Position = originalGroupPosition
	})

	tween:Play()
end

local function closeGroupRewards()
	if not isGroupRewardsOpen then return end
	isGroupRewardsOpen = false

	local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In)
	local tween = TweenService:Create(groupRewardsBackground, tweenInfo, {
		Size = UDim2.new(0, 0, 0, 0),
		Position = UDim2.new(0.5, 0, 0.5, 0)
	})

	tween:Play()
	tween.Completed:Connect(function()
		groupRewardsBackground.Visible = false
		groupRewardsGui.Enabled = false
		groupRewardsBackground.Size = originalGroupSize
		groupRewardsBackground.Position = originalGroupPosition
	end)
end

groupRewardsButton.MouseButton1Click:Connect(function()
	debugPrint("Group rewards button clicked")
	if isGroupRewardsOpen then
		closeGroupRewards()
	else
		openGroupRewards()
	end
end)

groupExitButton.MouseButton1Click:Connect(function()
	closeGroupRewards()
end)

verifyButton.MouseButton1Click:Connect(function()
	debugPrint("Group verify button clicked")

	-- Store original button state
	local originalText = verifyButton.Text
	local originalColor = verifyButton.BackgroundColor3

	-- Disable button immediately
	verifyButton.Text = "VERIFYING..."
	verifyButton.BackgroundColor3 = Color3.fromRGB(128, 128, 128)
	verifyButton.Active = false

	spawn(function()
		-- Get remote function
		local groupRewardsRemote = ReplicatedStorage:WaitForChild("GroupRewardsRemote")

		-- Call server
		local success, isSuccess, message = pcall(function()
			return groupRewardsRemote:InvokeServer()
		end)

		if success then
			if isSuccess then
				print("✅ " .. message)
				verifyButton.Text = "SUCCESS!"
				verifyButton.BackgroundColor3 = Color3.fromRGB(46, 125, 50)
			else
				print("❌ " .. message)
				verifyButton.Text = "FAILED"
				verifyButton.BackgroundColor3 = Color3.fromRGB(244, 67, 54)
			end
		else
			print("❌ Connection error: " .. tostring(isSuccess))
			verifyButton.Text = "ERROR"
			verifyButton.BackgroundColor3 = Color3.fromRGB(244, 67, 54)
		end

		-- Wait then restore button
		wait(3)
		verifyButton.Text = originalText
		verifyButton.BackgroundColor3 = originalColor
		verifyButton.Active = true
	end)
end)

-- ======================
-- SETUP ALL BUTTON EFFECTS
-- ======================
-- Main navigation buttons
createHoverEffect(shopButton)
createHoverEffect(settingsButton)
createHoverEffect(statsButton)
createHoverEffect(groupRewardsButton)

-- Settings buttons
createHoverEffect(settingsExitButton)
createHoverEffect(musicButton, {skipColorEffect = true})
createHoverEffect(qualityButton, {skipColorEffect = true})
createHoverEffect(popupsButton, {skipColorEffect = true})

-- Stats buttons
createHoverEffect(statsExitButton)

-- Group rewards buttons
createHoverEffect(groupExitButton)
createHoverEffect(verifyButton)

-- Initialize
updateSettingsButtons()
debugPrint("MainGuiHandler loaded successfully!")

>>> game.StarterPlayer.StarterPlayerScripts.PoopScript (LocalScript) — 540 lines
-- PoopScript (StarterPlayerScripts) - FIXED WITH DYNAMIC CLEANUP & BETTER HIGHLIGHTS
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local SoundService = game:GetService("SoundService")

local player = Players.LocalPlayer

-- DEBUG SYSTEM
local DEBUG = true -- Set to false to disable debug prints

local function debugPrint(message)
	if DEBUG then
		print("[POOP DEBUG]: " .. message)
	end
end

-- CONFIGURABLE CONSTANTS
local ANIMATION_TIMEOUT = 0.3
local BASE_POOP_CLEANUP_TIME = 3 -- Base cleanup time
local CLEANUP_TIME_INCREMENT = 0.1 -- Add this much time per poop on screen
local MAX_CLEANUP_TIME = 8 -- Maximum cleanup time
local FADE_DURATION = 0.3
local POOP_DISTANCE_BEHIND = 2
local POOP_Y_OFFSET = 0.5
local ANIMATION_ID = "rbxassetid://90164930719674"
local SOUND_ID = "rbxassetid://98112849852832"


-- Wait for required objects
local poopFolder = ReplicatedStorage:WaitForChild("PoopFolder")
local poopSpawnedEvent = ReplicatedStorage:WaitForChild("PoopSpawnedEvent")
local ShopConfig = require(ReplicatedStorage:WaitForChild("ShopConfig"))
local GetProductionMultiplierRemote = ReplicatedStorage:WaitForChild("GetProductionMultiplierRemote")

-- Current state
local currentPoopType = "Poop"
local isPooping = false
local activePoops = {} -- Track active poops for dynamic cleanup

-- Cache animation and sound
local cachedAnimationTrack = nil
local poopSound = Instance.new("Sound")
poopSound.SoundId = SOUND_ID
poopSound.Volume = 0.8
poopSound.Parent = workspace

debugPrint("PoopScript initialized")

-- ROBUST: Function to get production multiplier with multiple fallbacks
local function getProductionMultiplier()
	debugPrint("=== GETTING PRODUCTION MULTIPLIER ===")

	-- Method 1: Try global client data (fastest)
	if _G.ClientShopData and _G.ClientShopData.OwnedUpgrades then  -  Edit
  12:31:15.427  		debugPrint("Method 1: Using _G.ClientShopData")
		local highestProductionValue = 1

		for _, upgradeKey in pairs(_G.ClientShopData.OwnedUpgrades) do
			local upgradeConfig = ShopConfig.Upgrades[upgradeKey]
			if upgradeConfig and upgradeConfig.Effect == "ProductionMultiplier" then
				if upgradeConfig.Value > highestProductionValue then
					highestProductionValue = upgradeConfig.Value
					debugPrint("Found upgrade: " .. upgradeKey .. " with value " .. upgradeConfig.Value)
				end
			end
		end

		debugPrint("Method 1 result: " .. highestProductionValue)
		return highestProductionValue
	end

	-- Method 2: Ask server for data
	debugPrint("Method 2: Asking server for production multiplier")
	local success, multiplier = pcall(function()
		return GetProductionMultiplierRemote:InvokeServer()
	end)

	if success and multiplier and multiplier > 1 then
		debugPrint("Method 2 result: " .. multiplier)
		return multiplier
	end

	-- Method 3: Try to get fresh data from shop system
	debugPrint("Method 3: Trying to get fresh shop data")
	local shopGUI = player.PlayerGui:FindFirstChild("ShopGUI")
	if shopGUI then
		-- Try to trigger a data update
		local GetPlayerDataRemote = ReplicatedStorage:FindFirstChild("GetPlayerDataRemote")
		if GetPlayerDataRemote then
			local dataSuccess, freshData = pcall(function()
				return GetPlayerDataRemote:InvokeServer()
			end)

			if dataSuccess and freshData and freshData.OwnedUpgrades then
				debugPrint("Method 3: Got fresh data from server")
				_G.ClientShopData = freshData -- Update global data

				local highestProductionValue = 1
				for _, upgradeKey in pairs(freshData.OwnedUpgrades) do
					local upgradeConfig = ShopConfig.Upgrades[upgradeKey]
					if upgradeConfig and upgradeConfig.Effect == "ProductionMultiplier" then
						if upgradeConfig.Value > highestProductionValue then
							highestProductionValue = upgradeConfig.Value
							debugPrint("Found upgrade: " .. upgradeKey .. " with value " .. upgradeConfig.Value)
						end
					end
				end

				debugPrint("Method 3 result: " .. highestProductionValue)
				return highestProductionValue
			end
		end
	end

	-- Fallback: Default multiplier
	debugPrint("All methods failed, using default: 1")
	return 1
end

-- Function to calculate dynamic cleanup time
local function calculateCleanupTime()
	local poopCount = #activePoops
	local cleanupTime = BASE_POOP_CLEANUP_TIME + (poopCount * CLEANUP_TIME_INCREMENT)
	cleanupTime = math.min(cleanupTime, MAX_CLEANUP_TIME) -- Cap at max

	debugPrint("Active poops: " .. poopCount .. ", Cleanup time: " .. cleanupTime .. "s")
	return cleanupTime
end

-- Function to notify server of poop spawn
local function notifyPoopSpawned()
	local success, _ = pcall(function()
		poopSpawnedEvent:FireServer()
	end)
	if not success then
		debugPrint("Failed to notify server of poop spawn")
	end
end

-- Function to position poop with better spacing
local function positionPoop(newPoop, humanoidRootPart, index)
	debugPrint("=== POSITIONING POOP " .. (index + 1) .. " ===")

	local playerPosition = humanoidRootPart.Position
	local playerCFrame = humanoidRootPart.CFrame
	local playerLookDirection = playerCFrame.LookVector

	-- Better spacing algorithm for multiple poops
	local spreadX = (index % 3 - 1) * 1.5 -- -1.5, 0, 1.5 pattern
	local spreadZ = math.floor(index / 3) * 1.5 -- Rows: 0, 1.5, 3.0
	local randomX = math.random(-0.5, 0.5) + spreadX
	local randomZ = math.random(-0.5, 0.5) + spreadZ

	local behindVector = playerLookDirection * POOP_DISTANCE_BEHIND
	local poopPosition = playerPosition - behindVector + Vector3.new(
		randomX,
		POOP_Y_OFFSET,
		randomZ
	)

	debugPrint("Poop " .. (index + 1) .. " position: " .. tostring(poopPosition))

	-- Position the poop
	if newPoop.PrimaryPart then
		newPoop:SetPrimaryPartCFrame(CFrame.new(poopPosition))
	elseif newPoop:FindFirstChild("Part") then
		newPoop.Part.Position = poopPosition
	else
		for _, child in pairs(newPoop:GetChildren()) do
			if child:IsA("BasePart") then
				child.Position = poopPosition
				break
			end
		end
	end

	debugPrint("=== END POSITIONING POOP " .. (index + 1) .. " ===")
end

-- Function to add physics effects to poop
local function addPhysics(newPoop)
	local parts = newPoop:GetChildren()
	for _, part in pairs(parts) do
		if part:IsA("BasePart") then
			part.Anchored = false
			part.AssemblyLinearVelocity = Vector3.new(
				math.random(-5, 5),
				math.random(2, 8),
				math.random(-5, 5)
			)
		end
	end
end

-- IMPROVED: Black outline highlight function that works with all poop types
local function addHighlight(newPoop)
	local highlight = Instance.new("Highlight")
	highlight.Name = "ClientHighlight"
	highlight.Adornee = newPoop
	highlight.FillColor = Color3.fromRGB(0, 0, 0)
	highlight.OutlineColor = Color3.fromRGB(0, 0, 0)
	highlight.FillTransparency = 1
	highlight.OutlineTransparency = 0
	highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop

	-- Try different parent locations for better compatibility
	local success = pcall(function()
		highlight.Parent = newPoop
	end)

	if not success then
		-- If can't parent to model, try parenting to workspace
		success = pcall(function()
			highlight.Parent = workspace
		end)

		if success then
			debugPrint("Highlight parented to workspace instead of model")
		else
			debugPrint("Failed to create highlight for " .. currentPoopType)
			return nil
		end
	end

	debugPrint("Added black outline highlight to " .. currentPoopType)
	return highlight
end

-- Function to setup poop cleanup and fade with dynamic timing
local function setupCleanup(newPoop)
	-- Add to active poops
	table.insert(activePoops, newPoop)

	spawn(function()
		local cleanupTime = calculateCleanupTime()
		wait(cleanupTime)

		-- Remove from active poops
		for i, poop in ipairs(activePoops) do
			if poop == newPoop then
				table.remove(activePoops, i)
				break
			end
		end

		local fadeInfo = TweenInfo.new(FADE_DURATION, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
		local highlight = newPoop:FindFirstChild("ClientHighlight")

		-- If highlight is in workspace, find it differently
		if not highlight then
			for _, obj in pairs(workspace:GetChildren()) do
				if obj:IsA("Highlight") and obj.Name == "ClientHighlight" and obj.Adornee == newPoop then
					highlight = obj
					break  -  Edit
  12:31:15.427  				end
			end
		end

		-- Fade all parts
		for _, part in pairs(newPoop:GetDescendants()) do
			if part:IsA("BasePart") then
				local success, tween = pcall(function()
					return TweenService:Create(part, fadeInfo, {Transparency = 1})
				end)
				if success then
					tween:Play()
				end
			elseif part:IsA("Decal") or part:IsA("Texture") then
				-- Handle decals/textures for special poop types
				local success, tween = pcall(function()
					return TweenService:Create(part, fadeInfo, {Transparency = 1})
				end)
				if success then
					tween:Play()
				end
			end
		end

		-- Fade highlight
		if highlight then
			local highlightFadeTween = TweenService:Create(highlight, fadeInfo, {
				OutlineTransparency = 1
			})
			highlightFadeTween:Play()
		end

		-- Clean up after fade
		Debris:AddItem(newPoop, FADE_DURATION)
		if highlight and highlight.Parent == workspace then
			Debris:AddItem(highlight, FADE_DURATION)
		end
	end)
end

-- Function to spawn a single poop
local function spawnSinglePoop(index)
	local character = player.Character
	if not character then 
		debugPrint("No character found")
		return 
	end

	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then 
		debugPrint("No HumanoidRootPart found")
		return 
	end

	-- Get the current poop model
	local poopModel = poopFolder:FindFirstChild(currentPoopType)
	if not poopModel then
		debugPrint("Poop model '" .. currentPoopType .. "' not found!")
		return
	end

	-- Clone the poop model
	local newPoop = poopModel:Clone()

	-- Position the poop
	positionPoop(newPoop, humanoidRootPart, index)

	-- Parent to workspace
	newPoop.Parent = workspace

	-- Add highlight and physics
	addHighlight(newPoop)
	addPhysics(newPoop)
	setupCleanup(newPoop)

	debugPrint("Successfully spawned poop " .. (index + 1))
end

-- FIXED: Function to spawn multiple poops based on upgrades
local function actuallySpawnPoop()
	local productionMultiplier = getProductionMultiplier()
	local poopsToSpawn = math.floor(productionMultiplier)

	debugPrint("=== SPAWNING POOPS ===")
	debugPrint("Production multiplier: " .. productionMultiplier)
	debugPrint("Poops to spawn: " .. poopsToSpawn)

	-- Spawn all poops with slight delays
	for i = 1, poopsToSpawn do
		spawn(function()
			-- Stagger the spawning for visual effect
			wait((i - 1) * 0.05) -- 0.05 second delay between each poop
			spawnSinglePoop(i - 1) -- Pass index starting from 0
		end)
	end

	-- Notify server once (server handles its own multiplier calculation)
	notifyPoopSpawned()

	debugPrint("=== FINISHED SPAWNING POOPS ===")
end

-- Function to load and cache animation
local function loadAnimation(humanoid)
	if cachedAnimationTrack then
		return cachedAnimationTrack
	end

	local success, result = pcall(function()
		local animation = Instance.new("Animation")
		animation.AnimationId = ANIMATION_ID
		return humanoid:LoadAnimation(animation)
	end)

	if success then
		cachedAnimationTrack = result
		debugPrint("Animation loaded successfully")
		return cachedAnimationTrack
	else
		debugPrint("Failed to load poop animation")
		return nil
	end
end

-- Main spawn poop function with animation
local function spawnPoop()
	if isPooping then 
		debugPrint("Already pooping - ignoring input")
		return 
	end

	local character = player.Character
	if not character then 
		debugPrint("No character - cannot poop")
		return 
	end

	local humanoid = character:FindFirstChild("Humanoid")
	if not humanoid then 
		debugPrint("No humanoid - cannot poop")
		return 
	end

	debugPrint("🚽 STARTING POOP SEQUENCE 🚽")

	-- Set cooldown
	isPooping = true

	-- Store original values
	local originalWalkSpeed = humanoid.WalkSpeed
	local originalJumpPower = humanoid.JumpPower

	-- Lock movement
	humanoid.WalkSpeed = 0
	humanoid.JumpPower = 0

	-- Load and play poop animation
	local animationTrack = loadAnimation(humanoid)

	local poopSpawned = false
	local function spawnOnce()
		if not poopSpawned then
			poopSpawned = true

			-- Restore movement
			humanoid.WalkSpeed = originalWalkSpeed
			humanoid.JumpPower = originalJumpPower

			-- Spawn the actual poop(s)
			actuallySpawnPoop()

			-- Reset cooldown
			isPooping = false
			debugPrint("💩 POOP SEQUENCE COMPLETED 💩")
		end
	end

	if animationTrack then
		-- Play animation
		animationTrack:Play()
		debugPrint("Playing poop animation")

		-- Play poop sound
		local success, _ = pcall(function()
			poopSound:Play()
		end)
		if not success then
			debugPrint("Failed to play poop sound")
		end

		-- Connect to animation end
		animationTrack.Ended:Connect(spawnOnce)
	else
		-- If no animation, play sound immediately
		local success, _ = pcall(function()
			poopSound:Play()
		end)
		if not success then
			debugPrint("Failed to play poop sound")
		end  -  Edit
  12:31:15.427  	end

	-- Backup timer
	spawn(function()
		wait(ANIMATION_TIMEOUT)
		spawnOnce()
	end)
end

-- Function to change poop type
local function changePoopType(newType)
	if poopFolder:FindFirstChild(newType) then
		currentPoopType = newType
		debugPrint("Changed poop type to: " .. newType)
	else
		debugPrint("Poop type '" .. newType .. "' not found in PoopFolder!")
	end
end

-- Make functions globally accessible
_G.spawnPoop = spawnPoop
_G.changePoopType = changePoopType

-- Key input handling
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end

	if input.KeyCode == Enum.KeyCode.P then
		debugPrint("P key pressed")
		spawnPoop()
	end
end)

-- IMPROVED: Initialize shop data when script loads
spawn(function()
	wait(2) -- Wait for everything to load
	currentPoopType = ShopConfig.DefaultPoop

	-- Try to get initial shop data
	wait(1)
	local success = pcall(function()
		local GetPlayerDataRemote = ReplicatedStorage:FindFirstChild("GetPlayerDataRemote")
		if GetPlayerDataRemote then
			local data = GetPlayerDataRemote:InvokeServer()
			if data then
				_G.ClientShopData = data
				debugPrint("Initialized shop data on script load")
			end
		end
	end)

	if not success then
		debugPrint("Failed to initialize shop data on load")
	end

	debugPrint("Initialized with default poop: " .. currentPoopType)
end)

-- Clean up on character removal
player.CharacterRemoving:Connect(function()
	-- Clear active poops tracking
	activePoops = {}

	-- Clear cached animation
	if cachedAnimationTrack then
		cachedAnimationTrack:Stop()
		cachedAnimationTrack = nil
	end

	debugPrint("Character removing - cleaned up poop system")
end)

-- Debug command to check active poops (optional)
spawn(function()
	while true do
		wait(10) -- Every 10 seconds
		if #activePoops > 0 then
			debugPrint("Active poops on screen: " .. #activePoops)
		end
	end
end)

debugPrint("PoopScript setup complete with dynamic cleanup and improved highlights!")

>>> game.StarterPlayer.StarterPlayerScripts.PortalClient (LocalScript) — 134 lines
-- PortalClient (LocalScript in StarterPlayerScripts)
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Get ShopConfig
local ShopConfig = require(ReplicatedStorage:WaitForChild("ShopConfig"))

-- Debug system
local function debugPrint(message)
	if ShopConfig.Debug.Enabled and ShopConfig.Debug.ShowZoneDebug then
		print("[PORTAL CLIENT]: " .. message)
	end
end

-- Wait for RemoteEvents
local PortalTeleportClient = ReplicatedStorage:WaitForChild("PortalTeleportClient", 10)
if not PortalTeleportClient then
	warn("PortalTeleportClient RemoteEvent not found!")
	return
end

-- Create fade frame
local function createFadeFrame()
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "PortalFadeGui"
	screenGui.ResetOnSpawn = false
	screenGui.IgnoreGuiInset = true
	screenGui.Parent = playerGui

	local frame = Instance.new("Frame")
	frame.Name = "FadeFrame"
	frame.Size = UDim2.new(1, 0, 1, 0)
	frame.Position = UDim2.new(0, 0, 0, 0)
	frame.BackgroundColor3 = Color3.new(0, 0, 0)
	frame.BackgroundTransparency = 1
	frame.BorderSizePixel = 0
	frame.ZIndex = 10
	frame.Parent = screenGui

	local teleportLabel = Instance.new("TextLabel")
	teleportLabel.Name = "TeleportLabel"
	teleportLabel.Size = UDim2.new(0, 300, 0, 50)
	teleportLabel.Position = UDim2.new(0.5, -150, 0.5, -25)
	teleportLabel.BackgroundTransparency = 1
	teleportLabel.Text = "Teleporting..."
	teleportLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	teleportLabel.TextSize = 24
	teleportLabel.Font = Enum.Font.GothamBold
	teleportLabel.TextTransparency = 1
	teleportLabel.ZIndex = 11
	teleportLabel.Parent = frame

	return frame, teleportLabel
end

local fadeFrame, teleportLabel = createFadeFrame()

-- Sound setup
local teleportSound = Instance.new("Sound")
teleportSound.SoundId = ShopConfig.Portals.Effects.TeleportSoundId
teleportSound.Volume = ShopConfig.Portals.Effects.Volume
teleportSound.Parent = workspace

local errorSound = Instance.new("Sound")
errorSound.SoundId = ShopConfig.Portals.Effects.RequirementNotMetSound
errorSound.Volume = ShopConfig.Portals.Effects.Volume
errorSound.Parent = workspace

-- Fade effects
local function fadeOut(duration, callback)
	local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

	local frameTween = TweenService:Create(fadeFrame, tweenInfo, {
		BackgroundTransparency = 0
	})

	local labelTween = TweenService:Create(teleportLabel, tweenInfo, {
		TextTransparency = 0
	})

	frameTween:Play()
	labelTween:Play()

	if callback then
		frameTween.Completed:Connect(callback)
	end
end

local function fadeIn(duration, callback)
	local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

	local frameTween = TweenService:Create(fadeFrame, tweenInfo, {
		BackgroundTransparency = 1
	})

	local labelTween = TweenService:Create(teleportLabel, tweenInfo, {
		TextTransparency = 1
	})

	frameTween:Play()
	labelTween:Play()

	if callback then
		frameTween.Completed:Connect(callback)
	end
end

-- Handle teleport events from server
PortalTeleportClient.OnClientEvent:Connect(function(eventType, data)
	debugPrint("Portal event: " .. eventType)
  -  Edit
  12:31:15.429  	if eventType == "TeleportStart" then
		teleportSound:Play()
		fadeOut(0.3)

	elseif eventType == "TeleportComplete" then
		wait(0.2) -- Small delay
		fadeIn(0.5)

	elseif eventType == "TeleportFailed" then
		errorSound:Play()
		fadeIn(0.3)

	elseif eventType == "RequirementNotMet" then
		debugPrint("Portal requirement not met: " .. (data.message or "Unknown"))
		errorSound:Play()
	end
end)

debugPrint("PortalClient initialized")

>>> game.StarterPlayer.StarterPlayerScripts.TutorialClient (LocalScript) — 916 lines
-- TutorialClient (LocalScript in StarterPlayerScripts) - FULLY DATA-DRIVEN SYSTEM WITH SKIP
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Wait for tutorial config and events
local TutorialConfig = require(ReplicatedStorage:WaitForChild("TutorialConfig"))

local TutorialStepCompleted = ReplicatedStorage:WaitForChild("TutorialStepCompleted")
local TutorialProgressUpdate = ReplicatedStorage:WaitForChild("TutorialProgressUpdate")
local StartTutorial = ReplicatedStorage:WaitForChild("StartTutorial")
local GetTutorialStatus = ReplicatedStorage:WaitForChild("GetTutorialStatus")

-- Debug system
local function debugPrint(message)
	if TutorialConfig.Debug.Enabled and TutorialConfig.Debug.ShowTutorialDebug then
		print("[TUTORIAL CLIENT]: " .. message)
	end
end

-- Wait for tutorial GUI
local tutorialScreenGui = playerGui:WaitForChild("TutorialScreenGui")
local background = tutorialScreenGui:WaitForChild("Background")
local titleLabel = background:WaitForChild("Title")
local tutorialTextLabel = background:WaitForChild("TutorialText")
local nextButton = background:WaitForChild("NextButton")
local skipButton = background:WaitForChild("SkipButton") -- Skip button

-- Get notification GUI
local notificationScreenGui = playerGui:FindFirstChild("NotificationScreenGui") or 
	playerGui:FindFirstChild("NotificationGui") or
	playerGui:FindFirstChild("PopupScreenGui")

-- Tutorial state
local currentStepData = nil
local currentStepIndex = 0
local isTutorialActive = false
local isAnimating = false

-- CLIENT-SIDE BEAM MANAGEMENT
local currentPlayerAttachment = nil
local activeBeams = {}
local TutorialParts = workspace:WaitForChild("TutorialParts")

-- Original GUI states
local originalSize = background.Size
local originalPosition = background.Position
local originalNotificationState = nil

-- Button animation states
local buttonOriginalSize = nextButton.Size
local buttonOriginalPosition = nextButton.Position
local buttonOriginalColor = nextButton.BackgroundColor3
local isButtonHovering = false

-- Skip button animation states
local skipButtonOriginalSize = skipButton.Size
local skipButtonOriginalColor = skipButton.BackgroundColor3
local isSkipButtonHovering = false

debugPrint("TutorialClient initializing...")

-- CLIENT-SIDE: Function to create attachment on player's character
local function createPlayerAttachment()
	local character = player.Character
	if not character then 
		debugPrint("No character for player")
		return nil 
	end

	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then 
		debugPrint("No HumanoidRootPart for player")
		return nil 
	end

	-- Remove any existing tutorial attachment
	if currentPlayerAttachment then
		currentPlayerAttachment:Destroy()
		currentPlayerAttachment = nil
	end

	-- Create new attachment
	local attachment = Instance.new("Attachment")
	attachment.Name = "TutorialBeamAttachment_Client"
	attachment.Position = Vector3.new(0, 0, 0) -- Center of torso
	attachment.Parent = humanoidRootPart

	currentPlayerAttachment = attachment
	debugPrint("Created client-side player attachment")
	return attachment
end

-- CLIENT-SIDE: Function to cleanup player beam attachments
local function cleanupPlayerBeamAttachment()
	if currentPlayerAttachment then
		currentPlayerAttachment:Destroy()
		currentPlayerAttachment = nil
		debugPrint("Cleaned up client-side beam attachment")
	end
end

-- CLIENT-SIDE: Function to create a beam clone for the player
local function createClientBeam(originalBeam, attachment0, attachment1)
	local beamClone = originalBeam:Clone()
	beamClone.Name = "TutorialBeam_Client"
	beamClone.Attachment0 = attachment0
	beamClone.Attachment1 = attachment1
	beamClone.Enabled = true
	beamClone.Parent = attachment0.Parent

	return beamClone
end

-- CLIENT-SIDE: Function to setup beam visibility (CLIENT ONLY)
local function updateBeamVisibility(stepConfig)
	debugPrint("=== CLIENT BEAM VISIBILITY DEBUG START ===")
	debugPrint("Step: " .. (stepConfig.StepID or "Unknown"))
	debugPrint("ShowBeam: " .. tostring(stepConfig.ShowBeam))
	debugPrint("BeamTarget: " .. tostring(stepConfig.BeamTarget))

	-- Clean up all active beams
	for _, beam in pairs(activeBeams) do
		if beam and beam.Parent then
			beam:Destroy()
		end
	end
	activeBeams = {}

	-- Clean up player attachment
	cleanupPlayerBeamAttachment()

	-- Show specific beam if needed and attach to player
	if stepConfig.ShowBeam and stepConfig.BeamTarget then
		debugPrint("Attempting to show beam for target: " .. stepConfig.BeamTarget)
		local beamConfig = TutorialConfig.TutorialParts.BeamParts[stepConfig.BeamTarget]
		if beamConfig then
			debugPrint("Found beam config for: " .. stepConfig.BeamTarget)
			local beamPart = TutorialParts:FindFirstChild(beamConfig.PartName)
			if beamPart then
				debugPrint("Found target beam part: " .. beamConfig.PartName)
				local attachment = beamPart:FindFirstChild(beamConfig.AttachmentName)
				if attachment then
					debugPrint("Found target attachment: " .. beamConfig.AttachmentName)
					local originalBeam = attachment:FindFirstChild(beamConfig.BeamName)
					if originalBeam then
						debugPrint("Found target beam: " .. beamConfig.BeamName)

						-- Create player attachment
						local playerAttachment = createPlayerAttachment()
						if playerAttachment then
							-- Create a client-side beam clone
							local clientBeam = createClientBeam(originalBeam, attachment, playerAttachment)
							table.insert(activeBeams, clientBeam)

							debugPrint("SUCCESS: Created client-side beam for " .. beamConfig.BeamName)
						else
							debugPrint("FAILED: Could not create player attachment")
						end
					else
						debugPrint("FAILED: Could not find beam: " .. beamConfig.BeamName)
					end
				else
					debugPrint("FAILED: Could not find attachment: " .. beamConfig.AttachmentName)
				end
			else
				debugPrint("FAILED: Could not find beam part: " .. beamConfig.PartName)
			end
		else
			debugPrint("FAILED: No beam config found for: " .. stepConfig.BeamTarget)
		end
	else
		debugPrint("No beam to show")
	end  -  Edit
  12:31:15.429  
	debugPrint("=== CLIENT BEAM VISIBILITY DEBUG END ===")
end

-- Function to find UI elements with their associated strokes
local function getElementStrokePairs(parent)
	local elementPairs = {}

	local function findElementsRecursive(obj)
		if obj:IsA("GuiObject") then
			local elementData = {
				element = obj,
				strokes = {},
				corners = {},
				shadows = {}
			}

			for _, child in ipairs(obj:GetChildren()) do
				if child:IsA("UIStroke") then
					table.insert(elementData.strokes, child)
				elseif child:IsA("UICorner") then
					table.insert(elementData.corners, child)
				elseif child:IsA("ImageLabel") and string.find(string.lower(child.Name), "shadow") then
					table.insert(elementData.shadows, child)
				end
			end

			table.insert(elementPairs, elementData)
		end

		for _, child in ipairs(obj:GetChildren()) do
			findElementsRecursive(child)
		end
	end

	findElementsRecursive(parent)
	return elementPairs
end

-- Function to create button hover effect (generic for both buttons)
local function createButtonHoverEffect(button, originalSize, originalColor)
	local currentTween = nil
	local isHovering = false

	button.MouseEnter:Connect(function()
		if not button.Interactable then return end
		isHovering = true

		if currentTween then currentTween:Cancel() end

		local config = TutorialConfig.GUI.ButtonHover
		local tweenInfo = TweenInfo.new(
			config.Duration,
			config.EasingStyle,
			config.EasingDirection
		)

		local newSize = UDim2.new(
			originalSize.X.Scale * config.ScaleMultiplier,
			originalSize.X.Offset * config.ScaleMultiplier,
			originalSize.Y.Scale * config.ScaleMultiplier,
			originalSize.Y.Offset * config.ScaleMultiplier
		)

		local newColor = Color3.new(
			math.min(1, originalColor.R * config.ColorBrightness),
			math.min(1, originalColor.G * config.ColorBrightness),
			math.min(1, originalColor.B * config.ColorBrightness)
		)

		currentTween = TweenService:Create(button, tweenInfo, {
			Size = newSize,
			BackgroundColor3 = newColor
		})

		currentTween:Play()
	end)

	button.MouseLeave:Connect(function()
		isHovering = false

		if currentTween then currentTween:Cancel() end

		local config = TutorialConfig.GUI.ButtonHover
		local tweenInfo = TweenInfo.new(
			config.Duration,
			config.EasingStyle,
			config.EasingDirection
		)

		currentTween = TweenService:Create(button, tweenInfo, {
			Size = originalSize,
			BackgroundColor3 = originalColor
		})

		currentTween:Play()
	end)

	button.MouseButton1Down:Connect(function()
		if not button.Interactable then return end

		if currentTween then currentTween:Cancel() end

		local config = TutorialConfig.GUI.ButtonClick
		local tweenInfo = TweenInfo.new(
			config.Duration,
			config.EasingStyle,
			config.EasingDirection
		)

		local newSize = UDim2.new(
			originalSize.X.Scale * config.ScaleMultiplier,
			originalSize.X.Offset * config.ScaleMultiplier,
			originalSize.Y.Scale * config.ScaleMultiplier,
			originalSize.Y.Offset * config.ScaleMultiplier
		)

		currentTween = TweenService:Create(button, tweenInfo, {
			Size = newSize
		})

		currentTween:Play()
	end)

	button.MouseButton1Up:Connect(function()
		if not button.Interactable then return end

		if currentTween then currentTween:Cancel() end

		local config = TutorialConfig.GUI.ButtonHover
		local tweenInfo = TweenInfo.new(
			config.Duration,
			Enum.EasingStyle.Back,
			Enum.EasingDirection.Out
		)

		local targetSize = isHovering and UDim2.new(
			originalSize.X.Scale * config.ScaleMultiplier,
			originalSize.X.Offset * config.ScaleMultiplier,
			originalSize.Y.Scale * config.ScaleMultiplier,
			originalSize.Y.Offset * config.ScaleMultiplier
		) or originalSize

		currentTween = TweenService:Create(button, tweenInfo, {
			Size = targetSize
		})

		currentTween:Play()
	end)
end

-- Function to manage notification GUI
local function hideNotificationGUI()
	if notificationScreenGui then
		originalNotificationState = notificationScreenGui.Enabled
		notificationScreenGui.Enabled = false
		debugPrint("Hidden notification GUI during tutorial: " .. notificationScreenGui.Name)
	else
		debugPrint("No notification GUI found to hide")
	end
end

local function restoreNotificationGUI()
	if notificationScreenGui and originalNotificationState ~= nil then
		notificationScreenGui.Enabled = originalNotificationState
		debugPrint("Restored notification GUI after tutorial: " .. notificationScreenGui.Name)
	end
end

-- Function to animate element with its strokes perfectly synchronized
local function animateElementWithStrokes(elementData, tweenInfo, targetProperties, delay)
	delay = delay or 0

	spawn(function()
		wait(delay)

		local elementTween = TweenService:Create(elementData.element, tweenInfo, targetProperties)

		local strokeTweens = {}
		for _, stroke in ipairs(elementData.strokes) do
			local strokeProperties = {}

			if targetProperties.BackgroundTransparency then
				strokeProperties.Transparency = targetProperties.BackgroundTransparency
			end
			if targetProperties.TextTransparency then
				strokeProperties.Transparency = targetProperties.TextTransparency
			end
			if targetProperties.ImageTransparency then
				strokeProperties.Transparency = targetProperties.ImageTransparency
			end

			if next(strokeProperties) then
				local strokeTween = TweenService:Create(stroke, tweenInfo, strokeProperties)
				table.insert(strokeTweens, strokeTween)
			end
		end

		elementTween:Play()
		for _, strokeTween in ipairs(strokeTweens) do  -  Edit
  12:31:15.429  			strokeTween:Play()
		end
	end)
end

-- Function to get background strokes specifically
local function getBackgroundStrokes()
	local strokes = {}
	for _, child in ipairs(background:GetChildren()) do
		if child:IsA("UIStroke") then
			table.insert(strokes, child)
		end
	end
	return strokes
end

-- Function to show tutorial GUI with ULTRA SMOOTH synchronized animations
local function showTutorialGUI()
	if isAnimating then return end
	isAnimating = true

	debugPrint("Showing tutorial GUI with ultra smooth synchronized animations")

	hideNotificationGUI()
	tutorialScreenGui.Enabled = true

	local elementPairs = getElementStrokePairs(background)
	local backgroundStrokes = getBackgroundStrokes()

	-- Set initial states
	background.Size = UDim2.new(0, 0, 0, 0)
	background.Position = UDim2.new(0.5, 0, 0.5, 0)
	background.BackgroundTransparency = 1

	-- Set background strokes to transparent initially
	for _, stroke in ipairs(backgroundStrokes) do
		stroke.Transparency = 1
	end

	-- Set initial transparency for all elements and their strokes
	for _, elementData in ipairs(elementPairs) do
		local element = elementData.element

		if element == background then continue end

		if element:IsA("Frame") or element:IsA("TextButton") or element:IsA("ImageLabel") then
			element.BackgroundTransparency = 1
		end

		if element:IsA("TextLabel") or element:IsA("TextButton") or element:IsA("TextBox") then
			element.TextTransparency = 1
		end

		if element:IsA("ImageLabel") then
			element.ImageTransparency = 1
		end

		for _, stroke in ipairs(elementData.strokes) do
			stroke.Transparency = 1
		end

		for _, shadow in ipairs(elementData.shadows) do
			shadow.ImageTransparency = 1
		end
	end

	-- Animate background AND its strokes together
	local backgroundTweenInfo = TweenInfo.new(
		TutorialConfig.GUI.TweenDuration,
		TutorialConfig.GUI.EasingStyle,
		TutorialConfig.GUI.EasingDirection
	)

	local backgroundTween = TweenService:Create(background, backgroundTweenInfo, {
		Size = originalSize,
		Position = originalPosition,
		BackgroundTransparency = 0
	})

	-- Animate background strokes simultaneously
	local backgroundStrokeTweens = {}
	for _, stroke in ipairs(backgroundStrokes) do
		local strokeTween = TweenService:Create(stroke, backgroundTweenInfo, {
			Transparency = 0
		})
		table.insert(backgroundStrokeTweens, strokeTween)
	end

	backgroundTween:Play()
	for _, strokeTween in ipairs(backgroundStrokeTweens) do
		strokeTween:Play()
	end

	-- Animate all other elements with perfect stroke synchronization
	local frameIndex = 0
	local textIndex = 0

	for _, elementData in ipairs(elementPairs) do
		local element = elementData.element
		if element == background then continue end

		local tweenInfo = TweenInfo.new(
			TutorialConfig.GUI.TextAppear.Duration,
			TutorialConfig.GUI.TextAppear.EasingStyle,
			TutorialConfig.GUI.TextAppear.EasingDirection
		)

		local targetProperties = {}
		local delay = 0

		if element:IsA("Frame") or element:IsA("ImageLabel") then
			frameIndex = frameIndex + 1
			targetProperties.BackgroundTransparency = element:GetAttribute("OriginalTransparency") or 0
			delay = TutorialConfig.GUI.StaggerDelay * frameIndex

		elseif element:IsA("TextLabel") or element:IsA("TextButton") or element:IsA("TextBox") then
			textIndex = textIndex + 1
			targetProperties.TextTransparency = 0

			if element:IsA("TextButton") then
				targetProperties.BackgroundTransparency = 0
			elseif element.BackgroundTransparency < 1 then
				targetProperties.BackgroundTransparency = 0
			end

			delay = TutorialConfig.GUI.TextStaggerDelay * textIndex

		elseif element:IsA("ImageLabel") then
			frameIndex = frameIndex + 1
			targetProperties.ImageTransparency = element:GetAttribute("OriginalImageTransparency") or 0
			delay = TutorialConfig.GUI.StaggerDelay * frameIndex
		end

		animateElementWithStrokes(elementData, tweenInfo, targetProperties, delay)

		for i, shadow in ipairs(elementData.shadows) do
			spawn(function()
				wait(delay + (0.05 * i))
				local shadowTween = TweenService:Create(shadow, tweenInfo, {
					ImageTransparency = 0.7
				})
				shadowTween:Play()
			end)
		end
	end

	backgroundTween.Completed:Connect(function()
		isAnimating = false
		isTutorialActive = true
		debugPrint("Tutorial GUI shown successfully")
	end)
end

-- Function to hide tutorial GUI
local function hideTutorialGUI()
	if isAnimating or not isTutorialActive then return end
	isAnimating = true

	debugPrint("Hiding tutorial GUI")

	-- Clean up beams when hiding GUI
	updateBeamVisibility({ShowBeam = false})

	local elementPairs = getElementStrokePairs(background)
	local backgroundStrokes = getBackgroundStrokes()

	local frameIndex = 0
	local textIndex = 0

	for _, elementData in ipairs(elementPairs) do
		local element = elementData.element
		if element == background then continue end

		local tweenInfo = TweenInfo.new(
			0.25,
			Enum.EasingStyle.Quint,
			Enum.EasingDirection.In
		)

		local targetProperties = {}
		local delay = 0

		if element:IsA("Frame") or element:IsA("ImageLabel") then
			frameIndex = frameIndex + 1
			targetProperties.BackgroundTransparency = 1
			if element:IsA("ImageLabel") then
				targetProperties.ImageTransparency = 1
			end
			delay = 0.02 * frameIndex

		elseif element:IsA("TextLabel") or element:IsA("TextButton") or element:IsA("TextBox") then
			textIndex = textIndex + 1
			targetProperties.TextTransparency = 1
			targetProperties.BackgroundTransparency = 1
			delay = 0.03 * textIndex
		end

		animateElementWithStrokes(elementData, tweenInfo, targetProperties, delay)

		for i, shadow in ipairs(elementData.shadows) do  -  Edit
  12:31:15.429  			spawn(function()
				wait(delay + (0.02 * i))
				local shadowTween = TweenService:Create(shadow, tweenInfo, {
					ImageTransparency = 1
				})
				shadowTween:Play()
			end)
		end
	end

	spawn(function()
		wait(0.35)

		local backgroundTweenInfo = TweenInfo.new(
			TutorialConfig.GUI.HideTweenDuration,
			TutorialConfig.GUI.HideEasingStyle,
			TutorialConfig.GUI.HideEasingDirection
		)

		local backgroundTween = TweenService:Create(background, backgroundTweenInfo, {
			Size = UDim2.new(0, 0, 0, 0),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			BackgroundTransparency = 1
		})

		local backgroundStrokeTweens = {}
		for _, stroke in ipairs(backgroundStrokes) do
			local strokeTween = TweenService:Create(stroke, backgroundTweenInfo, {
				Transparency = 1
			})
			table.insert(backgroundStrokeTweens, strokeTween)
		end

		backgroundTween:Play()
		for _, strokeTween in ipairs(backgroundStrokeTweens) do
			strokeTween:Play()
		end

		backgroundTween.Completed:Connect(function()
			tutorialScreenGui.Enabled = false
			background.Size = originalSize
			background.Position = originalPosition
			background.BackgroundTransparency = 0

			for _, stroke in ipairs(backgroundStrokes) do
				stroke.Transparency = 0
			end

			for _, elementData in ipairs(elementPairs) do
				local element = elementData.element

				if element == background then continue end

				if element:IsA("TextLabel") or element:IsA("TextButton") or element:IsA("TextBox") then
					element.TextTransparency = 0
					if element:IsA("TextButton") or element.BackgroundTransparency < 1 then
						element.BackgroundTransparency = 0
					end
				end

				if element:IsA("Frame") or element:IsA("ImageLabel") then
					element.BackgroundTransparency = element:GetAttribute("OriginalTransparency") or 0
					if element:IsA("ImageLabel") then
						element.ImageTransparency = element:GetAttribute("OriginalImageTransparency") or 0
					end
				end

				for _, stroke in ipairs(elementData.strokes) do
					stroke.Transparency = 0
				end

				for _, shadow in ipairs(elementData.shadows) do
					shadow.ImageTransparency = 0.7
				end
			end

			isTutorialActive = false
			isAnimating = false
			restoreNotificationGUI()

			debugPrint("Tutorial GUI hidden successfully")
		end)
	end)
end

-- Function to update button state with smooth transitions
local function updateButtonState(newColor, newText, interactable)
	buttonOriginalColor = newColor

	local tweenInfo = TweenInfo.new(
		TutorialConfig.GUI.ButtonStateChange.Duration,
		TutorialConfig.GUI.ButtonStateChange.EasingStyle,
		TutorialConfig.GUI.ButtonStateChange.EasingDirection
	)

	local tween = TweenService:Create(nextButton, tweenInfo, {
		BackgroundColor3 = newColor
	})

	tween:Play()
	nextButton.Text = newText
	nextButton.Interactable = interactable
end

-- Function to update tutorial display with smooth transitions
local function updateTutorialDisplay(stepData, stepIndex)
	currentStepData = stepData
	currentStepIndex = stepIndex

	titleLabel.Text = stepData.Title or "Tutorial"
	tutorialTextLabel.Text = stepData.Text or "Follow the instructions..."

	debugPrint("Updating display for step: " .. stepData.StepID)

	-- Update button state based on requirement type
	local requirementType = TutorialConfig.RequirementTypes[stepData.RequirementType]
	if requirementType then
		if stepData.RequirementType == "ButtonClick" then
			updateButtonState(
				Color3.fromRGB(46, 125, 50), -- Green
				stepData.ButtonText or "Continue",
				true
			)
		elseif stepData.RequirementType == "PurchaseItem" then
			updateButtonState(
				Color3.fromRGB(255, 193, 7), -- Yellow/Orange
				stepData.ButtonText or "Complete the task",
				false
			)
		elseif stepData.RequirementType == "TouchPart" then
			updateButtonState(
				Color3.fromRGB(33, 150, 243), -- Blue
				stepData.ButtonText or "Go to the location",
				false
			)
		elseif stepData.RequirementType == "PoopCount" or stepData.RequirementType == "CollectItems" then
			updateButtonState(
				Color3.fromRGB(150, 150, 150), -- Gray
				stepData.ButtonText or "Continue",
				false
			)
		else
			-- Generic handling for new requirement types
			updateButtonState(
				Color3.fromRGB(150, 150, 150), -- Gray
				stepData.ButtonText or "Continue",
				false
			)
		end
	else
		-- Fallback for unknown requirement types
		updateButtonState(
			Color3.fromRGB(150, 150, 150), -- Gray
			stepData.ButtonText or "Continue",
			false
		)
	end

	-- Update beam visibility based on step
	updateBeamVisibility(stepData)

	debugPrint("Updated tutorial display for step: " .. stepData.StepID)
end

-- Function to handle next button click
local function handleNextButtonClick()
	if not currentStepData or isAnimating then return end

	debugPrint("Next button clicked for step: " .. currentStepData.StepID)

	if currentStepData.RequirementType == "ButtonClick" then
		-- Clean up beams before advancing
		updateBeamVisibility({ShowBeam = false})

		TutorialStepCompleted:FireServer(currentStepData.StepID)
		hideTutorialGUI()
	else
		debugPrint("Button not interactable for this step type: " .. currentStepData.RequirementType)
	end
end

-- Function to handle skip button click
local function handleSkipButtonClick()
	if isAnimating then return end

	debugPrint("Skip button clicked - skipping tutorial")

	-- Clean up beams before skipping
	updateBeamVisibility({ShowBeam = false})

	-- Hide the tutorial GUI
	hideTutorialGUI()

	-- Notify server that tutorial is being skipped (send completion signal)
	TutorialStepCompleted:FireServer("SKIP_TUTORIAL")

	-- Show skip message (NO REWARDS MENTIONED)
	print("🚀 " .. TutorialConfig.CompletionRewards.SkipMessage)
end
  -  Edit
  12:31:15.430  -- Function to show completion message
local function showCompletionMessage()
	if TutorialConfig.CompletionRewards.ShowCompletionMessage then
		print("🎉 " .. TutorialConfig.CompletionRewards.CompletionMessage)
	end
end

-- RemoteEvent connections with error handling
StartTutorial.OnClientEvent:Connect(function(stepData, stepIndex, ownsItem)
	if not stepData then
		debugPrint("ERROR: Received nil stepData")
		return
	end

	debugPrint("Received start tutorial for step: " .. stepData.StepID .. " (Index: " .. stepIndex .. ")")

	-- Handle ownership display
	if ownsItem and stepData.RequirementType == "PurchaseItem" then
		debugPrint("Player already owns " .. stepData.RequiredItem .. ", showing owned state")
		stepData.Text = stepData.Text .. "\n\n✅ You already own " .. stepData.RequiredItem .. "!"
		stepData.RequirementType = "ButtonClick"
		stepData.ButtonText = "Continue"
	end

	-- Wait for any ongoing animations to complete
	wait(0.3)

	-- Force reset GUI state
	tutorialScreenGui.Enabled = false
	isAnimating = false
	isTutorialActive = false

	-- Small delay then show
	wait(0.2)
	updateTutorialDisplay(stepData, stepIndex)
	showTutorialGUI()
end)

TutorialProgressUpdate.OnClientEvent:Connect(function(currentProgress, requiredAmount, requirementMet)
	if not currentStepData then return end

	debugPrint("Progress update: " .. currentProgress .. "/" .. requiredAmount .. " Met: " .. tostring(requirementMet))

	local newText = currentStepData.ProgressFormat and 
		string.format(currentStepData.ProgressFormat, currentProgress) or
		(currentStepData.ButtonText or "Continue")

	if requirementMet then
		updateButtonState(
			Color3.fromRGB(46, 125, 50), -- Green
			"Continue!",
			true
		)
	else
		updateButtonState(
			Color3.fromRGB(150, 150, 150), -- Gray
			newText,
			false
		)
	end
end)

TutorialStepCompleted.OnClientEvent:Connect(function(tutorialComplete)
	debugPrint("Tutorial step completed. Tutorial finished: " .. tostring(tutorialComplete))

	if tutorialComplete then
		showCompletionMessage()
		-- Clean up all beams when tutorial is complete
		updateBeamVisibility({ShowBeam = false})
	end

	hideTutorialGUI()
end)

-- Button connections
nextButton.MouseButton1Click:Connect(function()
	if nextButton.Interactable then
		handleNextButtonClick()
	else
		debugPrint("Button click ignored - button not interactable")
	end
end)

-- Skip button connection
skipButton.MouseButton1Click:Connect(function()
	handleSkipButtonClick()
end)

-- Clean up beams when character respawns
player.CharacterRemoving:Connect(function()
	cleanupPlayerBeamAttachment()
	for _, beam in pairs(activeBeams) do
		if beam and beam.Parent then
			beam:Destroy()
		end
	end
	activeBeams = {}
end)

-- Initialize
tutorialScreenGui.Enabled = false

-- Create hover effects for both buttons
createButtonHoverEffect(nextButton, buttonOriginalSize, buttonOriginalColor)
createButtonHoverEffect(skipButton, skipButtonOriginalSize, skipButtonOriginalColor)

-- Store original transparencies for all elements
spawn(function()
	wait(1)
	local elementPairs = getElementStrokePairs(background)
	for _, elementData in ipairs(elementPairs) do
		local element = elementData.element
		if element:IsA("Frame") or element:IsA("ImageLabel") then
			element:SetAttribute("OriginalTransparency", element.BackgroundTransparency)
			if element:IsA("ImageLabel") then
				element:SetAttribute("OriginalImageTransparency", element.ImageTransparency)
			end
		end
	end
end)

-- Check tutorial status on load
spawn(function()
	wait(5)

	local success, status = pcall(function()
		return GetTutorialStatus:InvokeServer()
	end)

	if success and status and status.needsTutorial then
		debugPrint("Player needs tutorial - waiting for server to start")
	else
		debugPrint("Player doesn't need tutorial")
	end
end)

debugPrint("TutorialClient initialized successfully with full data-driven system and skip functionality!")

>>> game.Workspace.Shop.Trigger.TriggerShopScript (Script) — 91 lines
-- TriggerShopScript (ServerScript inside Workspace.Shop.Trigger) - ENHANCED WITH REMOTE OPENING
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Get the trigger part (this script's parent)
local triggerPart = script.Parent

-- Wait for RemoteEvent
local RemoteEvent_OpenShop = ReplicatedStorage:WaitForChild("RemoteEvent_OpenShop")

-- Create close shop event
local RemoteEvent_CloseShop = Instance.new("RemoteEvent")
RemoteEvent_CloseShop.Name = "RemoteEvent_CloseShop"
RemoteEvent_CloseShop.Parent = ReplicatedStorage

-- Track players in shop area
local playersInShop = {}

-- Track players who opened shop remotely (via button)
local playersInRemoteShop = {}

-- Function to check if player is still touching
local function isPlayerTouchingPart(player, part)
	if not player.Character or not player.Character.PrimaryPart then
		return false
	end

	local character = player.Character
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return false end

	-- Check distance
	local distance = (humanoidRootPart.Position - part.Position).Magnitude
	local maxDistance = math.max(part.Size.X, part.Size.Y, part.Size.Z) -- Add buffer

	return distance <= maxDistance
end

-- ENHANCED: Handle remote shop opening
RemoteEvent_OpenShop.OnServerEvent:Connect(function(player)
	print("RemoteEvent_OpenShop fired by " .. player.Name)

	-- Check if player is already in shop (via trigger)
	if not playersInShop[player] then
		-- Player is opening shop remotely (via button)
		playersInRemoteShop[player] = true
		RemoteEvent_OpenShop:FireClient(player)
		print("Player " .. player.Name .. " opened shop remotely")
	end
end)

-- Handle touches (original trigger functionality)
triggerPart.Touched:Connect(function(hit)
	local player = Players:GetPlayerFromCharacter(hit.Parent)
	if player and not playersInShop[player] then
		playersInShop[player] = true
		-- If player was in remote shop, remove them from that list
		playersInRemoteShop[player] = nil
		RemoteEvent_OpenShop:FireClient(player)
		print("Player " .. player.Name .. " entered shop via trigger")  -  Edit
  12:31:15.430  	end
end)

-- Monitor players leaving shop area
spawn(function()
	while true do
		wait(0.5) -- Check every half second

		-- Check trigger-based shop players
		for player, _ in pairs(playersInShop) do
			if player.Parent and not isPlayerTouchingPart(player, triggerPart) then
				-- Player left the area
				playersInShop[player] = nil
				RemoteEvent_CloseShop:FireClient(player)
				print("Player " .. player.Name .. " left shop trigger area")
			end
		end

		-- Remote shop players stay in shop until they manually close it
		-- (The shop GUI should handle closing for remote players)
	end
end)

-- Clean up when players leave
Players.PlayerRemoving:Connect(function(player)
	playersInShop[player] = nil
	playersInRemoteShop[player] = nil
end)

print("Shop trigger initialized with remote opening support!")

=== Scripts scanned: 81 | Printed: 41 | Skipped duplicates beyond 2: 40 ===  -  Edit
